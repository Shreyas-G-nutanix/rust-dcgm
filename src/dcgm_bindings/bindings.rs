/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
pub const DCGM_FT_BINARY: u8 = 98u8;
pub const DCGM_FT_DOUBLE: u8 = 100u8;
pub const DCGM_FT_INT64: u8 = 105u8;
pub const DCGM_FT_STRING: u8 = 115u8;
pub const DCGM_FT_TIMESTAMP: u8 = 116u8;
pub const DCGM_FS_GLOBAL: u32 = 0;
pub const DCGM_FS_ENTITY: u32 = 1;
pub const DCGM_FS_DEVICE: u32 = 1;
pub const DCGM_CLOCKS_EVENT_REASON_GPU_IDLE: u32 = 1;
pub const DCGM_CLOCKS_EVENT_REASON_CLOCKS_SETTING: u32 = 2;
pub const DCGM_CLOCKS_EVENT_REASON_SW_POWER_CAP: u32 = 4;
pub const DCGM_CLOCKS_EVENT_REASON_HW_SLOWDOWN: u32 = 8;
pub const DCGM_CLOCKS_EVENT_REASON_SYNC_BOOST: u32 = 15;
pub const DCGM_CLOCKS_EVENT_REASON_SW_THERMAL: u32 = 32;
pub const DCGM_CLOCKS_EVENT_REASON_HW_THERMAL: u32 = 64;
pub const DCGM_CLOCKS_EVENT_REASON_HW_POWER_BRAKE: u32 = 128;
pub const DCGM_CLOCKS_EVENT_REASON_DISPLAY_CLOCKS: u32 = 256;
pub const DCGM_CLOCKS_THROTTLE_REASON_GPU_IDLE: u32 = 1;
pub const DCGM_CLOCKS_THROTTLE_REASON_CLOCKS_SETTING: u32 = 2;
pub const DCGM_CLOCKS_THROTTLE_REASON_SW_POWER_CAP: u32 = 4;
pub const DCGM_CLOCKS_THROTTLE_REASON_HW_SLOWDOWN: u32 = 8;
pub const DCGM_CLOCKS_THROTTLE_REASON_SYNC_BOOST: u32 = 15;
pub const DCGM_CLOCKS_THROTTLE_REASON_SW_THERMAL: u32 = 32;
pub const DCGM_CLOCKS_THROTTLE_REASON_HW_THERMAL: u32 = 64;
pub const DCGM_CLOCKS_THROTTLE_REASON_HW_POWER_BRAKE: u32 = 128;
pub const DCGM_CLOCKS_THROTTLE_REASON_DISPLAY_CLOCKS: u32 = 256;
pub const DCGM_FI_UNKNOWN: u32 = 0;
pub const DCGM_FI_DRIVER_VERSION: u32 = 1;
pub const DCGM_FI_NVML_VERSION: u32 = 2;
pub const DCGM_FI_PROCESS_NAME: u32 = 3;
pub const DCGM_FI_DEV_COUNT: u32 = 4;
pub const DCGM_FI_CUDA_DRIVER_VERSION: u32 = 5;
pub const DCGM_FI_DEV_NAME: u32 = 50;
pub const DCGM_FI_DEV_BRAND: u32 = 51;
pub const DCGM_FI_DEV_NVML_INDEX: u32 = 52;
pub const DCGM_FI_DEV_SERIAL: u32 = 53;
pub const DCGM_FI_DEV_UUID: u32 = 54;
pub const DCGM_FI_DEV_MINOR_NUMBER: u32 = 55;
pub const DCGM_FI_DEV_OEM_INFOROM_VER: u32 = 56;
pub const DCGM_FI_DEV_PCI_BUSID: u32 = 57;
pub const DCGM_FI_DEV_PCI_COMBINED_ID: u32 = 58;
pub const DCGM_FI_DEV_PCI_SUBSYS_ID: u32 = 59;
pub const DCGM_FI_GPU_TOPOLOGY_PCI: u32 = 60;
pub const DCGM_FI_GPU_TOPOLOGY_NVLINK: u32 = 61;
pub const DCGM_FI_GPU_TOPOLOGY_AFFINITY: u32 = 62;
pub const DCGM_FI_DEV_CUDA_COMPUTE_CAPABILITY: u32 = 63;
pub const DCGM_FI_DEV_COMPUTE_MODE: u32 = 65;
pub const DCGM_FI_DEV_PERSISTENCE_MODE: u32 = 66;
pub const DCGM_FI_DEV_MIG_MODE: u32 = 67;
pub const DCGM_FI_DEV_CUDA_VISIBLE_DEVICES_STR: u32 = 68;
pub const DCGM_FI_DEV_MIG_MAX_SLICES: u32 = 69;
pub const DCGM_FI_DEV_CPU_AFFINITY_0: u32 = 70;
pub const DCGM_FI_DEV_CPU_AFFINITY_1: u32 = 71;
pub const DCGM_FI_DEV_CPU_AFFINITY_2: u32 = 72;
pub const DCGM_FI_DEV_CPU_AFFINITY_3: u32 = 73;
pub const DCGM_FI_DEV_CC_MODE: u32 = 74;
pub const DCGM_FI_DEV_MIG_ATTRIBUTES: u32 = 75;
pub const DCGM_FI_DEV_MIG_GI_INFO: u32 = 76;
pub const DCGM_FI_DEV_MIG_CI_INFO: u32 = 77;
pub const DCGM_FI_DEV_ECC_INFOROM_VER: u32 = 80;
pub const DCGM_FI_DEV_POWER_INFOROM_VER: u32 = 81;
pub const DCGM_FI_DEV_INFOROM_IMAGE_VER: u32 = 82;
pub const DCGM_FI_DEV_INFOROM_CONFIG_CHECK: u32 = 83;
pub const DCGM_FI_DEV_INFOROM_CONFIG_VALID: u32 = 84;
pub const DCGM_FI_DEV_VBIOS_VERSION: u32 = 85;
pub const DCGM_FI_DEV_MEM_AFFINITY_0: u32 = 86;
pub const DCGM_FI_DEV_MEM_AFFINITY_1: u32 = 87;
pub const DCGM_FI_DEV_MEM_AFFINITY_2: u32 = 88;
pub const DCGM_FI_DEV_MEM_AFFINITY_3: u32 = 89;
pub const DCGM_FI_DEV_BAR1_TOTAL: u32 = 90;
pub const DCGM_FI_SYNC_BOOST: u32 = 91;
pub const DCGM_FI_DEV_BAR1_USED: u32 = 92;
pub const DCGM_FI_DEV_BAR1_FREE: u32 = 93;
pub const DCGM_FI_DEV_GPM_SUPPORT: u32 = 94;
pub const DCGM_FI_DEV_SM_CLOCK: u32 = 100;
pub const DCGM_FI_DEV_MEM_CLOCK: u32 = 101;
pub const DCGM_FI_DEV_VIDEO_CLOCK: u32 = 102;
pub const DCGM_FI_DEV_APP_SM_CLOCK: u32 = 110;
pub const DCGM_FI_DEV_APP_MEM_CLOCK: u32 = 111;
pub const DCGM_FI_DEV_CLOCKS_EVENT_REASONS: u32 = 112;
pub const DCGM_FI_DEV_CLOCK_THROTTLE_REASONS: u32 = 112;
pub const DCGM_FI_DEV_MAX_SM_CLOCK: u32 = 113;
pub const DCGM_FI_DEV_MAX_MEM_CLOCK: u32 = 114;
pub const DCGM_FI_DEV_MAX_VIDEO_CLOCK: u32 = 115;
pub const DCGM_FI_DEV_AUTOBOOST: u32 = 120;
pub const DCGM_FI_DEV_SUPPORTED_CLOCKS: u32 = 130;
pub const DCGM_FI_DEV_MEMORY_TEMP: u32 = 140;
pub const DCGM_FI_DEV_GPU_TEMP: u32 = 150;
pub const DCGM_FI_DEV_MEM_MAX_OP_TEMP: u32 = 151;
pub const DCGM_FI_DEV_GPU_MAX_OP_TEMP: u32 = 152;
pub const DCGM_FI_DEV_GPU_TEMP_LIMIT: u32 = 153;
pub const DCGM_FI_DEV_POWER_USAGE: u32 = 155;
pub const DCGM_FI_DEV_TOTAL_ENERGY_CONSUMPTION: u32 = 156;
pub const DCGM_FI_DEV_POWER_USAGE_INSTANT: u32 = 157;
pub const DCGM_FI_DEV_SLOWDOWN_TEMP: u32 = 158;
pub const DCGM_FI_DEV_SHUTDOWN_TEMP: u32 = 159;
pub const DCGM_FI_DEV_POWER_MGMT_LIMIT: u32 = 160;
pub const DCGM_FI_DEV_POWER_MGMT_LIMIT_MIN: u32 = 161;
pub const DCGM_FI_DEV_POWER_MGMT_LIMIT_MAX: u32 = 162;
pub const DCGM_FI_DEV_POWER_MGMT_LIMIT_DEF: u32 = 163;
pub const DCGM_FI_DEV_ENFORCED_POWER_LIMIT: u32 = 164;
pub const DCGM_FI_DEV_REQUESTED_POWER_PROFILE_MASK: u32 = 165;
pub const DCGM_FI_DEV_ENFORCED_POWER_PROFILE_MASK: u32 = 166;
pub const DCGM_FI_DEV_VALID_POWER_PROFILE_MASK: u32 = 167;
pub const DCGM_FI_DEV_FABRIC_MANAGER_STATUS: u32 = 170;
pub const DCGM_FI_DEV_FABRIC_MANAGER_ERROR_CODE: u32 = 171;
pub const DCGM_FI_DEV_FABRIC_CLUSTER_UUID: u32 = 172;
pub const DCGM_FI_DEV_FABRIC_CLIQUE_ID: u32 = 173;
pub const DCGM_FI_DEV_PSTATE: u32 = 190;
pub const DCGM_FI_DEV_FAN_SPEED: u32 = 191;
pub const DCGM_FI_DEV_PCIE_TX_THROUGHPUT: u32 = 200;
pub const DCGM_FI_DEV_PCIE_RX_THROUGHPUT: u32 = 201;
pub const DCGM_FI_DEV_PCIE_REPLAY_COUNTER: u32 = 202;
pub const DCGM_FI_DEV_GPU_UTIL: u32 = 203;
pub const DCGM_FI_DEV_MEM_COPY_UTIL: u32 = 204;
pub const DCGM_FI_DEV_ACCOUNTING_DATA: u32 = 205;
pub const DCGM_FI_DEV_ENC_UTIL: u32 = 206;
pub const DCGM_FI_DEV_DEC_UTIL: u32 = 207;
pub const DCGM_FI_DEV_XID_ERRORS: u32 = 230;
pub const DCGM_FI_DEV_PCIE_MAX_LINK_GEN: u32 = 235;
pub const DCGM_FI_DEV_PCIE_MAX_LINK_WIDTH: u32 = 236;
pub const DCGM_FI_DEV_PCIE_LINK_GEN: u32 = 237;
pub const DCGM_FI_DEV_PCIE_LINK_WIDTH: u32 = 238;
pub const DCGM_FI_DEV_POWER_VIOLATION: u32 = 240;
pub const DCGM_FI_DEV_THERMAL_VIOLATION: u32 = 241;
pub const DCGM_FI_DEV_SYNC_BOOST_VIOLATION: u32 = 242;
pub const DCGM_FI_DEV_BOARD_LIMIT_VIOLATION: u32 = 243;
pub const DCGM_FI_DEV_LOW_UTIL_VIOLATION: u32 = 244;
pub const DCGM_FI_DEV_RELIABILITY_VIOLATION: u32 = 245;
pub const DCGM_FI_DEV_TOTAL_APP_CLOCKS_VIOLATION: u32 = 246;
pub const DCGM_FI_DEV_TOTAL_BASE_CLOCKS_VIOLATION: u32 = 247;
pub const DCGM_FI_DEV_FB_TOTAL: u32 = 250;
pub const DCGM_FI_DEV_FB_FREE: u32 = 251;
pub const DCGM_FI_DEV_FB_USED: u32 = 252;
pub const DCGM_FI_DEV_FB_RESERVED: u32 = 253;
pub const DCGM_FI_DEV_FB_USED_PERCENT: u32 = 254;
pub const DCGM_FI_DEV_C2C_LINK_COUNT: u32 = 285;
pub const DCGM_FI_DEV_C2C_LINK_STATUS: u32 = 286;
pub const DCGM_FI_DEV_C2C_MAX_BANDWIDTH: u32 = 287;
pub const DCGM_FI_DEV_ECC_CURRENT: u32 = 300;
pub const DCGM_FI_DEV_ECC_PENDING: u32 = 301;
pub const DCGM_FI_DEV_ECC_SBE_VOL_TOTAL: u32 = 310;
pub const DCGM_FI_DEV_ECC_DBE_VOL_TOTAL: u32 = 311;
pub const DCGM_FI_DEV_ECC_SBE_AGG_TOTAL: u32 = 312;
pub const DCGM_FI_DEV_ECC_DBE_AGG_TOTAL: u32 = 313;
pub const DCGM_FI_DEV_ECC_SBE_VOL_L1: u32 = 314;
pub const DCGM_FI_DEV_ECC_DBE_VOL_L1: u32 = 315;
pub const DCGM_FI_DEV_ECC_SBE_VOL_L2: u32 = 316;
pub const DCGM_FI_DEV_ECC_DBE_VOL_L2: u32 = 317;
pub const DCGM_FI_DEV_ECC_SBE_VOL_DEV: u32 = 318;
pub const DCGM_FI_DEV_ECC_DBE_VOL_DEV: u32 = 319;
pub const DCGM_FI_DEV_ECC_SBE_VOL_REG: u32 = 320;
pub const DCGM_FI_DEV_ECC_DBE_VOL_REG: u32 = 321;
pub const DCGM_FI_DEV_ECC_SBE_VOL_TEX: u32 = 322;
pub const DCGM_FI_DEV_ECC_DBE_VOL_TEX: u32 = 323;
pub const DCGM_FI_DEV_ECC_SBE_AGG_L1: u32 = 324;
pub const DCGM_FI_DEV_ECC_DBE_AGG_L1: u32 = 325;
pub const DCGM_FI_DEV_ECC_SBE_AGG_L2: u32 = 326;
pub const DCGM_FI_DEV_ECC_DBE_AGG_L2: u32 = 327;
pub const DCGM_FI_DEV_ECC_SBE_AGG_DEV: u32 = 328;
pub const DCGM_FI_DEV_ECC_DBE_AGG_DEV: u32 = 329;
pub const DCGM_FI_DEV_ECC_SBE_AGG_REG: u32 = 330;
pub const DCGM_FI_DEV_ECC_DBE_AGG_REG: u32 = 331;
pub const DCGM_FI_DEV_ECC_SBE_AGG_TEX: u32 = 332;
pub const DCGM_FI_DEV_ECC_DBE_AGG_TEX: u32 = 333;
pub const DCGM_FI_DEV_ECC_SBE_VOL_SHM: u32 = 334;
pub const DCGM_FI_DEV_ECC_DBE_VOL_SHM: u32 = 335;
pub const DCGM_FI_DEV_ECC_SBE_VOL_CBU: u32 = 336;
pub const DCGM_FI_DEV_ECC_DBE_VOL_CBU: u32 = 337;
pub const DCGM_FI_DEV_ECC_SBE_AGG_SHM: u32 = 338;
pub const DCGM_FI_DEV_ECC_DBE_AGG_SHM: u32 = 339;
pub const DCGM_FI_DEV_ECC_SBE_AGG_CBU: u32 = 340;
pub const DCGM_FI_DEV_ECC_DBE_AGG_CBU: u32 = 341;
pub const DCGM_FI_DEV_ECC_SBE_VOL_SRM: u32 = 342;
pub const DCGM_FI_DEV_ECC_DBE_VOL_SRM: u32 = 343;
pub const DCGM_FI_DEV_ECC_SBE_AGG_SRM: u32 = 344;
pub const DCGM_FI_DEV_ECC_DBE_AGG_SRM: u32 = 345;
pub const DCGM_FI_DEV_DIAG_MEMORY_RESULT: u32 = 350;
pub const DCGM_FI_DEV_DIAG_DIAGNOSTIC_RESULT: u32 = 351;
pub const DCGM_FI_DEV_DIAG_PCIE_RESULT: u32 = 352;
pub const DCGM_FI_DEV_DIAG_TARGETED_STRESS_RESULT: u32 = 353;
pub const DCGM_FI_DEV_DIAG_TARGETED_POWER_RESULT: u32 = 354;
pub const DCGM_FI_DEV_DIAG_MEMORY_BANDWIDTH_RESULT: u32 = 355;
pub const DCGM_FI_DEV_DIAG_MEMTEST_RESULT: u32 = 356;
pub const DCGM_FI_DEV_DIAG_PULSE_TEST_RESULT: u32 = 357;
pub const DCGM_FI_DEV_DIAG_EUD_RESULT: u32 = 358;
pub const DCGM_FI_DEV_DIAG_CPU_EUD_RESULT: u32 = 359;
pub const DCGM_FI_DEV_DIAG_SOFTWARE_RESULT: u32 = 360;
pub const DCGM_FI_DEV_DIAG_NVBANDWIDTH_RESULT: u32 = 361;
pub const DCGM_FI_DEV_DIAG_STATUS: u32 = 362;
pub const DCGM_FI_DEV_BANKS_REMAP_ROWS_AVAIL_MAX: u32 = 385;
pub const DCGM_FI_DEV_BANKS_REMAP_ROWS_AVAIL_HIGH: u32 = 386;
pub const DCGM_FI_DEV_BANKS_REMAP_ROWS_AVAIL_PARTIAL: u32 = 387;
pub const DCGM_FI_DEV_BANKS_REMAP_ROWS_AVAIL_LOW: u32 = 388;
pub const DCGM_FI_DEV_BANKS_REMAP_ROWS_AVAIL_NONE: u32 = 389;
pub const DCGM_FI_DEV_RETIRED_SBE: u32 = 390;
pub const DCGM_FI_DEV_RETIRED_DBE: u32 = 391;
pub const DCGM_FI_DEV_RETIRED_PENDING: u32 = 392;
pub const DCGM_FI_DEV_UNCORRECTABLE_REMAPPED_ROWS: u32 = 393;
pub const DCGM_FI_DEV_CORRECTABLE_REMAPPED_ROWS: u32 = 394;
pub const DCGM_FI_DEV_ROW_REMAP_FAILURE: u32 = 395;
pub const DCGM_FI_DEV_ROW_REMAP_PENDING: u32 = 396;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L0: u32 = 400;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L1: u32 = 401;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L2: u32 = 402;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L3: u32 = 403;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L4: u32 = 404;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L5: u32 = 405;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_TOTAL: u32 = 409;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L0: u32 = 410;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L1: u32 = 411;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L2: u32 = 412;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L3: u32 = 413;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L4: u32 = 414;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L5: u32 = 415;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_TOTAL: u32 = 419;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L0: u32 = 420;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L1: u32 = 421;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L2: u32 = 422;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L3: u32 = 423;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L4: u32 = 424;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L5: u32 = 425;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_TOTAL: u32 = 429;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L0: u32 = 430;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L1: u32 = 431;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L2: u32 = 432;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L3: u32 = 433;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L4: u32 = 434;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L5: u32 = 435;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_TOTAL: u32 = 439;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L0: u32 = 440;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L1: u32 = 441;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L2: u32 = 442;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L3: u32 = 443;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L4: u32 = 444;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L5: u32 = 445;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_TOTAL: u32 = 449;
pub const DCGM_FI_DEV_GPU_NVLINK_ERRORS: u32 = 450;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L6: u32 = 451;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L7: u32 = 452;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L8: u32 = 453;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L9: u32 = 454;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L10: u32 = 455;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L11: u32 = 456;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L6: u32 = 457;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L7: u32 = 458;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L8: u32 = 459;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L9: u32 = 460;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L10: u32 = 461;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L11: u32 = 462;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L6: u32 = 463;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L7: u32 = 464;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L8: u32 = 465;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L9: u32 = 466;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L10: u32 = 467;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L11: u32 = 468;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L6: u32 = 469;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L7: u32 = 470;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L8: u32 = 471;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L9: u32 = 472;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L10: u32 = 473;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L11: u32 = 474;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L6: u32 = 475;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L7: u32 = 476;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L8: u32 = 477;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L9: u32 = 478;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L10: u32 = 479;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L11: u32 = 480;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L12: u32 = 406;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L13: u32 = 407;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L14: u32 = 408;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L15: u32 = 481;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L16: u32 = 482;
pub const DCGM_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L17: u32 = 483;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L12: u32 = 416;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L13: u32 = 417;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L14: u32 = 418;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L15: u32 = 484;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L16: u32 = 485;
pub const DCGM_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L17: u32 = 486;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L12: u32 = 426;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L13: u32 = 427;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L14: u32 = 428;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L15: u32 = 487;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L16: u32 = 488;
pub const DCGM_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L17: u32 = 489;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L12: u32 = 436;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L13: u32 = 437;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L14: u32 = 438;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L15: u32 = 491;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L16: u32 = 492;
pub const DCGM_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L17: u32 = 493;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L12: u32 = 446;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L13: u32 = 447;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L14: u32 = 448;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L15: u32 = 494;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L16: u32 = 495;
pub const DCGM_FI_DEV_NVLINK_BANDWIDTH_L17: u32 = 496;
pub const DCGM_FI_DEV_NVLINK_ERROR_DL_CRC: u32 = 497;
pub const DCGM_FI_DEV_NVLINK_ERROR_DL_RECOVERY: u32 = 498;
pub const DCGM_FI_DEV_NVLINK_ERROR_DL_REPLAY: u32 = 499;
pub const DCGM_FI_DEV_VIRTUAL_MODE: u32 = 500;
pub const DCGM_FI_DEV_SUPPORTED_TYPE_INFO: u32 = 501;
pub const DCGM_FI_DEV_CREATABLE_VGPU_TYPE_IDS: u32 = 502;
pub const DCGM_FI_DEV_VGPU_INSTANCE_IDS: u32 = 503;
pub const DCGM_FI_DEV_VGPU_UTILIZATIONS: u32 = 504;
pub const DCGM_FI_DEV_VGPU_PER_PROCESS_UTILIZATION: u32 = 505;
pub const DCGM_FI_DEV_ENC_STATS: u32 = 506;
pub const DCGM_FI_DEV_FBC_STATS: u32 = 507;
pub const DCGM_FI_DEV_FBC_SESSIONS_INFO: u32 = 508;
pub const DCGM_FI_DEV_SUPPORTED_VGPU_TYPE_IDS: u32 = 509;
pub const DCGM_FI_DEV_VGPU_TYPE_INFO: u32 = 510;
pub const DCGM_FI_DEV_VGPU_TYPE_NAME: u32 = 511;
pub const DCGM_FI_DEV_VGPU_TYPE_CLASS: u32 = 512;
pub const DCGM_FI_DEV_VGPU_TYPE_LICENSE: u32 = 513;
pub const DCGM_FI_DEV_VGPU_VM_ID: u32 = 520;
pub const DCGM_FI_DEV_VGPU_VM_NAME: u32 = 521;
pub const DCGM_FI_DEV_VGPU_TYPE: u32 = 522;
pub const DCGM_FI_DEV_VGPU_UUID: u32 = 523;
pub const DCGM_FI_DEV_VGPU_DRIVER_VERSION: u32 = 524;
pub const DCGM_FI_DEV_VGPU_MEMORY_USAGE: u32 = 525;
pub const DCGM_FI_DEV_VGPU_LICENSE_STATUS: u32 = 526;
pub const DCGM_FI_DEV_VGPU_FRAME_RATE_LIMIT: u32 = 527;
pub const DCGM_FI_DEV_VGPU_ENC_STATS: u32 = 528;
pub const DCGM_FI_DEV_VGPU_ENC_SESSIONS_INFO: u32 = 529;
pub const DCGM_FI_DEV_VGPU_FBC_STATS: u32 = 530;
pub const DCGM_FI_DEV_VGPU_FBC_SESSIONS_INFO: u32 = 531;
pub const DCGM_FI_DEV_VGPU_INSTANCE_LICENSE_STATE: u32 = 532;
pub const DCGM_FI_DEV_VGPU_PCI_ID: u32 = 533;
pub const DCGM_FI_DEV_VGPU_VM_GPU_INSTANCE_ID: u32 = 534;
pub const DCGM_FI_FIRST_VGPU_FIELD_ID: u32 = 520;
pub const DCGM_FI_LAST_VGPU_FIELD_ID: u32 = 570;
pub const DCGM_FI_MAX_VGPU_FIELDS: u32 = 50;
pub const DCGM_FI_DEV_PLATFORM_INFINIBAND_GUID: u32 = 571;
pub const DCGM_FI_DEV_PLATFORM_CHASSIS_SERIAL_NUMBER: u32 = 572;
pub const DCGM_FI_DEV_PLATFORM_CHASSIS_SLOT_NUMBER: u32 = 573;
pub const DCGM_FI_DEV_PLATFORM_TRAY_INDEX: u32 = 574;
pub const DCGM_FI_DEV_PLATFORM_HOST_ID: u32 = 575;
pub const DCGM_FI_DEV_PLATFORM_PEER_TYPE: u32 = 576;
pub const DCGM_FI_DEV_PLATFORM_MODULE_ID: u32 = 577;
pub const DCGM_FI_INTERNAL_FIELDS_0_START: u32 = 600;
pub const DCGM_FI_INTERNAL_FIELDS_0_END: u32 = 699;
pub const DCGM_FI_FIRST_NVSWITCH_FIELD_ID: u32 = 700;
pub const DCGM_FI_DEV_NVSWITCH_VOLTAGE_MVOLT: u32 = 701;
pub const DCGM_FI_DEV_NVSWITCH_CURRENT_IDDQ: u32 = 702;
pub const DCGM_FI_DEV_NVSWITCH_CURRENT_IDDQ_REV: u32 = 703;
pub const DCGM_FI_DEV_NVSWITCH_CURRENT_IDDQ_DVDD: u32 = 704;
pub const DCGM_FI_DEV_NVSWITCH_POWER_VDD: u32 = 705;
pub const DCGM_FI_DEV_NVSWITCH_POWER_DVDD: u32 = 706;
pub const DCGM_FI_DEV_NVSWITCH_POWER_HVDD: u32 = 707;
pub const DCGM_FI_DEV_NVSWITCH_LINK_THROUGHPUT_TX: u32 = 780;
pub const DCGM_FI_DEV_NVSWITCH_LINK_THROUGHPUT_RX: u32 = 781;
pub const DCGM_FI_DEV_NVSWITCH_LINK_FATAL_ERRORS: u32 = 782;
pub const DCGM_FI_DEV_NVSWITCH_LINK_NON_FATAL_ERRORS: u32 = 783;
pub const DCGM_FI_DEV_NVSWITCH_LINK_REPLAY_ERRORS: u32 = 784;
pub const DCGM_FI_DEV_NVSWITCH_LINK_RECOVERY_ERRORS: u32 = 785;
pub const DCGM_FI_DEV_NVSWITCH_LINK_FLIT_ERRORS: u32 = 786;
pub const DCGM_FI_DEV_NVSWITCH_LINK_CRC_ERRORS: u32 = 787;
pub const DCGM_FI_DEV_NVSWITCH_LINK_ECC_ERRORS: u32 = 788;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_LOW_VC0: u32 = 789;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_LOW_VC1: u32 = 790;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_LOW_VC2: u32 = 791;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_LOW_VC3: u32 = 792;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_MEDIUM_VC0: u32 = 793;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_MEDIUM_VC1: u32 = 794;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_MEDIUM_VC2: u32 = 795;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_MEDIUM_VC3: u32 = 796;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_HIGH_VC0: u32 = 797;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_HIGH_VC1: u32 = 798;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_HIGH_VC2: u32 = 799;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_HIGH_VC3: u32 = 800;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_PANIC_VC0: u32 = 801;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_PANIC_VC1: u32 = 802;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_PANIC_VC2: u32 = 803;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_PANIC_VC3: u32 = 804;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_COUNT_VC0: u32 = 805;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_COUNT_VC1: u32 = 806;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_COUNT_VC2: u32 = 807;
pub const DCGM_FI_DEV_NVSWITCH_LINK_LATENCY_COUNT_VC3: u32 = 808;
pub const DCGM_FI_DEV_NVSWITCH_LINK_CRC_ERRORS_LANE0: u32 = 809;
pub const DCGM_FI_DEV_NVSWITCH_LINK_CRC_ERRORS_LANE1: u32 = 810;
pub const DCGM_FI_DEV_NVSWITCH_LINK_CRC_ERRORS_LANE2: u32 = 811;
pub const DCGM_FI_DEV_NVSWITCH_LINK_CRC_ERRORS_LANE3: u32 = 812;
pub const DCGM_FI_DEV_NVSWITCH_LINK_ECC_ERRORS_LANE0: u32 = 813;
pub const DCGM_FI_DEV_NVSWITCH_LINK_ECC_ERRORS_LANE1: u32 = 814;
pub const DCGM_FI_DEV_NVSWITCH_LINK_ECC_ERRORS_LANE2: u32 = 815;
pub const DCGM_FI_DEV_NVSWITCH_LINK_ECC_ERRORS_LANE3: u32 = 816;
pub const DCGM_FI_DEV_NVSWITCH_LINK_CRC_ERRORS_LANE4: u32 = 817;
pub const DCGM_FI_DEV_NVSWITCH_LINK_CRC_ERRORS_LANE5: u32 = 818;
pub const DCGM_FI_DEV_NVSWITCH_LINK_CRC_ERRORS_LANE6: u32 = 819;
pub const DCGM_FI_DEV_NVSWITCH_LINK_CRC_ERRORS_LANE7: u32 = 820;
pub const DCGM_FI_DEV_NVSWITCH_LINK_ECC_ERRORS_LANE4: u32 = 821;
pub const DCGM_FI_DEV_NVSWITCH_LINK_ECC_ERRORS_LANE5: u32 = 822;
pub const DCGM_FI_DEV_NVSWITCH_LINK_ECC_ERRORS_LANE6: u32 = 823;
pub const DCGM_FI_DEV_NVSWITCH_LINK_ECC_ERRORS_LANE7: u32 = 824;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L0: u32 = 825;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L1: u32 = 826;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L2: u32 = 827;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L3: u32 = 828;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L4: u32 = 829;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L5: u32 = 830;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L6: u32 = 831;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L7: u32 = 832;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L8: u32 = 833;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L9: u32 = 834;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L10: u32 = 835;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L11: u32 = 836;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L12: u32 = 837;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L13: u32 = 838;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L14: u32 = 839;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L15: u32 = 840;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L16: u32 = 841;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_L17: u32 = 842;
pub const DCGM_FI_DEV_NVLINK_TX_BANDWIDTH_TOTAL: u32 = 843;
pub const DCGM_FI_DEV_NVSWITCH_FATAL_ERRORS: u32 = 856;
pub const DCGM_FI_DEV_NVSWITCH_NON_FATAL_ERRORS: u32 = 857;
pub const DCGM_FI_DEV_NVSWITCH_TEMPERATURE_CURRENT: u32 = 858;
pub const DCGM_FI_DEV_NVSWITCH_TEMPERATURE_LIMIT_SLOWDOWN: u32 = 859;
pub const DCGM_FI_DEV_NVSWITCH_TEMPERATURE_LIMIT_SHUTDOWN: u32 = 860;
pub const DCGM_FI_DEV_NVSWITCH_THROUGHPUT_TX: u32 = 861;
pub const DCGM_FI_DEV_NVSWITCH_THROUGHPUT_RX: u32 = 862;
pub const DCGM_FI_DEV_NVSWITCH_PHYS_ID: u32 = 863;
pub const DCGM_FI_DEV_NVSWITCH_RESET_REQUIRED: u32 = 864;
pub const DCGM_FI_DEV_NVSWITCH_LINK_ID: u32 = 865;
pub const DCGM_FI_DEV_NVSWITCH_PCIE_DOMAIN: u32 = 866;
pub const DCGM_FI_DEV_NVSWITCH_PCIE_BUS: u32 = 867;
pub const DCGM_FI_DEV_NVSWITCH_PCIE_DEVICE: u32 = 868;
pub const DCGM_FI_DEV_NVSWITCH_PCIE_FUNCTION: u32 = 869;
pub const DCGM_FI_DEV_NVSWITCH_LINK_STATUS: u32 = 870;
pub const DCGM_FI_DEV_NVSWITCH_LINK_TYPE: u32 = 871;
pub const DCGM_FI_DEV_NVSWITCH_LINK_REMOTE_PCIE_DOMAIN: u32 = 872;
pub const DCGM_FI_DEV_NVSWITCH_LINK_REMOTE_PCIE_BUS: u32 = 873;
pub const DCGM_FI_DEV_NVSWITCH_LINK_REMOTE_PCIE_DEVICE: u32 = 874;
pub const DCGM_FI_DEV_NVSWITCH_LINK_REMOTE_PCIE_FUNCTION: u32 = 875;
pub const DCGM_FI_DEV_NVSWITCH_LINK_DEVICE_LINK_ID: u32 = 876;
pub const DCGM_FI_DEV_NVSWITCH_LINK_DEVICE_LINK_SID: u32 = 877;
pub const DCGM_FI_DEV_NVSWITCH_DEVICE_UUID: u32 = 878;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L0: u32 = 879;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L1: u32 = 880;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L2: u32 = 881;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L3: u32 = 882;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L4: u32 = 883;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L5: u32 = 884;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L6: u32 = 885;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L7: u32 = 886;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L8: u32 = 887;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L9: u32 = 888;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L10: u32 = 889;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L11: u32 = 890;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L12: u32 = 891;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L13: u32 = 892;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L14: u32 = 893;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L15: u32 = 894;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L16: u32 = 895;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_L17: u32 = 896;
pub const DCGM_FI_DEV_NVLINK_RX_BANDWIDTH_TOTAL: u32 = 897;
pub const DCGM_FI_LAST_NVSWITCH_FIELD_ID: u32 = 899;
pub const DCGM_FI_MAX_NVSWITCH_FIELDS: u32 = 200;
pub const DCGM_FI_PROF_GR_ENGINE_ACTIVE: u32 = 1001;
pub const DCGM_FI_PROF_SM_ACTIVE: u32 = 1002;
pub const DCGM_FI_PROF_SM_OCCUPANCY: u32 = 1003;
pub const DCGM_FI_PROF_PIPE_TENSOR_ACTIVE: u32 = 1004;
pub const DCGM_FI_PROF_DRAM_ACTIVE: u32 = 1005;
pub const DCGM_FI_PROF_PIPE_FP64_ACTIVE: u32 = 1006;
pub const DCGM_FI_PROF_PIPE_FP32_ACTIVE: u32 = 1007;
pub const DCGM_FI_PROF_PIPE_FP16_ACTIVE: u32 = 1008;
pub const DCGM_FI_PROF_PCIE_TX_BYTES: u32 = 1009;
pub const DCGM_FI_PROF_PCIE_RX_BYTES: u32 = 1010;
pub const DCGM_FI_PROF_NVLINK_TX_BYTES: u32 = 1011;
pub const DCGM_FI_PROF_NVLINK_RX_BYTES: u32 = 1012;
pub const DCGM_FI_PROF_PIPE_TENSOR_IMMA_ACTIVE: u32 = 1013;
pub const DCGM_FI_PROF_PIPE_TENSOR_HMMA_ACTIVE: u32 = 1014;
pub const DCGM_FI_PROF_PIPE_TENSOR_DFMA_ACTIVE: u32 = 1015;
pub const DCGM_FI_PROF_PIPE_INT_ACTIVE: u32 = 1016;
pub const DCGM_FI_PROF_NVDEC0_ACTIVE: u32 = 1017;
pub const DCGM_FI_PROF_NVDEC1_ACTIVE: u32 = 1018;
pub const DCGM_FI_PROF_NVDEC2_ACTIVE: u32 = 1019;
pub const DCGM_FI_PROF_NVDEC3_ACTIVE: u32 = 1020;
pub const DCGM_FI_PROF_NVDEC4_ACTIVE: u32 = 1021;
pub const DCGM_FI_PROF_NVDEC5_ACTIVE: u32 = 1022;
pub const DCGM_FI_PROF_NVDEC6_ACTIVE: u32 = 1023;
pub const DCGM_FI_PROF_NVDEC7_ACTIVE: u32 = 1024;
pub const DCGM_FI_PROF_NVJPG0_ACTIVE: u32 = 1025;
pub const DCGM_FI_PROF_NVJPG1_ACTIVE: u32 = 1026;
pub const DCGM_FI_PROF_NVJPG2_ACTIVE: u32 = 1027;
pub const DCGM_FI_PROF_NVJPG3_ACTIVE: u32 = 1028;
pub const DCGM_FI_PROF_NVJPG4_ACTIVE: u32 = 1029;
pub const DCGM_FI_PROF_NVJPG5_ACTIVE: u32 = 1030;
pub const DCGM_FI_PROF_NVJPG6_ACTIVE: u32 = 1031;
pub const DCGM_FI_PROF_NVJPG7_ACTIVE: u32 = 1032;
pub const DCGM_FI_PROF_NVOFA0_ACTIVE: u32 = 1033;
pub const DCGM_FI_PROF_NVOFA1_ACTIVE: u32 = 1034;
pub const DCGM_FI_PROF_NVLINK_L0_TX_BYTES: u32 = 1040;
pub const DCGM_FI_PROF_NVLINK_L0_RX_BYTES: u32 = 1041;
pub const DCGM_FI_PROF_NVLINK_L1_TX_BYTES: u32 = 1042;
pub const DCGM_FI_PROF_NVLINK_L1_RX_BYTES: u32 = 1043;
pub const DCGM_FI_PROF_NVLINK_L2_TX_BYTES: u32 = 1044;
pub const DCGM_FI_PROF_NVLINK_L2_RX_BYTES: u32 = 1045;
pub const DCGM_FI_PROF_NVLINK_L3_TX_BYTES: u32 = 1046;
pub const DCGM_FI_PROF_NVLINK_L3_RX_BYTES: u32 = 1047;
pub const DCGM_FI_PROF_NVLINK_L4_TX_BYTES: u32 = 1048;
pub const DCGM_FI_PROF_NVLINK_L4_RX_BYTES: u32 = 1049;
pub const DCGM_FI_PROF_NVLINK_L5_TX_BYTES: u32 = 1050;
pub const DCGM_FI_PROF_NVLINK_L5_RX_BYTES: u32 = 1051;
pub const DCGM_FI_PROF_NVLINK_L6_TX_BYTES: u32 = 1052;
pub const DCGM_FI_PROF_NVLINK_L6_RX_BYTES: u32 = 1053;
pub const DCGM_FI_PROF_NVLINK_L7_TX_BYTES: u32 = 1054;
pub const DCGM_FI_PROF_NVLINK_L7_RX_BYTES: u32 = 1055;
pub const DCGM_FI_PROF_NVLINK_L8_TX_BYTES: u32 = 1056;
pub const DCGM_FI_PROF_NVLINK_L8_RX_BYTES: u32 = 1057;
pub const DCGM_FI_PROF_NVLINK_L9_TX_BYTES: u32 = 1058;
pub const DCGM_FI_PROF_NVLINK_L9_RX_BYTES: u32 = 1059;
pub const DCGM_FI_PROF_NVLINK_L10_TX_BYTES: u32 = 1060;
pub const DCGM_FI_PROF_NVLINK_L10_RX_BYTES: u32 = 1061;
pub const DCGM_FI_PROF_NVLINK_L11_TX_BYTES: u32 = 1062;
pub const DCGM_FI_PROF_NVLINK_L11_RX_BYTES: u32 = 1063;
pub const DCGM_FI_PROF_NVLINK_L12_TX_BYTES: u32 = 1064;
pub const DCGM_FI_PROF_NVLINK_L12_RX_BYTES: u32 = 1065;
pub const DCGM_FI_PROF_NVLINK_L13_TX_BYTES: u32 = 1066;
pub const DCGM_FI_PROF_NVLINK_L13_RX_BYTES: u32 = 1067;
pub const DCGM_FI_PROF_NVLINK_L14_TX_BYTES: u32 = 1068;
pub const DCGM_FI_PROF_NVLINK_L14_RX_BYTES: u32 = 1069;
pub const DCGM_FI_PROF_NVLINK_L15_TX_BYTES: u32 = 1070;
pub const DCGM_FI_PROF_NVLINK_L15_RX_BYTES: u32 = 1071;
pub const DCGM_FI_PROF_NVLINK_L16_TX_BYTES: u32 = 1072;
pub const DCGM_FI_PROF_NVLINK_L16_RX_BYTES: u32 = 1073;
pub const DCGM_FI_PROF_NVLINK_L17_TX_BYTES: u32 = 1074;
pub const DCGM_FI_PROF_NVLINK_L17_RX_BYTES: u32 = 1075;
pub const DCGM_FI_PROF_NVLINK_THROUGHPUT_FIRST: u32 = 1040;
pub const DCGM_FI_PROF_NVLINK_THROUGHPUT_LAST: u32 = 1075;
pub const DCGM_FI_PROF_C2C_TX_ALL_BYTES: u32 = 1076;
pub const DCGM_FI_PROF_C2C_TX_DATA_BYTES: u32 = 1077;
pub const DCGM_FI_PROF_C2C_RX_ALL_BYTES: u32 = 1078;
pub const DCGM_FI_PROF_C2C_RX_DATA_BYTES: u32 = 1079;
pub const DCGM_FI_DEV_CPU_UTIL_TOTAL: u32 = 1100;
pub const DCGM_FI_DEV_CPU_UTIL_USER: u32 = 1101;
pub const DCGM_FI_DEV_CPU_UTIL_NICE: u32 = 1102;
pub const DCGM_FI_DEV_CPU_UTIL_SYS: u32 = 1103;
pub const DCGM_FI_DEV_CPU_UTIL_IRQ: u32 = 1104;
pub const DCGM_FI_DEV_CPU_TEMP_CURRENT: u32 = 1110;
pub const DCGM_FI_DEV_CPU_TEMP_WARNING: u32 = 1111;
pub const DCGM_FI_DEV_CPU_TEMP_CRITICAL: u32 = 1112;
pub const DCGM_FI_DEV_CPU_CLOCK_CURRENT: u32 = 1120;
pub const DCGM_FI_DEV_CPU_POWER_UTIL_CURRENT: u32 = 1130;
pub const DCGM_FI_DEV_CPU_POWER_LIMIT: u32 = 1131;
pub const DCGM_FI_DEV_SYSIO_POWER_UTIL_CURRENT: u32 = 1132;
pub const DCGM_FI_DEV_MODULE_POWER_UTIL_CURRENT: u32 = 1133;
pub const DCGM_FI_DEV_CPU_VENDOR: u32 = 1140;
pub const DCGM_FI_DEV_CPU_MODEL: u32 = 1141;
pub const DCGM_FI_DEV_NVLINK_COUNT_TX_PACKETS: u32 = 1200;
pub const DCGM_FI_DEV_NVLINK_COUNT_TX_BYTES: u32 = 1201;
pub const DCGM_FI_DEV_NVLINK_COUNT_RX_PACKETS: u32 = 1202;
pub const DCGM_FI_DEV_NVLINK_COUNT_RX_BYTES: u32 = 1203;
pub const DCGM_FI_DEV_NVLINK_COUNT_RX_MALFORMED_PACKET_ERRORS: u32 = 1204;
pub const DCGM_FI_DEV_NVLINK_COUNT_RX_BUFFER_OVERRUN_ERRORS: u32 = 1205;
pub const DCGM_FI_DEV_NVLINK_COUNT_RX_ERRORS: u32 = 1206;
pub const DCGM_FI_DEV_NVLINK_COUNT_RX_REMOTE_ERRORS: u32 = 1207;
pub const DCGM_FI_DEV_NVLINK_COUNT_RX_GENERAL_ERRORS: u32 = 1208;
pub const DCGM_FI_DEV_NVLINK_COUNT_LOCAL_LINK_INTEGRITY_ERRORS: u32 = 1209;
pub const DCGM_FI_DEV_NVLINK_COUNT_TX_DISCARDS: u32 = 1210;
pub const DCGM_FI_DEV_NVLINK_COUNT_LINK_RECOVERY_SUCCESSFUL_EVENTS: u32 = 1211;
pub const DCGM_FI_DEV_NVLINK_COUNT_LINK_RECOVERY_FAILED_EVENTS: u32 = 1212;
pub const DCGM_FI_DEV_NVLINK_COUNT_LINK_RECOVERY_EVENTS: u32 = 1213;
pub const DCGM_FI_DEV_NVLINK_COUNT_RX_SYMBOL_ERRORS: u32 = 1214;
pub const DCGM_FI_DEV_NVLINK_COUNT_SYMBOL_BER: u32 = 1215;
pub const DCGM_FI_DEV_FIRST_CONNECTX_FIELD_ID: u32 = 1300;
pub const DCGM_FI_DEV_CONNECTX_HEALTH: u32 = 1300;
pub const DCGM_FI_DEV_CONNECTX_ACTIVE_PCIE_LINK_WIDTH: u32 = 1301;
pub const DCGM_FI_DEV_CONNECTX_ACTIVE_PCIE_LINK_SPEED: u32 = 1302;
pub const DCGM_FI_DEV_CONNECTX_EXPECT_PCIE_LINK_WIDTH: u32 = 1303;
pub const DCGM_FI_DEV_CONNECTX_EXPECT_PCIE_LINK_SPEED: u32 = 1304;
pub const DCGM_FI_DEV_CONNECTX_CORRECTABLE_ERR_STATUS: u32 = 1305;
pub const DCGM_FI_DEV_CONNECTX_CORRECTABLE_ERR_MASK: u32 = 1306;
pub const DCGM_FI_DEV_CONNECTX_UNCORRECTABLE_ERR_STATUS: u32 = 1307;
pub const DCGM_FI_DEV_CONNECTX_UNCORRECTABLE_ERR_MASK: u32 = 1308;
pub const DCGM_FI_DEV_CONNECTX_UNCORRECTABLE_ERR_SEVERITY: u32 = 1309;
pub const DCGM_FI_DEV_CONNECTX_DEVICE_TEMPERATURE: u32 = 1310;
pub const DCGM_FI_DEV_LAST_CONNECTX_FIELD_ID: u32 = 1399;
pub const DCGM_FI_MAX_FIELDS: u32 = 1311;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 28;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _STDINT_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const DCGM_INT8_BLANK: u32 = 112;
pub const DCGM_INT32_BLANK: u32 = 2147483632;
pub const DCGM_INT64_BLANK: u64 = 9223372036854775792;
pub const DCGM_FP64_BLANK: f64 = 140737488355328.0;
pub const DCGM_STR_BLANK: &[u8; 11] = b"<<<NULL>>>\0";
pub const DCGM_INT32_NOT_FOUND: u32 = 2147483633;
pub const DCGM_INT64_NOT_FOUND: u64 = 9223372036854775793;
pub const DCGM_FP64_NOT_FOUND: f64 = 140737488355329.0;
pub const DCGM_STR_NOT_FOUND: &[u8; 16] = b"<<<NOT_FOUND>>>\0";
pub const DCGM_INT32_NOT_SUPPORTED: u32 = 2147483634;
pub const DCGM_INT64_NOT_SUPPORTED: u64 = 9223372036854775794;
pub const DCGM_FP64_NOT_SUPPORTED: f64 = 140737488355330.0;
pub const DCGM_STR_NOT_SUPPORTED: &[u8; 20] = b"<<<NOT_SUPPORTED>>>\0";
pub const DCGM_INT32_NOT_PERMISSIONED: u32 = 2147483635;
pub const DCGM_INT64_NOT_PERMISSIONED: u64 = 9223372036854775795;
pub const DCGM_FP64_NOT_PERMISSIONED: f64 = 140737488355331.0;
pub const DCGM_STR_NOT_PERMISSIONED: &[u8; 15] = b"<<<NOT_PERM>>>\0";
pub const DCGM_MAX_NUM_DEVICES: u32 = 32;
pub const DCGM_NVLINK_MAX_LINKS_PER_GPU: u32 = 18;
pub const DCGM_NVLINK_ERROR_COUNT: u32 = 4;
pub const DCGM_HEALTH_WATCH_NVLINK_ERROR_NUM_FIELDS: u32 = 4;
pub const DCGM_NVLINK_MAX_LINKS_PER_GPU_LEGACY1: u32 = 6;
pub const DCGM_NVLINK_MAX_LINKS_PER_GPU_LEGACY2: u32 = 12;
pub const DCGM_MAX_NUM_SWITCHES: u32 = 12;
pub const DCGM_MAX_XID_INFO: u32 = 10;
pub const DCGM_NVLINK_MAX_LINKS_PER_NVSWITCH: u32 = 256;
pub const DCGM_LANE_MAX_LANES_PER_NVSWICH_LINK: u32 = 4;
pub const DCGM_MAX_VGPU_INSTANCES_PER_PGPU: u32 = 32;
pub const DCGM_MAX_NUM_CPUS: u32 = 8;
pub const DCGM_MAX_NUM_CPU_CORES: u32 = 1024;
pub const DCGM_MAX_STR_LENGTH: u32 = 256;
pub const DCGM_MAX_AGE_USEC_DEFAULT: u32 = 30000000;
pub const DCGM_MAX_CLOCKS: u32 = 256;
pub const DCGM_MAX_NUM_GROUPS: u32 = 64;
pub const DCGM_MAX_FBC_SESSIONS: u32 = 256;
pub const DCGM_VGPU_NAME_BUFFER_SIZE: u32 = 64;
pub const DCGM_GRID_LICENSE_BUFFER_SIZE: u32 = 128;
pub const DCGM_CONFIG_COMPUTEMODE_DEFAULT: u32 = 0;
pub const DCGM_CONFIG_COMPUTEMODE_PROHIBITED: u32 = 1;
pub const DCGM_CONFIG_COMPUTEMODE_EXCLUSIVE_PROCESS: u32 = 2;
pub const DCGM_HE_PORT_NUMBER: u32 = 5555;
pub const DCGM_GROUP_ALL_GPUS: u32 = 2147483647;
pub const DCGM_GROUP_ALL_NVSWITCHES: u32 = 2147483646;
pub const DCGM_GROUP_ALL_INSTANCES: u32 = 2147483645;
pub const DCGM_GROUP_ALL_COMPUTE_INSTANCES: u32 = 2147483644;
pub const DCGM_GROUP_ALL_ENTITIES: u32 = 2147483643;
pub const DCGM_GROUP_NULL: u32 = 2147483642;
pub const DCGM_GROUP_MAX_ENTITIES_V1: u32 = 64;
pub const DCGM_GROUP_MAX_ENTITIES_V2: u32 = 1024;
pub const DCGM_MAX_INSTANCES_PER_GPU: u32 = 8;
pub const DCGM_MAX_COMPUTE_INSTANCES_PER_GPU: u32 = 8;
pub const DCGM_MAX_TOTAL_INSTANCES_PER_GPU: u32 = 14;
pub const DCGM_MAX_HIERARCHY_INFO: u32 = 448;
pub const DCGM_MAX_INSTANCES: u32 = 256;
pub const DCGM_MAX_COMPUTE_INSTANCES: u32 = 256;
pub const DCGM_MAX_NUM_FIELD_GROUPS: u32 = 64;
pub const DCGM_MAX_FIELD_IDS_PER_FIELD_GROUP: u32 = 128;
pub const DCGM_MAX_VGPU_TYPES_PER_PGPU: u32 = 32;
pub const DCGM_DEVICE_UUID_BUFFER_SIZE: u32 = 80;
pub const DCGM_POWER_PROFILE_ARRAY_SIZE: u32 = 8;
pub const DCGM_POWER_PROFILE_MASK_BITS_PER_ELEM: u32 = 32;
pub const DCGM_POWER_PROFILE_MAX_NUM: u32 = 255;
pub const DCGM_POLICY_COND_IDX_MAX: u32 = 7;
pub const DCGM_POLICY_COND_MAX: u32 = 7;
pub const DCGM_MAX_BLOB_LENGTH: u32 = 4096;
pub const DCGM_FV_FLAG_LIVE_DATA: u32 = 1;
pub const DCGM_HEALTH_WATCH_COUNT_V1: u32 = 10;
pub const DCGM_HEALTH_WATCH_COUNT_V2: u32 = 12;
pub const DCGM_ERR_MSG_LENGTH: u32 = 512;
pub const DCGM_DIAG_AUX_DATA_LEN: u32 = 2048;
pub const DCGM_DIAG_TEST_RUN_ERROR_INDICES_MAX: u32 = 32;
pub const DCGM_DIAG_TEST_RUN_INFO_INDICES_MAX: u32 = 16;
pub const DCGM_DIAG_TEST_RUN_RESULTS_MAX: u32 = 1024;
pub const DCGM_DIAG_TEST_RUN_NAME_LEN: u32 = 32;
pub const DCGM_DEVICE_ID_LEN: u32 = 5;
pub const DCGM_VERSION_LEN: u32 = 12;
pub const DCGM_HEALTH_WATCH_MAX_INCIDENTS_V2: u32 = 1024;
pub const DCGM_MAX_PID_INFO_NUM: u32 = 16;
pub const DCGM_MAX_ERRORS: u32 = 5;
pub const DCGM_PER_GPU_TEST_COUNT_V8: u32 = 13;
pub const DCGM_PER_GPU_TEST_COUNT_V7: u32 = 9;
pub const DCGM_SWTEST_COUNT: u32 = 11;
pub const LEVEL_ONE_MAX_RESULTS: u32 = 16;
pub const DCGM_DIAG_RESPONSE_TESTS_MAX: u32 = 20;
pub const DCGM_DIAG_RESPONSE_SYSTEM_ERROR: u32 = 112;
pub const DCGM_DIAG_RESPONSE_ERRORS_MAX: u32 = 32;
pub const DCGM_DIAG_RESPONSE_INFO_MAX: u32 = 16;
pub const DCGM_DIAG_RESPONSE_ENTITIES_MAX: u32 = 1024;
pub const DCGM_DIAG_RESPONSE_RESULTS_MAX: u32 = 20480;
pub const DCGM_DIAG_RESPONSE_CATEGORIES_MAX: u32 = 5;
pub const DCGM_DIAG_RESPONSE_CATEGORY_LEN: u32 = 20;
pub const DCGM_DIAG_RESPONSE_V11_UNUSED_LEN: u32 = 682880;
pub const DCGM_AFFINITY_BITMASK_ARRAY_SIZE: u32 = 8;
pub const DCGM_MAX_CONFIG_FILE_LEN: u32 = 10000;
pub const DCGM_MAX_TEST_NAMES: u32 = 20;
pub const DCGM_MAX_TEST_NAMES_LEN: u32 = 50;
pub const DCGM_MAX_TEST_PARMS: u32 = 100;
pub const DCGM_MAX_TEST_PARMS_LEN: u32 = 100;
pub const DCGM_MAX_TEST_PARMS_LEN_V2: u32 = 1050;
pub const DCGM_GPU_LIST_LEN: u32 = 50;
pub const DCGM_ENTITY_ID_LIST_LEN: u32 = 2048;
pub const DCGM_EXPECTED_ENTITIES_LEN: u32 = 50;
pub const DCGM_FILE_LEN: u32 = 30;
pub const DCGM_PATH_LEN: u32 = 128;
pub const DCGM_CLOCKS_EVENT_MASK_LEN: u32 = 50;
pub const DCGM_IGNORE_ERROR_MAX_LEN: u32 = 512;
pub const DCGM_THROTTLE_MASK_LEN: u32 = 50;
pub const DCGM_HOME_DIR_VAR_NAME: &[u8; 14] = b"DCGM_HOME_DIR\0";
pub const DCGM_RUN_FLAGS_VERBOSE: u32 = 1;
pub const DCGM_RUN_FLAGS_STATSONFAIL: u32 = 2;
pub const DCGM_RUN_FLAGS_TRAIN: u32 = 4;
pub const DCGM_RUN_FLAGS_FORCE_TRAIN: u32 = 8;
pub const DCGM_RUN_FLAGS_FAIL_EARLY: u32 = 16;
pub const DCGM_GEGE_FLAG_ONLY_SUPPORTED: u32 = 1;
pub const DCGM_TOPO_HINT_F_NONE: u32 = 0;
pub const DCGM_TOPO_HINT_F_IGNOREHEALTH: u32 = 1;
pub const DCGM_SUMMARY_MIN: u32 = 1;
pub const DCGM_SUMMARY_MAX: u32 = 2;
pub const DCGM_SUMMARY_AVG: u32 = 4;
pub const DCGM_SUMMARY_SUM: u32 = 8;
pub const DCGM_SUMMARY_COUNT: u32 = 16;
pub const DCGM_SUMMARY_INTEGRAL: u32 = 32;
pub const DCGM_SUMMARY_DIFF: u32 = 64;
pub const DCGM_SUMMARY_SIZE: u32 = 7;
pub const DCGM_MODULE_STATUSES_CAPACITY: u32 = 16;
pub const DCGM_PROF_MAX_NUM_GROUPS_V2: u32 = 10;
pub const DCGM_PROF_MAX_FIELD_IDS_PER_GROUP_V2: u32 = 64;
pub const TRIAGE_RUN_FIELD_DIAG_MSG: &[u8; 35] = b"Run a field diagnostic on the GPU.\0";
pub const DEBUG_COOLING_MSG : & [u8 ; 135] = b"Verify that the cooling on this machine is functional, including external, thermal material interface, fans, and any other components.\0" ;
pub const BUG_REPORT_MSG: &[u8; 59] =
    b"Please capture an nvidia-bug-report and send it to NVIDIA.\0";
pub const SYSTEM_TRIAGE_MSG: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const CONFIG_MSG : & [u8 ; 97] = b"Check DCGM and system configuration. This error may be eliminated with an updated configuration.\0" ;
pub const DCGM_FR_OK_MSG: &[u8; 38] = b"The operation completed successfully.\0";
pub const DCGM_FR_UNKNOWN_MSG: &[u8; 15] = b"Unknown error.\0";
pub const DCGM_FR_UNRECOGNIZED_MSG: &[u8; 25] = b"Unrecognized error code.\0";
pub const DCGM_FR_PCI_REPLAY_RATE_MSG: &[u8; 62] =
    b"Detected more than %u PCIe replays per minute for GPU %u : %d\0";
pub const DCGM_FR_VOLATILE_DBE_DETECTED_MSG: &[u8; 56] =
    b"Detected %d volatile double-bit ECC error(s) in GPU %u.\0";
pub const DCGM_FR_VOLATILE_SBE_DETECTED_MSG: &[u8; 76] =
    b"More than %u single-bit ECC error(s) detected in GPU %u Volatile SBEs: %lld\0";
pub const DCGM_FR_PENDING_PAGE_RETIREMENTS_MSG: &[u8; 52] =
    b"A pending retired page has been detected in GPU %u.\0";
pub const DCGM_FR_RETIRED_PAGES_LIMIT_MSG: &[u8; 56] =
    b"%u or more retired pages have been detected in GPU %u. \0";
pub const DCGM_FR_RETIRED_PAGES_DBE_LIMIT_MSG : & [u8 ; 141] = b"An excess of %u retired pages due to DBEs have been detected and more than one page has been retired due to DBEs in the past week in GPU %u.\0" ;
pub const DCGM_FR_CORRUPT_INFOROM_MSG: &[u8; 47] =
    b"A corrupt InfoROM has been detected in GPU %u.\0";
pub const DCGM_FR_CLOCKS_EVENT_THERMAL_MSG: &[u8; 58] =
    b"Detected clocks event due to thermal violation in GPU %u.\0";
pub const DCGM_FR_POWER_UNREADABLE_MSG: &[u8; 49] =
    b"Cannot reliably read the power usage for GPU %u.\0";
pub const DCGM_FR_CLOCKS_EVENT_POWER_MSG: &[u8; 56] =
    b"Detected clocks event due to power violation in GPU %u.\0";
pub const DCGM_FR_NVLINK_ERROR_THRESHOLD_MSG: &[u8; 79] =
    b"Detected %ld %s NvLink errors on GPU %u's NVLink which exceeds threshold of %u\0";
pub const DCGM_FR_NVLINK_DOWN_MSG: &[u8; 42] = b"GPU %u's NvLink link %d is currently down\0";
pub const DCGM_FR_GPU_EXPECTED_NVLINKS_UP_MSG: &[u8; 46] =
    b"Only %u NvLinks are up out of the expected %u\0";
pub const DCGM_FR_NVSWITCH_EXPECTED_NVLINKS_UP_MSG: &[u8; 60] =
    b"NvSwitch %u - Only %u NvLinks are up out of the expected %u\0";
pub const DCGM_FR_NVSWITCH_FATAL_ERROR_MSG: &[u8; 45] =
    b"Detected fatal errors on NvSwitch %u link %u\0";
pub const DCGM_FR_NVSWITCH_NON_FATAL_ERROR_MSG: &[u8; 48] =
    b"Detected nonfatal errors on NvSwitch %u link %u\0";
pub const DCGM_FR_NVSWITCH_DOWN_MSG: &[u8; 60] =
    b"NvSwitch physical ID %u's NvLink port %d is currently down.\0";
pub const DCGM_FR_NO_ACCESS_TO_FILE_MSG: &[u8; 43] =
    b"File %s could not be accessed directly: %s\0";
pub const DCGM_FR_NVML_API_MSG: &[u8; 30] = b"Error calling NVML API %s: %s\0";
pub const DCGM_FR_DEVICE_COUNT_MISMATCH_MSG: &[u8; 84] =
    b"The number of devices NVML returns is different than the number of devices in /dev.\0";
pub const DCGM_FR_BAD_PARAMETER_MSG: &[u8; 49] =
    b"Bad parameter to function %s cannot be processed\0";
pub const DCGM_FR_CANNOT_OPEN_LIB_MSG: &[u8; 29] = b"Cannot open library %s: '%s'\0";
pub const DCGM_FR_DENYLISTED_DRIVER_MSG: &[u8; 33] = b"Found driver on the denylist: %s\0";
pub const DCGM_FR_NVML_LIB_BAD_MSG: &[u8; 46] = b"Cannot get pointer to %s from libnvidia-ml.so\0";
pub const DCGM_FR_GRAPHICS_PROCESSES_MSG : & [u8 ; 120] = b"NVVS has detected processes with graphics contexts open running on at least one GPU. This may cause some tests to fail.\0" ;
pub const DCGM_FR_HOSTENGINE_CONN_MSG: &[u8; 43] = b"Could not connect to the host engine: '%s'\0";
pub const DCGM_FR_FIELD_QUERY_MSG: &[u8; 36] = b"Could not query field %s for GPU %u\0";
pub const DCGM_FR_BAD_CUDA_ENV_MSG: &[u8; 59] =
    b"Found CUDA performance-limiting environment variable '%s'.\0";
pub const DCGM_FR_PERSISTENCE_MODE_MSG: &[u8; 41] = b"Persistence mode for GPU %u is disabled.\0";
pub const DCGM_FR_LOW_BANDWIDTH_MSG : & [u8 ; 95] = b"Bandwidth of GPU %u in direction %s of %.2f did not exceed minimum required bandwidth of %.2f.\0" ;
pub const DCGM_FR_HIGH_LATENCY_MSG: &[u8; 79] =
    b"Latency type %s of GPU %u value %.2f exceeded maximum allowed latency of %.2f.\0";
pub const DCGM_FR_CANNOT_GET_FIELD_TAG_MSG: &[u8; 49] =
    b"Unable to get field information for field id %hu\0";
pub const DCGM_FR_FIELD_VIOLATION_MSG: &[u8; 27] = b"Detected %ld %s for GPU %u\0";
pub const DCGM_FR_FIELD_THRESHOLD_MSG: &[u8; 60] =
    b"Detected %ld %s for GPU %u which is above the threshold %ld\0";
pub const DCGM_FR_FIELD_VIOLATION_DBL_MSG: &[u8; 28] = b"Detected %.1f %s for GPU %u\0";
pub const DCGM_FR_FIELD_THRESHOLD_DBL_MSG: &[u8; 62] =
    b"Detected %.1f %s for GPU %u which is above the threshold %.1f\0";
pub const DCGM_FR_UNSUPPORTED_FIELD_TYPE_MSG: &[u8; 88] =
    b"Field %s is not supported by this API because it is neither an int64 nor a double type.\0";
pub const DCGM_FR_FIELD_THRESHOLD_TS_MSG: &[u8; 87] =
    b"%s met or exceeded the threshold of %lu per second: %lu at %.1f seconds into the test.\0";
pub const DCGM_FR_FIELD_THRESHOLD_TS_DBL_MSG: &[u8; 89] =
    b"%s met or exceeded the threshold of %.1f per second: %.1f at %.1f seconds into the test.\0";
pub const DCGM_FR_THERMAL_VIOLATIONS_MSG: &[u8; 63] =
    b"There were thermal violations totaling %.1f seconds for GPU %u\0";
pub const DCGM_FR_THERMAL_VIOLATIONS_TS_MSG: &[u8; 90] =
    b"Thermal violations totaling %.1f seconds started at %.1f seconds into the test for GPU %u\0";
pub const DCGM_FR_TEMP_VIOLATION_MSG: &[u8; 83] =
    b"Temperature %lld of %s %u exceeded user-specified maximum allowed temperature %lld\0";
pub const DCGM_FR_CLOCKS_EVENT_VIOLATION_MSG: &[u8; 88] =
    b"Clocks event for GPU %u because of clocks event starting %.1f seconds into the test. %s\0";
pub const DCGM_FR_INTERNAL_MSG: &[u8; 50] = b"There was an internal error during the test: '%s'\0";
pub const DCGM_FR_PCIE_GENERATION_MSG : & [u8 ; 119] = b"GPU %u is running at PCI link generation %d, which is below the minimum allowed link generation of %d (parameter '%s')\0" ;
pub const DCGM_FR_PCIE_WIDTH_MSG : & [u8 ; 115] = b"GPU %u is running at PCI link width %dX, which is below the minimum allowed link generation of %d (parameter '%s')\0" ;
pub const DCGM_FR_ABORTED_MSG: &[u8; 42] = b"Test was aborted early due to user signal\0";
pub const DCGM_FR_TEST_DISABLED_MSG: &[u8; 24] = b"The %s test is skipped.\0";
pub const DCGM_FR_CANNOT_GET_STAT_MSG: &[u8; 48] =
    b"Unable to generate / collect stat %s for GPU %u\0";
pub const DCGM_FR_STRESS_LEVEL_MSG: &[u8; 79] =
    b"Max stress level of %.1f did not reach desired stress level of %.1f for GPU %u\0";
pub const DCGM_FR_CUDA_API_MSG: &[u8; 24] = b"Error using CUDA API %s\0";
pub const DCGM_FR_FAULTY_MEMORY_MSG: &[u8; 44] = b"Found %lld faulty memory elements on GPU %u\0";
pub const DCGM_FR_CANNOT_SET_WATCHES_MSG: &[u8; 40] = b"Unable to add field watches to DCGM: %s\0";
pub const DCGM_FR_CUDA_UNBOUND_MSG: &[u8; 60] =
    b"Cuda GPU %d is no longer bound to a CUDA context...Aborting\0";
pub const DCGM_FR_ECC_DISABLED_MSG: &[u8; 54] =
    b"Skipping test %s because ECC is not enabled on GPU %u\0";
pub const DCGM_FR_MEMORY_ALLOC_MSG: &[u8; 58] =
    b"Couldn't allocate at least %.1f%% of GPU memory on GPU %u\0";
pub const DCGM_FR_CUDA_DBE_MSG: &[u8; 76] =
    b"CUDA APIs have indicated that a double-bit ECC error has occured on GPU %u.\0";
pub const DCGM_FR_MEMORY_MISMATCH_MSG: &[u8; 85] =
    b"A memory mismatch was detected on GPU %u, but no error was reported by CUDA or NVML.\0";
pub const DCGM_FR_CUDA_DEVICE_MSG: &[u8; 60] =
    b"Unable to find a corresponding CUDA device for GPU %u: '%s'\0";
pub const DCGM_FR_ECC_UNSUPPORTED_MSG: &[u8; 62] =
    b"ECC Memory is not turned on or is unsupported. Skipping test.\0";
pub const DCGM_FR_ECC_PENDING_MSG: &[u8; 45] = b"ECC memory for GPU %u is in a pending state.\0";
pub const DCGM_FR_MEMORY_BANDWIDTH_MSG : & [u8 ; 92] = b"GPU %u only achieved a memory bandwidth of %.2f GB/s, failing to meet %.2f GB/s for test %d\0" ;
pub const DCGM_FR_TARGET_POWER_MSG: &[u8; 76] =
    b"Max power of %.1f did not reach desired power minimum %s of %.1f for GPU %u\0";
pub const DCGM_FR_API_FAIL_MSG: &[u8; 25] = b"API call %s failed: '%s'\0";
pub const DCGM_FR_API_FAIL_GPU_MSG: &[u8; 36] = b"API call %s failed for GPU %u: '%s'\0";
pub const DCGM_FR_CUDA_CONTEXT_MSG: &[u8; 43] = b"GPU %u failed to create a CUDA context: %s\0";
pub const DCGM_FR_DCGM_API_MSG: &[u8; 24] = b"Error using DCGM API %s\0";
pub const DCGM_FR_CONCURRENT_GPUS_MSG: &[u8; 78] =
    b"Unable to run concurrent pair bandwidth test without 2 or more gpus. Skipping\0";
pub const DCGM_FR_TOO_MANY_ERRORS_MSG : & [u8 ; 131] = b"This API can only return up to four errors per system. Additional errors were found for this system that couldn't be communicated.\0" ;
pub const DCGM_FR_NVLINK_CRC_ERROR_THRESHOLD_MSG : & [u8 ; 98] = b"%.1f %s NvLink errors found occuring per second on GPU %u, exceeding the limit of 100 per second.\0" ;
pub const DCGM_FR_NVLINK_ERROR_CRITICAL_MSG: &[u8; 63] =
    b"Detected %ld %s NvLink errors on GPU %u's NVLink (should be 0)\0";
pub const DCGM_FR_ENFORCED_POWER_LIMIT_MSG : & [u8 ; 101] = b"Enforced power limit on GPU %u set to %.1f, which is too low to attempt to achieve target power %.1f\0" ;
pub const DCGM_FR_MEMORY_ALLOC_HOST_MSG: &[u8; 38] = b"Cannot allocate %zu bytes on the host\0";
pub const DCGM_FR_GPU_OP_MODE_MSG: &[u8; 66] =
    b"Skipping plugin due to a GPU being in GPU Operating Mode: LOW_DP.\0";
pub const DCGM_FR_NO_MEMORY_CLOCKS_MSG: &[u8; 69] =
    b"No memory clocks <= %u MHZ were found in %u supported memory clocks.\0";
pub const DCGM_FR_NO_GRAPHICS_CLOCKS_MSG : & [u8 ; 97] = b"No graphics clocks <= %u MHZ were found in %u supported graphics clocks for memory clock %u MHZ.\0" ;
pub const DCGM_FR_HAD_TO_RESTORE_STATE_MSG: &[u8; 44] =
    b"Had to restore GPU state on NVML GPU(s): %s\0";
pub const DCGM_FR_L1TAG_UNSUPPORTED_MSG: &[u8; 61] =
    b"This card does not support the L1 cache test. Skipping test.\0";
pub const DCGM_FR_L1TAG_MISCOMPARE_MSG: &[u8; 47] =
    b"Detected a miscompare failure in the L1 cache.\0";
pub const DCGM_FR_ROW_REMAP_FAILURE_MSG: &[u8; 65] =
    b"GPU %u had uncorrectable memory errors and row remapping failed.\0";
pub const DCGM_FR_UNCONTAINED_ERROR_MSG: &[u8; 38] = b"GPU had an uncontained error (XID 95)\0";
pub const DCGM_FR_EMPTY_GPU_LIST_MSG: &[u8; 31] = b"No valid GPUs passed to plugin\0";
pub const DCGM_FR_DBE_PENDING_PAGE_RETIREMENTS_MSG: &[u8; 70] =
    b"Pending page retirements together with a DBE were detected on GPU %u.\0";
pub const DCGM_FR_UNCORRECTABLE_ROW_REMAP_MSG: &[u8; 65] =
    b"GPU %u had uncorrectable memory errors and %u rows were remapped\0";
pub const DCGM_FR_PENDING_ROW_REMAP_MSG: &[u8; 56] =
    b"GPU %u had memory errors and row remappings are pending\0";
pub const DCGM_FR_BROKEN_P2P_MEMORY_DEVICE_MSG: &[u8; 74] =
    b"GPU %u was unsuccessfully written to by GPU %u in a peer-to-peer test: %s\0";
pub const DCGM_FR_BROKEN_P2P_WRITER_DEVICE_MSG: &[u8; 70] =
    b"GPU %u unsuccessfully wrote data to GPU %u in a peer-to-peer test: %s\0";
pub const DCGM_FR_BROKEN_P2P_PCIE_MEMORY_DEVICE_MSG: &[u8; 84] =
    b"GPU %u was unsuccessfully written to by GPU %u over PCIe in a peer-to-peer test: %s\0";
pub const DCGM_FR_BROKEN_P2P_PCIE_WRITER_DEVICE_MSG: &[u8; 80] =
    b"GPU %u unsuccessfully wrote data to GPU %u over PCIe in a peer-to-peer test: %s\0";
pub const DCGM_FR_BROKEN_P2P_NVLINK_MEMORY_DEVICE_MSG: &[u8; 86] =
    b"GPU %u was unsuccessfully written to by GPU %u over NVLink in a peer-to-peer test: %s\0";
pub const DCGM_FR_BROKEN_P2P_NVLINK_WRITER_DEVICE_MSG: &[u8; 82] =
    b"GPU %u unsuccessfully wrote data to GPU %u over NVLink in a peer-to-peer test: %s\0";
pub const DCGM_FR_NVSWITCH_NVLINK_DOWN_MSG: &[u8; 33] = b"NVSwitch %u's NvLink %u is down.\0";
pub const DCGM_FR_EUD_BINARY_PERMISSIONS_MSG: &[u8; 1] = b"\0";
pub const DCGM_FR_EUD_NON_ROOT_USER_MSG: &[u8; 1] = b"\0";
pub const DCGM_FR_EUD_SPAWN_FAILURE_MSG: &[u8; 1] = b"\0";
pub const DCGM_FR_EUD_TIMEOUT_MSG: &[u8; 1] = b"\0";
pub const DCGM_FR_EUD_ZOMBIE_MSG: &[u8; 1] = b"\0";
pub const DCGM_FR_EUD_NON_ZERO_EXIT_CODE_MSG: &[u8; 1] = b"\0";
pub const DCGM_FR_EUD_TEST_FAILED_MSG: &[u8; 1] = b"\0";
pub const DCGM_FR_FILE_CREATE_PERMISSIONS_MSG: &[u8; 81] =
    b"The DCGM Diagnostic does not have permissions to create a file in directory '%s'\0";
pub const DCGM_FR_PAUSE_RESUME_FAILED_MSG: &[u8; 1] = b"\0";
pub const DCGM_FR_PCIE_H_REPLAY_VIOLATION_MSG: &[u8; 71] =
    b"GPU %u host-side PCIe replay violation, see dmesg for more information\0";
pub const DCGM_FR_XID_ERROR_MSG: &[u8; 27] = b"Detected XID %u for GPU %u\0";
pub const DCGM_FR_SBE_VIOLATION_MSG: &[u8; 27] = b"Detected %ld %s for GPU %u\0";
pub const DCGM_FR_DBE_VIOLATION_MSG: &[u8; 27] = b"Detected %ld %s for GPU %u\0";
pub const DCGM_FR_PCIE_REPLAY_VIOLATION_MSG: &[u8; 27] = b"Detected %ld %s for GPU %u\0";
pub const DCGM_FR_SBE_THRESHOLD_VIOLATION_MSG: &[u8; 60] =
    b"Detected %ld %s for GPU %u which is above the threshold %ld\0";
pub const DCGM_FR_DBE_THRESHOLD_VIOLATION_MSG: &[u8; 60] =
    b"Detected %ld %s for GPU %u which is above the threshold %ld\0";
pub const DCGM_FR_PCIE_REPLAY_THRESHOLD_VIOLATION_MSG: &[u8; 60] =
    b"Detected %ld %s for GPU %u which is above the threshold %ld\0";
pub const DCGM_FR_CUDA_FM_NOT_INITIALIZED_MSG: &[u8; 1] = b"\0";
pub const DCGM_FR_SXID_ERROR_MSG: &[u8; 32] = b"Detected fatal NvSwitch SXID %u\0";
pub const DCGM_FR_GFLOPS_THRESHOLD_VIOLATION_MSG: &[u8; 62] =
    b"Detected %.2f %s for GPU %u which is below the threshold %.2f\0";
pub const DCGM_FR_NAN_VALUE_MSG: &[u8; 47] = b"Found %lld NaN-value memory elements on GPU %u\0";
pub const DCGM_FR_FABRIC_MANAGER_TRAINING_ERROR_MSG: &[u8; 55] =
    b"Fabric Manager (Cluster UUID: %s, Clique ID: %ld): %s.\0";
pub const DCGM_FR_TEST_SKIPPED_MSG: &[u8; 21] = b"Test %s was skipped.\0";
pub const DCGM_FR_ERROR_SENTINEL_MSG: &[u8; 1] = b"\0";
pub const DCGM_FR_OK_NEXT: &[u8; 4] = b"N/A\0";
pub const DCGM_FR_UNKNOWN_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_UNRECOGNIZED_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_PCI_REPLAY_RATE_NEXT : & [u8 ; 149] = b"Reconnect PCIe card. Run system side PCIE diagnostic utilities to verify hops off the GPU board. If issue is on the board, run the field diagnostic.\0" ;
pub const DCGM_FR_VOLATILE_DBE_DETECTED_NEXT: &[u8; 47] =
    b"Drain the GPU and reset it or reboot the node.\0";
pub const DCGM_FR_VOLATILE_SBE_DETECTED_NEXT: &[u8; 47] =
    b"Monitor - this GPU can still perform workload.\0";
pub const DCGM_FR_PENDING_PAGE_RETIREMENTS_NEXT: &[u8; 46] =
    b"Monitor - this GPU can still perform workload\0";
pub const DCGM_FR_RETIRED_PAGES_LIMIT_NEXT: &[u8; 35] = b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_RETIRED_PAGES_DBE_LIMIT_NEXT: &[u8; 35] = b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_CORRUPT_INFOROM_NEXT: &[u8; 44] =
    b"Flash the InfoROM to clear this corruption.\0";
pub const DCGM_FR_CLOCKS_EVENT_THERMAL_NEXT : & [u8 ; 135] = b"Verify that the cooling on this machine is functional, including external, thermal material interface, fans, and any other components.\0" ;
pub const DCGM_FR_POWER_UNREADABLE_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_CLOCKS_EVENT_POWER_NEXT: &[u8; 67] =
    b"Monitor the power conditions. This GPU can still perform workload.\0";
pub const DCGM_FR_NVLINK_ERROR_THRESHOLD_NEXT: &[u8; 51] =
    b"Monitor the NVLink. It can still perform workload.\0";
pub const DCGM_FR_NVLINK_DOWN_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_NVSWITCH_FATAL_ERROR_NEXT: &[u8; 35] = b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_NVSWITCH_NON_FATAL_ERROR_NEXT: &[u8; 53] =
    b"Monitor the NVSwitch. It can still perform workload.\0";
pub const DCGM_FR_NVSWITCH_DOWN_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_NO_ACCESS_TO_FILE_NEXT: &[u8; 63] =
    b"Check relevant permissions, access, and existence of the file.\0";
pub const DCGM_FR_GPU_EXPECTED_NVLINKS_UP_NEXT : & [u8 ; 99] = b"Ensure Fabric Manager is running. Check system logs, dmesg, and fabric-manager logs for more info.\0" ;
pub const DCGM_FR_NVSWITCH_EXPECTED_NVLINKS_UP_NEXT : & [u8 ; 99] = b"Ensure Fabric Manager is running. Check system logs, dmesg, and fabric-manager logs for more info.\0" ;
pub const DCGM_FR_NVML_API_NEXT : & [u8 ; 92] = b"Check the error condition and ensure that appropriate libraries are present and accessible.\0" ;
pub const DCGM_FR_DEVICE_COUNT_MISMATCH_NEXT : & [u8 ; 93] = b"Check for the presence of cgroups, operating system blocks, and or unsupported / older cards\0" ;
pub const DCGM_FR_BAD_PARAMETER_NEXT: &[u8; 59] =
    b"Please capture an nvidia-bug-report and send it to NVIDIA.\0";
pub const DCGM_FR_CANNOT_OPEN_LIB_NEXT: &[u8; 74] =
    b"Check for the existence of the library and set LD_LIBRARY_PATH if needed.\0";
pub const DCGM_FR_DENYLISTED_DRIVER_NEXT: &[u8; 36] = b"Please load the appropriate driver.\0";
pub const DCGM_FR_NVML_LIB_BAD_NEXT : & [u8 ; 96] = b"Make sure that the required version of libnvidia-ml.so is present and accessible on the system.\0" ;
pub const DCGM_FR_GRAPHICS_PROCESSES_NEXT : & [u8 ; 108] = b"Stop the graphics processes or run this diagnostic on a server that is not being used for display purposes.\0" ;
pub const DCGM_FR_HOSTENGINE_CONN_NEXT: &[u8; 77] =
    b"If hostengine is run separately, please ensure that it is up and responsive.\0";
pub const DCGM_FR_FIELD_QUERY_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_BAD_CUDA_ENV_NEXT: &[u8; 65] =
    b"Please unset this environment variable to address test failures.\0";
pub const DCGM_FR_PERSISTENCE_MODE_NEXT: &[u8; 75] =
    b"Enable persistence mode by running \"nvidia-smi -i <gpuId> -pm 1 \" as root.\0";
pub const DCGM_FR_LOW_BANDWIDTH_NEXT : & [u8 ; 153] = b"Verify that your minimum bandwidth setting is appropriate for the topology of each GPU. If so, and errors are consistent, please run a field diagnostic.\0" ;
pub const DCGM_FR_HIGH_LATENCY_NEXT : & [u8 ; 151] = b"Verify that your maximum latency setting is appropriate for the topology of each GPU. If so, and errors are consistent, please run a field diagnostic.\0" ;
pub const DCGM_FR_CANNOT_GET_FIELD_TAG_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_FIELD_VIOLATION_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_FIELD_THRESHOLD_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_FIELD_VIOLATION_DBL_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_FIELD_THRESHOLD_DBL_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_UNSUPPORTED_FIELD_TYPE_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_FIELD_THRESHOLD_TS_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_FIELD_THRESHOLD_TS_DBL_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_THERMAL_VIOLATIONS_NEXT : & [u8 ; 135] = b"Verify that the cooling on this machine is functional, including external, thermal material interface, fans, and any other components.\0" ;
pub const DCGM_FR_THERMAL_VIOLATIONS_TS_NEXT : & [u8 ; 135] = b"Verify that the cooling on this machine is functional, including external, thermal material interface, fans, and any other components.\0" ;
pub const DCGM_FR_TEMP_VIOLATION_NEXT : & [u8 ; 255] = b"Verify that the user-specified temperature maximum is set correctly. If it is, check the cooling for this GPU and node: Verify that the cooling on this machine is functional, including external, thermal material interface, fans, and any other components.\0" ;
pub const DCGM_FR_CLOCKS_EVENT_VIOLATION_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_INTERNAL_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_PCIE_GENERATION_NEXT : & [u8 ; 97] = b"Check DCGM and system configuration. This error may be eliminated with an updated configuration.\0" ;
pub const DCGM_FR_PCIE_WIDTH_NEXT : & [u8 ; 97] = b"Check DCGM and system configuration. This error may be eliminated with an updated configuration.\0" ;
pub const DCGM_FR_ABORTED_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_TEST_DISABLED_NEXT : & [u8 ; 97] = b"Check DCGM and system configuration. This error may be eliminated with an updated configuration.\0" ;
pub const DCGM_FR_CANNOT_GET_STAT_NEXT: &[u8; 76] =
    b"If running a standalone nv-hostengine, verify that it is up and responsive.\0";
pub const DCGM_FR_STRESS_LEVEL_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_CUDA_API_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_FAULTY_MEMORY_NEXT: &[u8; 35] = b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_CANNOT_SET_WATCHES_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_CUDA_UNBOUND_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_ECC_DISABLED_NEXT : & [u8 ; 124] = b"Enable ECC memory by running \"nvidia-smi -i <gpuId> -e 1\" to enable. This may require a GPU reset or reboot to take effect.\0" ;
pub const DCGM_FR_MEMORY_ALLOC_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_CUDA_DBE_NEXT: &[u8; 35] = b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_MEMORY_MISMATCH_NEXT: &[u8; 35] = b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_CUDA_DEVICE_NEXT : & [u8 ; 142] = b"Make sure CUDA_VISIBLE_DEVICES is not preventing visibility of this GPU. Also check if CUDA libraries are compatible and correctly installed.\0" ;
pub const DCGM_FR_ECC_UNSUPPORTED_NEXT : & [u8 ; 97] = b"Check DCGM and system configuration. This error may be eliminated with an updated configuration.\0" ;
pub const DCGM_FR_ECC_PENDING_NEXT: &[u8; 49] =
    b"Reboot to complete activation of the ECC memory.\0";
pub const DCGM_FR_MEMORY_BANDWIDTH_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_TARGET_POWER_NEXT: &[u8; 59] =
    b"Verify that the clock speeds and GPU utilization are high.\0";
pub const DCGM_FR_API_FAIL_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_API_FAIL_GPU_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_CUDA_CONTEXT_NEXT : & [u8 ; 111] = b"Please make sure the correct driver version is installed and verify that no conflicting libraries are present.\0" ;
pub const DCGM_FR_DCGM_API_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_CONCURRENT_GPUS_NEXT : & [u8 ; 97] = b"Check DCGM and system configuration. This error may be eliminated with an updated configuration.\0" ;
pub const DCGM_FR_TOO_MANY_ERRORS_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_NVLINK_CRC_ERROR_THRESHOLD_NEXT: &[u8; 35] =
    b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_NVLINK_ERROR_CRITICAL_NEXT: &[u8; 35] = b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_ENFORCED_POWER_LIMIT_NEXT : & [u8 ; 168] = b"If this enforced power limit is necessary, then this test cannot be run. If it is unnecessary, then raise the enforced power limit setting to be able to run this test.\0" ;
pub const DCGM_FR_MEMORY_ALLOC_HOST_NEXT: &[u8; 49] =
    b"Manually kill processes or restart your machine.\0";
pub const DCGM_FR_GPU_OP_MODE_NEXT: &[u8; 74] =
    b"Fix by running nvidia-smi as root with: nvidia-smi --gom=0 -i <gpu index>\0";
pub const DCGM_FR_NO_MEMORY_CLOCKS_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_NO_GRAPHICS_CLOCKS_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_HAD_TO_RESTORE_STATE_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_L1TAG_UNSUPPORTED_NEXT : & [u8 ; 97] = b"Check DCGM and system configuration. This error may be eliminated with an updated configuration.\0" ;
pub const DCGM_FR_L1TAG_MISCOMPARE_NEXT: &[u8; 35] = b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_ROW_REMAP_FAILURE_NEXT: &[u8; 35] = b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_UNCONTAINED_ERROR_NEXT: &[u8; 47] =
    b"Drain the GPU and reset it or reboot the node.\0";
pub const DCGM_FR_DBE_PENDING_PAGE_RETIREMENTS_NEXT: &[u8; 69] =
    b"Drain the GPU and reset it or reboot the node to resolve this issue.\0";
pub const DCGM_FR_EMPTY_GPU_LIST_NEXT : & [u8 ; 97] = b"Check DCGM and system configuration. This error may be eliminated with an updated configuration.\0" ;
pub const DCGM_FR_UNCORRECTABLE_ROW_REMAP_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_PENDING_ROW_REMAP_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_BROKEN_P2P_MEMORY_DEVICE_NEXT: &[u8; 59] =
    b"Please capture an nvidia-bug-report and send it to NVIDIA.\0";
pub const DCGM_FR_BROKEN_P2P_WRITER_DEVICE_NEXT: &[u8; 59] =
    b"Please capture an nvidia-bug-report and send it to NVIDIA.\0";
pub const DCGM_FR_BROKEN_P2P_PCIE_MEMORY_DEVICE_NEXT: &[u8; 59] =
    b"Please capture an nvidia-bug-report and send it to NVIDIA.\0";
pub const DCGM_FR_BROKEN_P2P_PCIE_WRITER_DEVICE_NEXT: &[u8; 59] =
    b"Please capture an nvidia-bug-report and send it to NVIDIA.\0";
pub const DCGM_FR_BROKEN_P2P_NVLINK_MEMORY_DEVICE_NEXT: &[u8; 59] =
    b"Please capture an nvidia-bug-report and send it to NVIDIA.\0";
pub const DCGM_FR_BROKEN_P2P_NVLINK_WRITER_DEVICE_NEXT: &[u8; 59] =
    b"Please capture an nvidia-bug-report and send it to NVIDIA.\0";
pub const DCGM_FR_NVSWITCH_NVLINK_DOWN_NEXT : & [u8 ; 133] = b"Please check fabric manager and initialization logs to figure out why the link is down. You may also need to run a field diagnostic.\0" ;
pub const DCGM_FR_EUD_BINARY_PERMISSIONS_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_EUD_NON_ROOT_USER_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_EUD_SPAWN_FAILURE_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_EUD_TIMEOUT_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_EUD_ZOMBIE_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_EUD_NON_ZERO_EXIT_CODE_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_EUD_TEST_FAILED_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_FILE_CREATE_PERMISSIONS_NEXT : & [u8 ; 200] = b"Please restart the hostengine with parameter --home-dir to specify a different home directory for the diagnostic or change permissions in the current directory to allow the user to write files there.\0" ;
pub const DCGM_FR_PAUSE_RESUME_FAILED_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_PCIE_H_REPLAY_VIOLATION_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_XID_ERROR_NEXT: &[u8; 58] =
    b"Please consult the documentation for details of this XID.\0";
pub const DCGM_FR_SBE_VIOLATION_NEXT: &[u8; 35] = b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_DBE_VIOLATION_NEXT: &[u8; 35] = b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_PCIE_REPLAY_VIOLATION_NEXT: &[u8; 35] = b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_SBE_THRESHOLD_VIOLATION_NEXT: &[u8; 35] = b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_DBE_THRESHOLD_VIOLATION_NEXT: &[u8; 35] = b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_PCIE_REPLAY_THRESHOLD_VIOLATION_NEXT: &[u8; 35] =
    b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_CUDA_FM_NOT_INITIALIZED_NEXT: &[u8; 57] =
    b"Ensure that the FabricManager is running without errors.\0";
pub const DCGM_FR_SXID_ERROR_NEXT: &[u8; 83] =
    b"Check DCGM and system logs for errors. Reset GPU. Restart DCGM. Rerun diagnostics.\0";
pub const DCGM_FR_GFLOPS_THRESHOLD_VIOLATION_NEXT : & [u8 ; 143] = b"Please verify your user-specified variance tolerance is set appropriately; if so, and if errors are persistent, please run a field diagnostic.\0" ;
pub const DCGM_FR_NAN_VALUE_NEXT: &[u8; 35] = b"Run a field diagnostic on the GPU.\0";
pub const DCGM_FR_FABRIC_MANAGER_TRAINING_ERROR_NEXT: &[u8; 57] =
    b"Ensure that the FabricManager is running without errors.\0";
pub const DCGM_FR_TEST_SKIPPED_NEXT: &[u8; 1] = b"\0";
pub const DCGM_FR_ERROR_SENTINEL_NEXT: &[u8; 1] = b"\0";
#[doc = "!< Represents Bare Metal GPU"]
pub const dcgmGpuVirtualizationMode_t_DCGM_GPU_VIRTUALIZATION_MODE_NONE:
    dcgmGpuVirtualizationMode_t = 0;
#[doc = "!< Device is associated with GPU-Passthrough"]
pub const dcgmGpuVirtualizationMode_t_DCGM_GPU_VIRTUALIZATION_MODE_PASSTHROUGH:
    dcgmGpuVirtualizationMode_t = 1;
#[doc = "!< Device is associated with vGPU inside virtual machine."]
pub const dcgmGpuVirtualizationMode_t_DCGM_GPU_VIRTUALIZATION_MODE_VGPU:
    dcgmGpuVirtualizationMode_t = 2;
#[doc = "!< Device is associated with VGX hypervisor in vGPU mode"]
pub const dcgmGpuVirtualizationMode_t_DCGM_GPU_VIRTUALIZATION_MODE_HOST_VGPU:
    dcgmGpuVirtualizationMode_t = 3;
#[doc = "!< Device is associated with VGX hypervisor in vSGA mode"]
pub const dcgmGpuVirtualizationMode_t_DCGM_GPU_VIRTUALIZATION_MODE_HOST_VSGA:
    dcgmGpuVirtualizationMode_t = 4;
#[doc = " GPU virtualization mode types for DCGM_FI_DEV_VIRTUAL_MODE"]
pub type dcgmGpuVirtualizationMode_t = ::std::os::raw::c_uint;
#[doc = "< Field is not associated with an entity. Field scope should be DCGM_FS_GLOBAL"]
pub const dcgm_field_entity_group_t_DCGM_FE_NONE: dcgm_field_entity_group_t = 0;
#[doc = "< Field is associated with a GPU entity"]
pub const dcgm_field_entity_group_t_DCGM_FE_GPU: dcgm_field_entity_group_t = 1;
#[doc = "< Field is associated with a VGPU entity"]
pub const dcgm_field_entity_group_t_DCGM_FE_VGPU: dcgm_field_entity_group_t = 2;
#[doc = "< Field is associated with a Switch entity"]
pub const dcgm_field_entity_group_t_DCGM_FE_SWITCH: dcgm_field_entity_group_t = 3;
#[doc = "< Field is associated with a GPU Instance entity"]
pub const dcgm_field_entity_group_t_DCGM_FE_GPU_I: dcgm_field_entity_group_t = 4;
#[doc = "< Field is associated with a GPU Compute Instance entity"]
pub const dcgm_field_entity_group_t_DCGM_FE_GPU_CI: dcgm_field_entity_group_t = 5;
#[doc = "< Field is associated with an NVLink"]
pub const dcgm_field_entity_group_t_DCGM_FE_LINK: dcgm_field_entity_group_t = 6;
#[doc = "< Field is associated with a CPU node"]
pub const dcgm_field_entity_group_t_DCGM_FE_CPU: dcgm_field_entity_group_t = 7;
#[doc = "< Field is associated with a CPU"]
pub const dcgm_field_entity_group_t_DCGM_FE_CPU_CORE: dcgm_field_entity_group_t = 8;
#[doc = "< Field is associated with a ConnectX card"]
pub const dcgm_field_entity_group_t_DCGM_FE_CONNECTX: dcgm_field_entity_group_t = 9;
#[doc = "< Number of elements in this enumeration. Keep this entry last"]
pub const dcgm_field_entity_group_t_DCGM_FE_COUNT: dcgm_field_entity_group_t = 10;
#[doc = " Enum of possible field entity groups"]
pub type dcgm_field_entity_group_t = ::std::os::raw::c_uint;
#[doc = " Represents an identifier for an entity within a field entity. For instance, this is the gpuId for DCGM_FE_GPU."]
pub type dcgm_field_eid_t = ::std::os::raw::c_uint;
#[doc = " Structure for formating the output for dmon.\n Used as a member in dcgm_field_meta_p"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgm_field_output_format_t {
    #[doc = "< Short name corresponding to field. This short name is used to identify columns in dmon\noutput."]
    pub shortName: [::std::os::raw::c_char; 10usize],
    #[doc = "< The unit of value. Eg: C(elsius), W(att), MB/s"]
    pub unit: [::std::os::raw::c_char; 4usize],
    #[doc = "< Maximum width/number of digits that a value for field can have."]
    pub width: ::std::os::raw::c_short,
}
#[doc = " Structure for formating the output for dmon.\n Used as a member in dcgm_field_meta_p"]
pub type dcgm_field_output_format_p = *mut dcgm_field_output_format_t;
#[doc = " Structure to store meta data for the field"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgm_field_meta_t {
    #[doc = "< Field identifier. DCGM_FI_? #define"]
    pub fieldId: ::std::os::raw::c_ushort,
    #[doc = "< Field type. DCGM_FT_? #define"]
    pub fieldType: ::std::os::raw::c_char,
    #[doc = "< field size in bytes (raw value size). 0=variable (like DCGM_FT_STRING)"]
    pub size: ::std::os::raw::c_uchar,
    #[doc = "< Tag for this field for serialization like 'device_temperature'"]
    pub tag: [::std::os::raw::c_char; 48usize],
    #[doc = "< Field scope. DCGM_FS_? #define of this field's association"]
    pub scope: ::std::os::raw::c_int,
    #[doc = "< Optional NVML field this DCGM field maps to. 0 = no mapping.\nOtherwise, this should be a NVML_FI_? #define from nvml.h"]
    pub nvmlFieldId: ::std::os::raw::c_int,
    #[doc = "< Field entity level. DCGM_FE_? specifying at what level the field is queryable"]
    pub entityLevel: dcgm_field_entity_group_t,
    #[doc = "< pointer to the structure that holds the formatting the\nvalues for fields"]
    pub valueFormat: dcgm_field_output_format_p,
}
pub type dcgm_field_meta_p = *const dcgm_field_meta_t;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vgpu_instances {
    pub num_instances: u32,
    pub vgpu_instance_ids: [u32; 32usize],
}
pub type dcgmVgpuInstanceIds_t = vgpu_instances;
pub const dcgmOperationMode_enum_DCGM_OPERATION_MODE_AUTO: dcgmOperationMode_enum = 1;
pub const dcgmOperationMode_enum_DCGM_OPERATION_MODE_MANUAL: dcgmOperationMode_enum = 2;
#[doc = " Operation mode for DCGM\n\n DCGM can run in auto-mode where it runs additional threads in the background to collect\n any metrics of interest and auto manages any operations needed for policy management.\n\n DCGM can also operate in manual-mode where it's execution is controlled by the user. In\n this mode, the user has to periodically call APIs such as \\ref dcgmPolicyTrigger and\n \\ref dcgmUpdateAllFields which tells DCGM to wake up and perform data collection and\n operations needed for policy management."]
pub type dcgmOperationMode_enum = ::std::os::raw::c_uint;
#[doc = " Operation mode for DCGM\n\n DCGM can run in auto-mode where it runs additional threads in the background to collect\n any metrics of interest and auto manages any operations needed for policy management.\n\n DCGM can also operate in manual-mode where it's execution is controlled by the user. In\n this mode, the user has to periodically call APIs such as \\ref dcgmPolicyTrigger and\n \\ref dcgmUpdateAllFields which tells DCGM to wake up and perform data collection and\n operations needed for policy management."]
pub use self::dcgmOperationMode_enum as dcgmOperationMode_t;
#[doc = "!< Data with earliest (lowest) timestamps returned first"]
pub const dcgmOrder_enum_DCGM_ORDER_ASCENDING: dcgmOrder_enum = 1;
#[doc = "!< Data with latest (highest) timestamps returned first"]
pub const dcgmOrder_enum_DCGM_ORDER_DESCENDING: dcgmOrder_enum = 2;
#[doc = " When more than one value is returned from a query, which order should it be returned in?"]
pub type dcgmOrder_enum = ::std::os::raw::c_uint;
#[doc = " When more than one value is returned from a query, which order should it be returned in?"]
pub use self::dcgmOrder_enum as dcgmOrder_t;
#[doc = "!< Success"]
pub const dcgmReturn_enum_DCGM_ST_OK: dcgmReturn_enum = 0;
#[doc = "!< A bad parameter was passed to a function"]
pub const dcgmReturn_enum_DCGM_ST_BADPARAM: dcgmReturn_enum = -1;
#[doc = "!< A generic, unspecified error"]
pub const dcgmReturn_enum_DCGM_ST_GENERIC_ERROR: dcgmReturn_enum = -3;
#[doc = "!< An out of memory error occurred"]
pub const dcgmReturn_enum_DCGM_ST_MEMORY: dcgmReturn_enum = -4;
#[doc = "!< Setting not configured"]
pub const dcgmReturn_enum_DCGM_ST_NOT_CONFIGURED: dcgmReturn_enum = -5;
#[doc = "!< Feature not supported"]
pub const dcgmReturn_enum_DCGM_ST_NOT_SUPPORTED: dcgmReturn_enum = -6;
#[doc = "!< DCGM Init error"]
pub const dcgmReturn_enum_DCGM_ST_INIT_ERROR: dcgmReturn_enum = -7;
#[doc = "!< When NVML returns error"]
pub const dcgmReturn_enum_DCGM_ST_NVML_ERROR: dcgmReturn_enum = -8;
#[doc = "!< Object is in pending state of something else"]
pub const dcgmReturn_enum_DCGM_ST_PENDING: dcgmReturn_enum = -9;
#[doc = "!< Object is in undefined state"]
pub const dcgmReturn_enum_DCGM_ST_UNINITIALIZED: dcgmReturn_enum = -10;
#[doc = "!< Requested operation timed out"]
pub const dcgmReturn_enum_DCGM_ST_TIMEOUT: dcgmReturn_enum = -11;
#[doc = "!< Version mismatch between received and understood API"]
pub const dcgmReturn_enum_DCGM_ST_VER_MISMATCH: dcgmReturn_enum = -12;
#[doc = "!< Unknown field id"]
pub const dcgmReturn_enum_DCGM_ST_UNKNOWN_FIELD: dcgmReturn_enum = -13;
#[doc = "!< No data is available"]
pub const dcgmReturn_enum_DCGM_ST_NO_DATA: dcgmReturn_enum = -14;
#[doc = "!< Data is considered stale"]
pub const dcgmReturn_enum_DCGM_ST_STALE_DATA: dcgmReturn_enum = -15;
#[doc = "!< The given field id is not being updated by the cache manager"]
pub const dcgmReturn_enum_DCGM_ST_NOT_WATCHED: dcgmReturn_enum = -16;
#[doc = "!< Do not have permission to perform the desired action"]
pub const dcgmReturn_enum_DCGM_ST_NO_PERMISSION: dcgmReturn_enum = -17;
#[doc = "!< GPU is no longer reachable"]
pub const dcgmReturn_enum_DCGM_ST_GPU_IS_LOST: dcgmReturn_enum = -18;
#[doc = "!< GPU requires a reset"]
pub const dcgmReturn_enum_DCGM_ST_RESET_REQUIRED: dcgmReturn_enum = -19;
#[doc = "!< The function that was requested was not found (bindings only error)"]
pub const dcgmReturn_enum_DCGM_ST_FUNCTION_NOT_FOUND: dcgmReturn_enum = -20;
#[doc = "!< The connection to the host engine is not valid any longer"]
pub const dcgmReturn_enum_DCGM_ST_CONNECTION_NOT_VALID: dcgmReturn_enum = -21;
#[doc = "!< This GPU is not supported by DCGM"]
pub const dcgmReturn_enum_DCGM_ST_GPU_NOT_SUPPORTED: dcgmReturn_enum = -22;
#[doc = "!< The GPUs of the provided group are not compatible with each other for the\n!< requested operation"]
pub const dcgmReturn_enum_DCGM_ST_GROUP_INCOMPATIBLE: dcgmReturn_enum = -23;
#[doc = "!< Max limit reached for the object"]
pub const dcgmReturn_enum_DCGM_ST_MAX_LIMIT: dcgmReturn_enum = -24;
#[doc = "!< DCGM library could not be found"]
pub const dcgmReturn_enum_DCGM_ST_LIBRARY_NOT_FOUND: dcgmReturn_enum = -25;
#[doc = "!< Duplicate key passed to a function"]
pub const dcgmReturn_enum_DCGM_ST_DUPLICATE_KEY: dcgmReturn_enum = -26;
#[doc = "!< GPU is already a part of a sync boost group"]
pub const dcgmReturn_enum_DCGM_ST_GPU_IN_SYNC_BOOST_GROUP: dcgmReturn_enum = -27;
#[doc = "!< GPU is not a part of a sync boost group"]
pub const dcgmReturn_enum_DCGM_ST_GPU_NOT_IN_SYNC_BOOST_GROUP: dcgmReturn_enum = -28;
#[doc = "!< This operation cannot be performed when the host engine is running as non-root"]
pub const dcgmReturn_enum_DCGM_ST_REQUIRES_ROOT: dcgmReturn_enum = -29;
#[doc = "!< DCGM GPU Diagnostic was successfully executed, but reported an error."]
pub const dcgmReturn_enum_DCGM_ST_NVVS_ERROR: dcgmReturn_enum = -30;
#[doc = "!< An input argument is not large enough"]
pub const dcgmReturn_enum_DCGM_ST_INSUFFICIENT_SIZE: dcgmReturn_enum = -31;
#[doc = "!< The given field ID is not supported by the API being called"]
pub const dcgmReturn_enum_DCGM_ST_FIELD_UNSUPPORTED_BY_API: dcgmReturn_enum = -32;
#[doc = "!< This request is serviced by a module of DCGM that is not currently loaded"]
pub const dcgmReturn_enum_DCGM_ST_MODULE_NOT_LOADED: dcgmReturn_enum = -33;
#[doc = "!< The requested operation could not be completed because the affected\n!< resource is in use"]
pub const dcgmReturn_enum_DCGM_ST_IN_USE: dcgmReturn_enum = -34;
#[doc = "!< This group is empty and the requested operation is not valid on an empty group"]
pub const dcgmReturn_enum_DCGM_ST_GROUP_IS_EMPTY: dcgmReturn_enum = -35;
#[doc = "!< Profiling is not supported for this group of GPUs or GPU."]
pub const dcgmReturn_enum_DCGM_ST_PROFILING_NOT_SUPPORTED: dcgmReturn_enum = -36;
#[doc = "!< The third-party Profiling module returned an unrecoverable error."]
pub const dcgmReturn_enum_DCGM_ST_PROFILING_LIBRARY_ERROR: dcgmReturn_enum = -37;
#[doc = "!< The requested profiling metrics cannot be collected in a single pass"]
pub const dcgmReturn_enum_DCGM_ST_PROFILING_MULTI_PASS: dcgmReturn_enum = -38;
#[doc = "!< A diag instance is already running, cannot run a new diag until\n!< the current one finishes."]
pub const dcgmReturn_enum_DCGM_ST_DIAG_ALREADY_RUNNING: dcgmReturn_enum = -39;
#[doc = "!< The DCGM GPU Diagnostic returned JSON that cannot be parsed"]
pub const dcgmReturn_enum_DCGM_ST_DIAG_BAD_JSON: dcgmReturn_enum = -40;
#[doc = "!< Error while launching the DCGM GPU Diagnostic"]
pub const dcgmReturn_enum_DCGM_ST_DIAG_BAD_LAUNCH: dcgmReturn_enum = -41;
#[doc = "!< Unused"]
pub const dcgmReturn_enum_DCGM_ST_DIAG_UNUSED: dcgmReturn_enum = -42;
#[doc = "!< A field value met or exceeded the error threshold."]
pub const dcgmReturn_enum_DCGM_ST_DIAG_THRESHOLD_EXCEEDED: dcgmReturn_enum = -43;
#[doc = "!< The installed driver version is insufficient for this API"]
pub const dcgmReturn_enum_DCGM_ST_INSUFFICIENT_DRIVER_VERSION: dcgmReturn_enum = -44;
#[doc = "!< The specified GPU instance does not exist"]
pub const dcgmReturn_enum_DCGM_ST_INSTANCE_NOT_FOUND: dcgmReturn_enum = -45;
#[doc = "!< The specified GPU compute instance does not exist"]
pub const dcgmReturn_enum_DCGM_ST_COMPUTE_INSTANCE_NOT_FOUND: dcgmReturn_enum = -46;
#[doc = "!< Couldn't kill a child process within the retries"]
pub const dcgmReturn_enum_DCGM_ST_CHILD_NOT_KILLED: dcgmReturn_enum = -47;
#[doc = "!< Detected an error in a 3rd-party library"]
pub const dcgmReturn_enum_DCGM_ST_3RD_PARTY_LIBRARY_ERROR: dcgmReturn_enum = -48;
#[doc = "!< Not enough resources available"]
pub const dcgmReturn_enum_DCGM_ST_INSUFFICIENT_RESOURCES: dcgmReturn_enum = -49;
#[doc = "!< Exception thrown from a diagnostic plugin"]
pub const dcgmReturn_enum_DCGM_ST_PLUGIN_EXCEPTION: dcgmReturn_enum = -50;
#[doc = "!< The diagnostic returned an error that indicates the need for isolation"]
pub const dcgmReturn_enum_DCGM_ST_NVVS_ISOLATE_ERROR: dcgmReturn_enum = -51;
#[doc = "!< The NVVS binary was not found in the specified location"]
pub const dcgmReturn_enum_DCGM_ST_NVVS_BINARY_NOT_FOUND: dcgmReturn_enum = -52;
#[doc = "!< The NVVS process was killed by a signal"]
pub const dcgmReturn_enum_DCGM_ST_NVVS_KILLED: dcgmReturn_enum = -53;
#[doc = "!< The hostengine and all modules are paused"]
pub const dcgmReturn_enum_DCGM_ST_PAUSED: dcgmReturn_enum = -54;
#[doc = "!< The object is already initialized"]
pub const dcgmReturn_enum_DCGM_ST_ALREADY_INITIALIZED: dcgmReturn_enum = -55;
#[doc = "!< Cannot perform operation because NVML isn't loaded"]
pub const dcgmReturn_enum_DCGM_ST_NVML_NOT_LOADED: dcgmReturn_enum = -56;
#[doc = "!< Cannot perform operation because an NVML driver timeout error was detected"]
pub const dcgmReturn_enum_DCGM_ST_NVML_DRIVER_TIMEOUT: dcgmReturn_enum = -57;
#[doc = "!< The NVVS returns no available tests (NVVS_ST_TEST_NOT_FOUND)"]
pub const dcgmReturn_enum_DCGM_ST_NVVS_NO_AVAILABLE_TEST: dcgmReturn_enum = -58;
#[doc = " Return values for DCGM API calls."]
pub type dcgmReturn_enum = ::std::os::raw::c_int;
#[doc = " Return values for DCGM API calls."]
pub use self::dcgmReturn_enum as dcgmReturn_t;
#[doc = "!< All the GPUs on the node are added to the group"]
pub const dcgmGroupType_enum_DCGM_GROUP_DEFAULT: dcgmGroupType_enum = 0;
#[doc = "!< Creates an empty group"]
pub const dcgmGroupType_enum_DCGM_GROUP_EMPTY: dcgmGroupType_enum = 1;
#[doc = "!< All NvSwitches of the node are added to the group"]
pub const dcgmGroupType_enum_DCGM_GROUP_DEFAULT_NVSWITCHES: dcgmGroupType_enum = 2;
#[doc = "!< All GPU instances of the node are added to the group"]
pub const dcgmGroupType_enum_DCGM_GROUP_DEFAULT_INSTANCES: dcgmGroupType_enum = 3;
#[doc = "!< All compute instances of the node are added to the group"]
pub const dcgmGroupType_enum_DCGM_GROUP_DEFAULT_COMPUTE_INSTANCES: dcgmGroupType_enum = 4;
#[doc = "!< All entities are added to this default group"]
pub const dcgmGroupType_enum_DCGM_GROUP_DEFAULT_EVERYTHING: dcgmGroupType_enum = 5;
#[doc = " Type of GPU groups"]
pub type dcgmGroupType_enum = ::std::os::raw::c_uint;
#[doc = " Type of GPU groups"]
pub use self::dcgmGroupType_enum as dcgmGroupType_t;
#[doc = "!< All GPUs older than Kepler"]
pub const dcgmChipArchitecture_enum_DCGM_CHIP_ARCH_OLDER: dcgmChipArchitecture_enum = 1;
#[doc = "!< All Kepler-architecture parts"]
pub const dcgmChipArchitecture_enum_DCGM_CHIP_ARCH_KEPLER: dcgmChipArchitecture_enum = 2;
#[doc = "!< All Maxwell-architecture parts"]
pub const dcgmChipArchitecture_enum_DCGM_CHIP_ARCH_MAXWELL: dcgmChipArchitecture_enum = 3;
#[doc = "!< All Pascal-architecture parts"]
pub const dcgmChipArchitecture_enum_DCGM_CHIP_ARCH_PASCAL: dcgmChipArchitecture_enum = 4;
#[doc = "!< All Volta-architecture parts"]
pub const dcgmChipArchitecture_enum_DCGM_CHIP_ARCH_VOLTA: dcgmChipArchitecture_enum = 5;
#[doc = "!< All Turing-architecture parts"]
pub const dcgmChipArchitecture_enum_DCGM_CHIP_ARCH_TURING: dcgmChipArchitecture_enum = 6;
#[doc = "!< All Ampere-architecture parts"]
pub const dcgmChipArchitecture_enum_DCGM_CHIP_ARCH_AMPERE: dcgmChipArchitecture_enum = 7;
#[doc = "!< All Ada-architecture parts"]
pub const dcgmChipArchitecture_enum_DCGM_CHIP_ARCH_ADA: dcgmChipArchitecture_enum = 8;
#[doc = "!< All Hopper-architecture parts"]
pub const dcgmChipArchitecture_enum_DCGM_CHIP_ARCH_HOPPER: dcgmChipArchitecture_enum = 9;
#[doc = "!< All Blackwell-architecture parts"]
pub const dcgmChipArchitecture_enum_DCGM_CHIP_ARCH_BLACKWELL: dcgmChipArchitecture_enum = 10;
#[doc = "!< Keep this 2nd to last, exclude unknown"]
pub const dcgmChipArchitecture_enum_DCGM_CHIP_ARCH_COUNT: dcgmChipArchitecture_enum = 10;
#[doc = "!< Anything else, presumably something newer"]
pub const dcgmChipArchitecture_enum_DCGM_CHIP_ARCH_UNKNOWN: dcgmChipArchitecture_enum = 4294967295;
#[doc = " Simplified chip architecture. Note that these are made to match nvmlChipArchitecture_t and thus\n do not start at 0."]
pub type dcgmChipArchitecture_enum = ::std::os::raw::c_uint;
#[doc = " Simplified chip architecture. Note that these are made to match nvmlChipArchitecture_t and thus\n do not start at 0."]
pub use self::dcgmChipArchitecture_enum as dcgmChipArchitecture_t;
#[doc = "!< The target configuration values to be applied"]
pub const dcgmConfigType_enum_DCGM_CONFIG_TARGET_STATE: dcgmConfigType_enum = 0;
#[doc = "!< The current configuration state"]
pub const dcgmConfigType_enum_DCGM_CONFIG_CURRENT_STATE: dcgmConfigType_enum = 1;
#[doc = " Represents the type of configuration to be fetched from the GPUs"]
pub type dcgmConfigType_enum = ::std::os::raw::c_uint;
#[doc = " Represents the type of configuration to be fetched from the GPUs"]
pub use self::dcgmConfigType_enum as dcgmConfigType_t;
#[doc = "!< Represents the power cap to be applied for each member of the group"]
pub const dcgmConfigPowerLimitType_enum_DCGM_CONFIG_POWER_CAP_INDIVIDUAL:
    dcgmConfigPowerLimitType_enum = 0;
#[doc = "!< Represents the power budget for the entire group"]
pub const dcgmConfigPowerLimitType_enum_DCGM_CONFIG_POWER_BUDGET_GROUP:
    dcgmConfigPowerLimitType_enum = 1;
#[doc = " Represents the power cap for each member of the group."]
pub type dcgmConfigPowerLimitType_enum = ::std::os::raw::c_uint;
#[doc = " Represents the power cap for each member of the group."]
pub use self::dcgmConfigPowerLimitType_enum as dcgmConfigPowerLimitType_t;
#[doc = "/\n/** @defgroup dcgmStructs Structure definitions\n  @{\n/\n/"]
pub type dcgmHandle_t = usize;
pub type dcgmGpuGrp_t = usize;
pub type dcgmFieldGrp_t = usize;
pub type dcgmStatus_t = usize;
#[doc = "< Don't care/inherit from the environment"]
pub const DcgmLoggingSeverity_t_DcgmLoggingSeverityUnspecified: DcgmLoggingSeverity_t = -1;
#[doc = "< No logging"]
pub const DcgmLoggingSeverity_t_DcgmLoggingSeverityNone: DcgmLoggingSeverity_t = 0;
#[doc = "< Fatal Errors"]
pub const DcgmLoggingSeverity_t_DcgmLoggingSeverityFatal: DcgmLoggingSeverity_t = 1;
#[doc = "< Errors"]
pub const DcgmLoggingSeverity_t_DcgmLoggingSeverityError: DcgmLoggingSeverity_t = 2;
#[doc = "< Warnings"]
pub const DcgmLoggingSeverity_t_DcgmLoggingSeverityWarning: DcgmLoggingSeverity_t = 3;
#[doc = "< Informative"]
pub const DcgmLoggingSeverity_t_DcgmLoggingSeverityInfo: DcgmLoggingSeverity_t = 4;
#[doc = "< Debug information (will generate large logs)"]
pub const DcgmLoggingSeverity_t_DcgmLoggingSeverityDebug: DcgmLoggingSeverity_t = 5;
#[doc = "< Verbose debugging information"]
pub const DcgmLoggingSeverity_t_DcgmLoggingSeverityVerbose: DcgmLoggingSeverity_t = 6;
#[doc = " DCGM Logging Severities. These match up with plog severities defined in Severity.h\n Each level includes all of the levels above it. For instance, level 4 includes 3,2, and 1 as well"]
pub type DcgmLoggingSeverity_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dcgm_link_s {
    pub __bindgen_anon_1: dcgm_link_s__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union dcgm_link_s__bindgen_ty_1 {
    #[doc = "< Broken out Link identifier GPU/SW:[GPU|SW]:Index"]
    pub parsed: dcgm_link_s__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< Raw Link ID"]
    pub raw: dcgm_field_eid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dcgm_link_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub __bindgen_anon_1: dcgm_link_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dcgm_link_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl dcgm_link_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn gpuId(&self) -> dcgm_field_eid_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_gpuId(&mut self, val: dcgm_field_eid_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gpuId_raw(this: *const Self) -> dcgm_field_eid_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_gpuId_raw(this: *mut Self, val: dcgm_field_eid_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn switchId(&self) -> dcgm_field_eid_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_switchId(&mut self, val: dcgm_field_eid_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn switchId_raw(this: *const Self) -> dcgm_field_eid_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_switchId_raw(this: *mut Self, val: dcgm_field_eid_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        gpuId: dcgm_field_eid_t,
        switchId: dcgm_field_eid_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let gpuId: u32 = unsafe { ::std::mem::transmute(gpuId) };
            gpuId as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let switchId: u32 = unsafe { ::std::mem::transmute(switchId) };
            switchId as u64
        });
        __bindgen_bitfield_unit
    }
}
impl dcgm_link_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn type_(&self) -> dcgm_field_entity_group_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: dcgm_field_entity_group_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn type__raw(this: *const Self) -> dcgm_field_entity_group_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_type_raw(this: *mut Self, val: dcgm_field_entity_group_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn index(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_index(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn index_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                32u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_index_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                32u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: dcgm_field_entity_group_t,
        index: u32,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 32u8, {
            let index: u32 = unsafe { ::std::mem::transmute(index) };
            index as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type dcgm_link_t = dcgm_link_s;
#[doc = " Connection options for dcgmConnect_v2 (v1)\n\n NOTE: This version is deprecated. use dcgmConnectV2Params_v2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmConnectV2Params_v1 {
    #[doc = "< Version number. Use dcgmConnectV2Params_version"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "< Whether to persist DCGM state modified by this connection\nonce the connection is terminated. Normally, all field\nwatches created by a connection are removed once a\nconnection goes away.\n1 = do not clean up after this connection.\n0 = clean up after this connection"]
    pub persistAfterDisconnect: ::std::os::raw::c_uint,
}
#[doc = " Connection options for dcgmConnect_v2 (v2)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmConnectV2Params_v2 {
    #[doc = "< Version number. Use dcgmConnectV2Params_version"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "< Whether to persist DCGM state modified by this connection once the\nconnection is terminated. Normally, all field watches created by a\nconnection are removed once a connection goes away. 1 = do not clean up\nafter this connection. 0 = clean up after this connection"]
    pub persistAfterDisconnect: ::std::os::raw::c_uint,
    #[doc = "< When attempting to connect to the specified host engine, how long should\nwe wait in milliseconds before giving up"]
    pub timeoutMs: ::std::os::raw::c_uint,
    #[doc = "< Whether or not the passed-in address is a unix socket filename (1) or a\nTCP/IP address (0)"]
    pub addressIsUnixSocket: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmConnectV2Params_v2"]
pub type dcgmConnectV2Params_t = dcgmConnectV2Params_v2;
#[doc = " Typedef for \\ref dcgmHostengineHealth_v1"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmHostengineHealth_v1 {
    #[doc = "!< The version of this request"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< 0 to indicate healthy, or a code to indicate the error"]
    pub overallHealth: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmHostengineHealth_t"]
pub type dcgmHostengineHealth_t = dcgmHostengineHealth_v1;
#[doc = " Represents a entityGroupId + entityId pair to uniquely identify a given entityId inside a group of entities\n\n Added in DCGM 1.5.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmGroupEntityPair_t {
    #[doc = "!< Entity Group ID entity belongs to"]
    pub entityGroupId: dcgm_field_entity_group_t,
    #[doc = "!< Entity ID of the entity"]
    pub entityId: dcgm_field_eid_t,
}
#[doc = " Structure to store information for DCGM group\n\n Added in DCGM 1.5.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmGroupInfo_v2 {
    #[doc = "!< Version Number (use dcgmGroupInfo_version2)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< count of entityIds returned in \\a entityList"]
    pub count: ::std::os::raw::c_uint,
    #[doc = "!< Group Name"]
    pub groupName: [::std::os::raw::c_char; 256usize],
    #[doc = "!< List of the entities that are in this group"]
    pub entityList: [dcgmGroupEntityPair_t; 64usize],
}
#[doc = " Structure to store information for DCGM group\n\n Added in DCGM 1.5.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmGroupInfo_v3 {
    #[doc = "!< Version Number (use dcgmGroupInfo_version3)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< count of entityIds returned in \\a entityList"]
    pub count: ::std::os::raw::c_uint,
    #[doc = "!< Group Name"]
    pub groupName: [::std::os::raw::c_char; 256usize],
    #[doc = "!< List of the entities that are in this group"]
    pub entityList: [dcgmGroupEntityPair_t; 1024usize],
}
#[doc = " Typedef for \\ref dcgmGroupInfo_v3"]
pub type dcgmGroupInfo_t = dcgmGroupInfo_v3;
#[doc = "< No profile (for GPUs)"]
pub const dcgmMigProfile_t_DcgmMigProfileNone: dcgmMigProfile_t = 0;
#[doc = "< GPU instance slice 1"]
pub const dcgmMigProfile_t_DcgmMigProfileGpuInstanceSlice1: dcgmMigProfile_t = 1;
#[doc = "< GPU instance slice 2"]
pub const dcgmMigProfile_t_DcgmMigProfileGpuInstanceSlice2: dcgmMigProfile_t = 2;
#[doc = "< GPU instance slice 3"]
pub const dcgmMigProfile_t_DcgmMigProfileGpuInstanceSlice3: dcgmMigProfile_t = 3;
#[doc = "< GPU instance slice 4"]
pub const dcgmMigProfile_t_DcgmMigProfileGpuInstanceSlice4: dcgmMigProfile_t = 4;
#[doc = "< GPU instance slice 7"]
pub const dcgmMigProfile_t_DcgmMigProfileGpuInstanceSlice7: dcgmMigProfile_t = 5;
#[doc = "< GPU instance slice 8"]
pub const dcgmMigProfile_t_DcgmMigProfileGpuInstanceSlice8: dcgmMigProfile_t = 6;
#[doc = "< GPU instance slice 6"]
pub const dcgmMigProfile_t_DcgmMigProfileGpuInstanceSlice6: dcgmMigProfile_t = 7;
#[doc = "< GPU instance slice 1 revision 1"]
pub const dcgmMigProfile_t_DcgmMigProfileGpuInstanceSlice1Rev1: dcgmMigProfile_t = 8;
#[doc = "< GPU instance slice 2 revision 1"]
pub const dcgmMigProfile_t_DcgmMigProfileGpuInstanceSlice2Rev1: dcgmMigProfile_t = 9;
#[doc = "< GPU instance slice 1 revision 2"]
pub const dcgmMigProfile_t_DcgmMigProfileGpuInstanceSlice1Rev2: dcgmMigProfile_t = 10;
#[doc = "< GPU instance slice 1 GFX"]
pub const dcgmMigProfile_t_DcgmMigProfileGpuInstanceSlice1GFX: dcgmMigProfile_t = 11;
#[doc = "< GPU instance slice 2 GFX"]
pub const dcgmMigProfile_t_DcgmMigProfileGpuInstanceSlice2GFX: dcgmMigProfile_t = 12;
#[doc = "< GPU instance slice 4 GFX"]
pub const dcgmMigProfile_t_DcgmMigProfileGpuInstanceSlice4GFX: dcgmMigProfile_t = 13;
#[doc = "< compute instance slice 1"]
pub const dcgmMigProfile_t_DcgmMigProfileComputeInstanceSlice1: dcgmMigProfile_t = 30;
#[doc = "< compute instance slice 2"]
pub const dcgmMigProfile_t_DcgmMigProfileComputeInstanceSlice2: dcgmMigProfile_t = 31;
#[doc = "< compute instance slice 3"]
pub const dcgmMigProfile_t_DcgmMigProfileComputeInstanceSlice3: dcgmMigProfile_t = 32;
#[doc = "< compute instance slice 4"]
pub const dcgmMigProfile_t_DcgmMigProfileComputeInstanceSlice4: dcgmMigProfile_t = 33;
#[doc = "< compute instance slice 7"]
pub const dcgmMigProfile_t_DcgmMigProfileComputeInstanceSlice7: dcgmMigProfile_t = 34;
#[doc = "< compute instance slice 8"]
pub const dcgmMigProfile_t_DcgmMigProfileComputeInstanceSlice8: dcgmMigProfile_t = 35;
#[doc = "< compute instance slice 6"]
pub const dcgmMigProfile_t_DcgmMigProfileComputeInstanceSlice6: dcgmMigProfile_t = 36;
#[doc = "< compute instance slice 1 revision 1"]
pub const dcgmMigProfile_t_DcgmMigProfileComputeInstanceSlice1Rev1: dcgmMigProfile_t = 37;
#[doc = " Enum for the different kinds of MIG profiles"]
pub type dcgmMigProfile_t = ::std::os::raw::c_uint;
#[doc = " Represents a pair of entity pairings to uniquely identify an entity and its place in the hierarchy."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmMigHierarchyInfo_t {
    #[doc = "!< Entity id and type for the entity in question"]
    pub entity: dcgmGroupEntityPair_t,
    #[doc = "!< Entity id and type for the parent of the entity in question"]
    pub parent: dcgmGroupEntityPair_t,
    #[doc = "!< Entity MIG profile identifier"]
    pub sliceProfile: dcgmMigProfile_t,
}
#[doc = " Provides additional information about location of MIG entities."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmMigEntityInfo_t {
    #[doc = "< GPU UUID"]
    pub gpuUuid: [::std::os::raw::c_char; 128usize],
    #[doc = "< GPU index from NVML"]
    pub nvmlGpuIndex: ::std::os::raw::c_uint,
    #[doc = "< GPU instance index within GPU. 0 to N. -1 for GPU entities"]
    pub nvmlInstanceId: ::std::os::raw::c_uint,
    #[doc = "< GPU Compute instance index within GPU instance. 0 to N. -1 for GPU\n      Instance and GPU entities"]
    pub nvmlComputeInstanceId: ::std::os::raw::c_uint,
    #[doc = "< Unique profile ID for GPU or Compute instances. -1 GPU entities\n      \\see nvmlComputeInstanceProfileInfo_st\n      \\see nvmlGpuInstanceProfileInfo_st"]
    pub nvmlMigProfileId: ::std::os::raw::c_uint,
    #[doc = "< Number of slices in the MIG profile"]
    pub nvmlProfileSlices: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmMigHierarchyInfo_v2 {
    pub entity: dcgmGroupEntityPair_t,
    pub parent: dcgmGroupEntityPair_t,
    pub info: dcgmMigEntityInfo_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmMigHierarchy_v2 {
    pub version: ::std::os::raw::c_uint,
    pub count: ::std::os::raw::c_uint,
    pub entityList: [dcgmMigHierarchyInfo_v2; 448usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmCpuHierarchyOwnedCores_v1 {
    pub version: ::std::os::raw::c_uint,
    pub bitmask: [u64; 16usize],
}
pub type dcgmCpuHierarchyOwnedCores_t = dcgmCpuHierarchyOwnedCores_v1;
#[doc = " Hierarchy of CPUs and their cores"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmCpuHierarchy_v1 {
    pub version: ::std::os::raw::c_uint,
    pub numCpus: ::std::os::raw::c_uint,
    pub cpus: [dcgmCpuHierarchy_v1_dcgmCpuHierarchyCpu_v1; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmCpuHierarchy_v1_dcgmCpuHierarchyCpu_v1 {
    pub cpuId: ::std::os::raw::c_uint,
    pub ownedCores: dcgmCpuHierarchyOwnedCores_v1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmCpuHierarchy_v2 {
    pub version: ::std::os::raw::c_uint,
    pub numCpus: ::std::os::raw::c_uint,
    pub cpus: [dcgmCpuHierarchy_v2_dcgmCpuHierarchyCpu_v2; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmCpuHierarchy_v2_dcgmCpuHierarchyCpu_v2 {
    pub cpuId: ::std::os::raw::c_uint,
    pub ownedCores: dcgmCpuHierarchyOwnedCores_v1,
    pub serial: [::std::os::raw::c_char; 256usize],
}
pub type dcgmCpuHierarchy_t = dcgmCpuHierarchy_v2;
#[doc = " Structure to represent information about a field group"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmFieldGroupInfo_v1 {
    #[doc = "!< Version number (dcgmFieldGroupInfo_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Number of entries in fieldIds[] that are valid"]
    pub numFieldIds: ::std::os::raw::c_uint,
    #[doc = "!< ID of this field group"]
    pub fieldGroupId: dcgmFieldGrp_t,
    #[doc = "!< Field Group Name"]
    pub fieldGroupName: [::std::os::raw::c_char; 256usize],
    #[doc = "!< Field ids that belong to this group"]
    pub fieldIds: [::std::os::raw::c_ushort; 128usize],
}
#[doc = " Structure to represent information about a field group"]
pub type dcgmFieldGroupInfo_t = dcgmFieldGroupInfo_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmAllFieldGroup_v1 {
    #[doc = "!< Version number (dcgmAllFieldGroupInfo_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Number of entries in fieldGroups[] that are populated"]
    pub numFieldGroups: ::std::os::raw::c_uint,
    #[doc = "!< Info about each field group"]
    pub fieldGroups: [dcgmFieldGroupInfo_t; 64usize],
}
pub type dcgmAllFieldGroup_t = dcgmAllFieldGroup_v1;
#[doc = " Structure to represent error attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmErrorInfo_t {
    #[doc = "!< Represents GPU ID"]
    pub gpuId: ::std::os::raw::c_uint,
    #[doc = "!< One of DCGM_FI_?"]
    pub fieldId: ::std::os::raw::c_short,
    #[doc = "!< One of DCGM_ST_?"]
    pub status: ::std::os::raw::c_int,
}
#[doc = " Represents a set of memory, SM, and video clocks for a device. This can be current values or a target values\n based on context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmClockSet_v1 {
    #[doc = "!< Version Number (dcgmClockSet_version)"]
    pub version: ::std::os::raw::c_int,
    #[doc = "!< Memory Clock (Memory Clock value OR DCGM_INT32_BLANK to Ignore/Use compatible\n!< value with smClk)"]
    pub memClock: ::std::os::raw::c_uint,
    #[doc = "!< SM Clock (SM Clock value OR DCGM_INT32_BLANK to Ignore/Use compatible value with memClk)"]
    pub smClock: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmClockSet_v1"]
pub type dcgmClockSet_t = dcgmClockSet_v1;
#[doc = " Represents list of supported clock sets for a device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceSupportedClockSets_v1 {
    #[doc = "!< Version Number (dcgmDeviceSupportedClockSets_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Number of supported clocks"]
    pub count: ::std::os::raw::c_uint,
    #[doc = "!< Valid clock sets for the device. Upto \\ref count entries are filled"]
    pub clockSet: [dcgmClockSet_t; 256usize],
}
#[doc = " Typedef for \\ref dcgmDeviceSupportedClockSets_v1"]
pub type dcgmDeviceSupportedClockSets_t = dcgmDeviceSupportedClockSets_v1;
#[doc = " Represents accounting data for one process"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDevicePidAccountingStats_v1 {
    #[doc = "!< Version Number. Should match dcgmDevicePidAccountingStats_version"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Process id of the process these stats are for"]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< Percent of time over the process's lifetime during which one or more kernels\n!< was executing on the GPU.\n!< Set to DCGM_INT32_NOT_SUPPORTED if is not supported"]
    pub gpuUtilization: ::std::os::raw::c_uint,
    #[doc = "!< Percent of time over the process's lifetime during which global (device)\n!< memory was being read or written.\n!< Set to DCGM_INT32_NOT_SUPPORTED if is not supported"]
    pub memoryUtilization: ::std::os::raw::c_uint,
    #[doc = "!< Maximum total memory in bytes that was ever allocated by the process.\n!< Set to DCGM_INT64_NOT_SUPPORTED if is not supported"]
    pub maxMemoryUsage: ::std::os::raw::c_ulonglong,
    #[doc = "!< CPU Timestamp in usec representing start time for the process"]
    pub startTimestamp: ::std::os::raw::c_ulonglong,
    #[doc = "!< Amount of time in usec during which the compute context was active.\n!< Note that this does not mean the context was being used. endTimestamp\n!< can be computed as startTimestamp + activeTime"]
    pub activeTimeUsec: ::std::os::raw::c_ulonglong,
}
#[doc = " Typedef for \\ref dcgmDevicePidAccountingStats_v1"]
pub type dcgmDevicePidAccountingStats_t = dcgmDevicePidAccountingStats_v1;
#[doc = " Represents thermal information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceThermals_v1 {
    #[doc = "!< Version Number"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Slowdown temperature"]
    pub slowdownTemp: ::std::os::raw::c_uint,
    #[doc = "!< Shutdown temperature"]
    pub shutdownTemp: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmDeviceThermals_v1"]
pub type dcgmDeviceThermals_t = dcgmDeviceThermals_v1;
#[doc = " Represents various power limits"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDevicePowerLimits_v1 {
    #[doc = "!< Version Number"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Power management limit associated with this device (in W)"]
    pub curPowerLimit: ::std::os::raw::c_uint,
    #[doc = "!< Power management limit effective at device boot (in W)"]
    pub defaultPowerLimit: ::std::os::raw::c_uint,
    #[doc = "!< Effective power limit that the driver enforces after taking into account\n!< all limiters (in W)"]
    pub enforcedPowerLimit: ::std::os::raw::c_uint,
    #[doc = "!< Minimum power management limit (in W)"]
    pub minPowerLimit: ::std::os::raw::c_uint,
    #[doc = "!< Maximum power management limit (in W)"]
    pub maxPowerLimit: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmDevicePowerLimits_v1"]
pub type dcgmDevicePowerLimits_t = dcgmDevicePowerLimits_v1;
#[doc = " Represents device identifiers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceIdentifiers_v1 {
    #[doc = "!< Version Number (dcgmDeviceIdentifiers_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Brand Name"]
    pub brandName: [::std::os::raw::c_char; 256usize],
    #[doc = "!< Name of the device"]
    pub deviceName: [::std::os::raw::c_char; 256usize],
    #[doc = "!< PCI Bus ID"]
    pub pciBusId: [::std::os::raw::c_char; 256usize],
    #[doc = "!< Serial for the device"]
    pub serial: [::std::os::raw::c_char; 256usize],
    #[doc = "!< UUID for the device"]
    pub uuid: [::std::os::raw::c_char; 256usize],
    #[doc = "!< VBIOS version"]
    pub vbios: [::std::os::raw::c_char; 256usize],
    #[doc = "!< Inforom Image version"]
    pub inforomImageVersion: [::std::os::raw::c_char; 256usize],
    #[doc = "!< The combined 16-bit device id and 16-bit vendor id"]
    pub pciDeviceId: ::std::os::raw::c_uint,
    #[doc = "!< The 32-bit Sub System Device ID"]
    pub pciSubSystemId: ::std::os::raw::c_uint,
    #[doc = "!< Driver Version"]
    pub driverVersion: [::std::os::raw::c_char; 256usize],
    #[doc = "!< Virtualization Mode"]
    pub virtualizationMode: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmDeviceIdentifiers_v1"]
pub type dcgmDeviceIdentifiers_t = dcgmDeviceIdentifiers_v1;
#[doc = " Represents device memory and usage"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceMemoryUsage_v1 {
    #[doc = "!< Version Number (dcgmDeviceMemoryUsage_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Total BAR1 size in megabytes"]
    pub bar1Total: ::std::os::raw::c_uint,
    #[doc = "!< Total framebuffer memory in megabytes"]
    pub fbTotal: ::std::os::raw::c_uint,
    #[doc = "!< Used framebuffer memory in megabytes"]
    pub fbUsed: ::std::os::raw::c_uint,
    #[doc = "!< Free framebuffer memory in megabytes"]
    pub fbFree: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmDeviceMemoryUsage_v1"]
pub type dcgmDeviceMemoryUsage_t = dcgmDeviceMemoryUsage_v1;
#[doc = " Represents utilization values for vGPUs running on the device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceVgpuUtilInfo_v1 {
    #[doc = "!< Version Number (dcgmDeviceVgpuUtilInfo_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< vGPU instance ID"]
    pub vgpuId: ::std::os::raw::c_uint,
    #[doc = "!< GPU utilization for vGPU"]
    pub smUtil: ::std::os::raw::c_uint,
    #[doc = "!< Memory utilization for vGPU"]
    pub memUtil: ::std::os::raw::c_uint,
    #[doc = "!< Encoder utilization for vGPU"]
    pub encUtil: ::std::os::raw::c_uint,
    #[doc = "!< Decoder utilization for vGPU"]
    pub decUtil: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmDeviceVgpuUtilInfo_v1"]
pub type dcgmDeviceVgpuUtilInfo_t = dcgmDeviceVgpuUtilInfo_v1;
#[doc = " Represents current encoder statistics for the given device/vGPU instance"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceEncStats_v1 {
    #[doc = "!< Version Number (dcgmDeviceEncStats_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Count of active encoder sessions"]
    pub sessionCount: ::std::os::raw::c_uint,
    #[doc = "!< Trailing average FPS of all active sessions"]
    pub averageFps: ::std::os::raw::c_uint,
    #[doc = "!< Encode latency in milliseconds"]
    pub averageLatency: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmDeviceEncStats_v1"]
pub type dcgmDeviceEncStats_t = dcgmDeviceEncStats_v1;
#[doc = " Represents current frame buffer capture sessions statistics for the given device/vGPU instance"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceFbcStats_v1 {
    #[doc = "!< Version Number (dcgmDeviceFbcStats_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Count of active FBC sessions"]
    pub sessionCount: ::std::os::raw::c_uint,
    #[doc = "!< Moving average new frames captured per second"]
    pub averageFps: ::std::os::raw::c_uint,
    #[doc = "!< Moving average new frame capture latency in microseconds"]
    pub averageLatency: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmDeviceFbcStats_v1"]
pub type dcgmDeviceFbcStats_t = dcgmDeviceFbcStats_v1;
#[doc = "!< Unknown"]
pub const dcgmFBCSessionType_enum_DCGM_FBC_SESSION_TYPE_UNKNOWN: dcgmFBCSessionType_enum = 0;
#[doc = "!< FB capture for a system buffer"]
pub const dcgmFBCSessionType_enum_DCGM_FBC_SESSION_TYPE_TOSYS: dcgmFBCSessionType_enum = 1;
#[doc = "!< FB capture for a cuda buffer"]
pub const dcgmFBCSessionType_enum_DCGM_FBC_SESSION_TYPE_CUDA: dcgmFBCSessionType_enum = 2;
#[doc = "!< FB capture for a Vid buffer"]
pub const dcgmFBCSessionType_enum_DCGM_FBC_SESSION_TYPE_VID: dcgmFBCSessionType_enum = 3;
#[doc = "!< FB capture for a NVENC HW buffer"]
pub const dcgmFBCSessionType_enum_DCGM_FBC_SESSION_TYPE_HWENC: dcgmFBCSessionType_enum = 4;
pub type dcgmFBCSessionType_enum = ::std::os::raw::c_uint;
pub use self::dcgmFBCSessionType_enum as dcgmFBCSessionType_t;
#[doc = " Represents information about active FBC session on the given device/vGPU instance"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceFbcSessionInfo_v1 {
    #[doc = "!< Version Number (dcgmDeviceFbcSessionInfo_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Unique session ID"]
    pub sessionId: ::std::os::raw::c_uint,
    #[doc = "!< Owning process ID"]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< vGPU instance ID (only valid on vGPU hosts, otherwise zero)"]
    pub vgpuId: ::std::os::raw::c_uint,
    #[doc = "!< Display identifier"]
    pub displayOrdinal: ::std::os::raw::c_uint,
    #[doc = "!< Type of frame buffer capture session"]
    pub sessionType: dcgmFBCSessionType_t,
    #[doc = "!< Session flags"]
    pub sessionFlags: ::std::os::raw::c_uint,
    #[doc = "!< Max horizontal resolution supported by the capture session"]
    pub hMaxResolution: ::std::os::raw::c_uint,
    #[doc = "!< Max vertical resolution supported by the capture session"]
    pub vMaxResolution: ::std::os::raw::c_uint,
    #[doc = "!< Horizontal resolution requested by caller in capture call"]
    pub hResolution: ::std::os::raw::c_uint,
    #[doc = "!< Vertical resolution requested by caller in capture call"]
    pub vResolution: ::std::os::raw::c_uint,
    #[doc = "!< Moving average new frames captured per second"]
    pub averageFps: ::std::os::raw::c_uint,
    #[doc = "!< Moving average new frame capture latency in microseconds"]
    pub averageLatency: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmDeviceFbcSessionInfo_v1"]
pub type dcgmDeviceFbcSessionInfo_t = dcgmDeviceFbcSessionInfo_v1;
#[doc = " Represents all the active FBC sessions on the given device/vGPU instance"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceFbcSessions_v1 {
    #[doc = "!< Version Number (dcgmDeviceFbcSessions_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Count of active FBC sessions"]
    pub sessionCount: ::std::os::raw::c_uint,
    #[doc = "!< Info about the active FBC session"]
    pub sessionInfo: [dcgmDeviceFbcSessionInfo_t; 256usize],
}
#[doc = " Typedef for \\ref dcgmDeviceFbcSessions_v1"]
pub type dcgmDeviceFbcSessions_t = dcgmDeviceFbcSessions_v1;
pub const dcgmEncoderQueryType_enum_DCGM_ENCODER_QUERY_H264: dcgmEncoderQueryType_enum = 0;
pub const dcgmEncoderQueryType_enum_DCGM_ENCODER_QUERY_HEVC: dcgmEncoderQueryType_enum = 1;
pub type dcgmEncoderQueryType_enum = ::std::os::raw::c_uint;
pub use self::dcgmEncoderQueryType_enum as dcgmEncoderType_t;
#[doc = " Represents information about active encoder sessions on the given vGPU instance"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dcgmDeviceVgpuEncSessions_v1 {
    #[doc = "!< Version Number (dcgmDeviceVgpuEncSessions_version)"]
    pub version: ::std::os::raw::c_uint,
    pub encoderSessionInfo: dcgmDeviceVgpuEncSessions_v1__bindgen_ty_1,
    #[doc = "!< Unique session ID"]
    pub sessionId: ::std::os::raw::c_uint,
    #[doc = "!< Process ID"]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< Video encoder type"]
    pub codecType: dcgmEncoderType_t,
    #[doc = "!< Current encode horizontal resolution"]
    pub hResolution: ::std::os::raw::c_uint,
    #[doc = "!< Current encode vertical resolution"]
    pub vResolution: ::std::os::raw::c_uint,
    #[doc = "!< Moving average encode frames per second"]
    pub averageFps: ::std::os::raw::c_uint,
    #[doc = "!< Moving average encode latency in milliseconds"]
    pub averageLatency: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dcgmDeviceVgpuEncSessions_v1__bindgen_ty_1 {
    #[doc = "!< vGPU instance ID"]
    pub vgpuId: ::std::os::raw::c_uint,
    pub sessionCount: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmDeviceVgpuEncSessions_v1"]
pub type dcgmDeviceVgpuEncSessions_t = dcgmDeviceVgpuEncSessions_v1;
#[doc = " Represents utilization values for processes running in vGPU VMs using the device"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dcgmDeviceVgpuProcessUtilInfo_v1 {
    #[doc = "!< Version Number (dcgmDeviceVgpuProcessUtilInfo_version)"]
    pub version: ::std::os::raw::c_uint,
    pub vgpuProcessUtilInfo: dcgmDeviceVgpuProcessUtilInfo_v1__bindgen_ty_1,
    #[doc = "!< Process ID of the process running in the vGPU VM."]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< Process Name of process running in the vGPU VM."]
    pub processName: [::std::os::raw::c_char; 64usize],
    #[doc = "!< GPU utilization of process running in the vGPU VM."]
    pub smUtil: ::std::os::raw::c_uint,
    #[doc = "!< Memory utilization of process running in the vGPU VM."]
    pub memUtil: ::std::os::raw::c_uint,
    #[doc = "!< Encoder utilization of process running in the vGPU VM."]
    pub encUtil: ::std::os::raw::c_uint,
    #[doc = "!< Decoder utilization of process running in the vGPU VM."]
    pub decUtil: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dcgmDeviceVgpuProcessUtilInfo_v1__bindgen_ty_1 {
    #[doc = "!< vGPU instance ID"]
    pub vgpuId: ::std::os::raw::c_uint,
    #[doc = "!< Count of processes running in the vGPU VM,for which utilization\n!< rates are being reported in this cycle."]
    pub vgpuProcessSamplesCount: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmDeviceVgpuProcessUtilInfo_v1"]
pub type dcgmDeviceVgpuProcessUtilInfo_t = dcgmDeviceVgpuProcessUtilInfo_v1;
#[doc = " Represents static info related to vGPUs supported on the device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dcgmDeviceVgpuTypeInfo_v1 {
    #[doc = "!< Version number (dcgmDeviceVgpuTypeInfo_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< vGPU type ID and Supported vGPU type count"]
    pub vgpuTypeInfo: dcgmDeviceVgpuTypeInfo_v1__bindgen_ty_1,
    #[doc = "!< vGPU type Name"]
    pub vgpuTypeName: [::std::os::raw::c_char; 64usize],
    #[doc = "!< Class of vGPU type"]
    pub vgpuTypeClass: [::std::os::raw::c_char; 64usize],
    #[doc = "!< license of vGPU type"]
    pub vgpuTypeLicense: [::std::os::raw::c_char; 128usize],
    #[doc = "!< device ID of vGPU type"]
    pub deviceId: ::std::os::raw::c_int,
    #[doc = "!< Subsystem ID of vGPU type"]
    pub subsystemId: ::std::os::raw::c_int,
    #[doc = "!< Count of vGPU's supported display heads"]
    pub numDisplayHeads: ::std::os::raw::c_int,
    #[doc = "!< maximum number of vGPU instances creatable on a device for given vGPU type"]
    pub maxInstances: ::std::os::raw::c_int,
    #[doc = "!< Frame rate limit value of the vGPU type"]
    pub frameRateLimit: ::std::os::raw::c_int,
    #[doc = "!< vGPU display head's maximum supported resolution in X dimension"]
    pub maxResolutionX: ::std::os::raw::c_int,
    #[doc = "!< vGPU display head's maximum supported resolution in Y dimension"]
    pub maxResolutionY: ::std::os::raw::c_int,
    #[doc = "!< vGPU Total framebuffer size in megabytes"]
    pub fbTotal: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dcgmDeviceVgpuTypeInfo_v1__bindgen_ty_1 {
    pub vgpuTypeId: ::std::os::raw::c_uint,
    pub supportedVgpuTypeCount: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dcgmDeviceVgpuTypeInfo_v2 {
    #[doc = "!< Version number (dcgmDeviceVgpuTypeInfo_version2)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< vGPU type ID and Supported vGPU type count"]
    pub vgpuTypeInfo: dcgmDeviceVgpuTypeInfo_v2__bindgen_ty_1,
    #[doc = "!< vGPU type Name"]
    pub vgpuTypeName: [::std::os::raw::c_char; 64usize],
    #[doc = "!< Class of vGPU type"]
    pub vgpuTypeClass: [::std::os::raw::c_char; 64usize],
    #[doc = "!< license of vGPU type"]
    pub vgpuTypeLicense: [::std::os::raw::c_char; 128usize],
    #[doc = "!< device ID of vGPU type"]
    pub deviceId: ::std::os::raw::c_int,
    #[doc = "!< Subsystem ID of vGPU type"]
    pub subsystemId: ::std::os::raw::c_int,
    #[doc = "!< Count of vGPU's supported display heads"]
    pub numDisplayHeads: ::std::os::raw::c_int,
    #[doc = "!< maximum number of vGPU instances creatable on a device for given vGPU type"]
    pub maxInstances: ::std::os::raw::c_int,
    #[doc = "!< Frame rate limit value of the vGPU type"]
    pub frameRateLimit: ::std::os::raw::c_int,
    #[doc = "!< vGPU display head's maximum supported resolution in X dimension"]
    pub maxResolutionX: ::std::os::raw::c_int,
    #[doc = "!< vGPU display head's maximum supported resolution in Y dimension"]
    pub maxResolutionY: ::std::os::raw::c_int,
    #[doc = "!< vGPU Total framebuffer size in megabytes"]
    pub fbTotal: ::std::os::raw::c_int,
    #[doc = "!< GPU Instance Profile ID for the given vGPU type"]
    pub gpuInstanceProfileId: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dcgmDeviceVgpuTypeInfo_v2__bindgen_ty_1 {
    pub vgpuTypeId: ::std::os::raw::c_uint,
    pub supportedVgpuTypeCount: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmDeviceVgpuTypeInfo_v2"]
pub type dcgmDeviceVgpuTypeInfo_t = dcgmDeviceVgpuTypeInfo_v2;
#[doc = " Represents the info related to vGPUs supported on the device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceSupportedVgpuTypeInfo_v1 {
    #[doc = "!< Version number (dcgmDeviceSupportedVgpuTypeInfo_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< device ID of vGPU type"]
    pub deviceId: ::std::os::raw::c_ulonglong,
    #[doc = "!< Subsystem ID of vGPU type"]
    pub subsystemId: ::std::os::raw::c_ulonglong,
    #[doc = "!< Count of vGPU's supported display heads"]
    pub numDisplayHeads: ::std::os::raw::c_uint,
    #[doc = "!< maximum number of vGPU instances creatable on a device for given vGPU type"]
    pub maxInstances: ::std::os::raw::c_uint,
    #[doc = "!< Frame rate limit value of the vGPU type"]
    pub frameRateLimit: ::std::os::raw::c_uint,
    #[doc = "!< vGPU display head's maximum supported resolution in X dimension"]
    pub maxResolutionX: ::std::os::raw::c_uint,
    #[doc = "!< vGPU display head's maximum supported resolution in Y dimension"]
    pub maxResolutionY: ::std::os::raw::c_uint,
    #[doc = "!< vGPU Total framebuffer size in megabytes"]
    pub fbTotal: ::std::os::raw::c_ulonglong,
    #[doc = "!< GPU Instance Profile ID for the given vGPU type"]
    pub gpuInstanceProfileId: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmDeviceSupportedVgpuTypeInfo_v1"]
pub type dcgmDeviceSupportedVgpuTypeInfo_t = dcgmDeviceSupportedVgpuTypeInfo_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceSettings_v2 {
    pub version: ::std::os::raw::c_uint,
    pub persistenceModeEnabled: ::std::os::raw::c_uint,
    pub migModeEnabled: ::std::os::raw::c_uint,
    pub confidentialComputeMode: ::std::os::raw::c_uint,
}
pub type dcgmDeviceSettings_t = dcgmDeviceSettings_v2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceAttributes_v3 {
    #[doc = "!< Version number (dcgmDeviceAttributes_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Supported clocks for the device"]
    pub clockSets: dcgmDeviceSupportedClockSets_t,
    #[doc = "!< Thermal settings for the device"]
    pub thermalSettings: dcgmDeviceThermals_t,
    #[doc = "!< Various power limits for the device"]
    pub powerLimits: dcgmDevicePowerLimits_t,
    #[doc = "!< Identifiers for the device"]
    pub identifiers: dcgmDeviceIdentifiers_t,
    #[doc = "!< Memory usage info for the device"]
    pub memoryUsage: dcgmDeviceMemoryUsage_t,
    #[doc = "!< Basic device settings"]
    pub settings: dcgmDeviceSettings_v2,
}
#[doc = " Typedef for \\ref dcgmDeviceAttributes_v3"]
pub type dcgmDeviceAttributes_t = dcgmDeviceAttributes_v3;
#[doc = " Structure to represent attributes info for a MIG device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceMigAttributesInfo_v1 {
    #[doc = "!< Version Number (dcgmDeviceMigAttributesInfo_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< GPU instance ID"]
    pub gpuInstanceId: ::std::os::raw::c_uint,
    #[doc = "!< Compute instance ID"]
    pub computeInstanceId: ::std::os::raw::c_uint,
    #[doc = "!< Streaming Multiprocessor count"]
    pub multiprocessorCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared Copy Engine count"]
    pub sharedCopyEngineCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared Decoder Engine count"]
    pub sharedDecoderCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared Encoder Engine count"]
    pub sharedEncoderCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared JPEG Engine count"]
    pub sharedJpegCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared OFA Engine count"]
    pub sharedOfaCount: ::std::os::raw::c_uint,
    #[doc = "!< GPU instance slice count"]
    pub gpuInstanceSliceCount: ::std::os::raw::c_uint,
    #[doc = "!< Compute instance slice count"]
    pub computeInstanceSliceCount: ::std::os::raw::c_uint,
    #[doc = "!< Device memory size (in MiB)"]
    pub memorySizeMB: ::std::os::raw::c_ulonglong,
}
#[doc = " Typedef for \\ref dcgmDeviceMigAttributesInfo_v1"]
pub type dcgmDeviceMigAttributesInfo_t = dcgmDeviceMigAttributesInfo_v1;
#[doc = " Structure to represent attributes for a MIG device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceMigAttributes_v1 {
    #[doc = "!< Version Number (dcgmDeviceMigAttributes_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Count of MIG devices"]
    pub migDevicesCount: ::std::os::raw::c_uint,
    #[doc = "!< MIG attributes information"]
    pub migAttributesInfo: dcgmDeviceMigAttributesInfo_v1,
}
#[doc = " Typedef for \\ref dcgmDeviceMigAttributes_v1"]
pub type dcgmDeviceMigAttributes_t = dcgmDeviceMigAttributes_v1;
#[doc = " Structure to represent GPU instance profile information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmGpuInstanceProfileInfo_v1 {
    #[doc = "!< Version Number (dcgmGpuInstanceProfileInfo_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Unique profile ID within the device"]
    pub id: ::std::os::raw::c_uint,
    #[doc = "!< Peer-to-Peer support"]
    pub isP2pSupported: ::std::os::raw::c_uint,
    #[doc = "!< GPU Slice count"]
    pub sliceCount: ::std::os::raw::c_uint,
    #[doc = "!< GPU instance count"]
    pub instanceCount: ::std::os::raw::c_uint,
    #[doc = "!< Streaming Multiprocessor count"]
    pub multiprocessorCount: ::std::os::raw::c_uint,
    #[doc = "!< Copy Engine count"]
    pub copyEngineCount: ::std::os::raw::c_uint,
    #[doc = "!< Decoder Engine count"]
    pub decoderCount: ::std::os::raw::c_uint,
    #[doc = "!< Encoder Engine count"]
    pub encoderCount: ::std::os::raw::c_uint,
    #[doc = "!< JPEG Engine count"]
    pub jpegCount: ::std::os::raw::c_uint,
    #[doc = "!< OFA Engine count"]
    pub ofaCount: ::std::os::raw::c_uint,
    #[doc = "!< Memory size in MBytes"]
    pub memorySizeMB: ::std::os::raw::c_ulonglong,
}
#[doc = " Typedef for \\ref dcgmGpuInstanceProfileInfo_v1"]
pub type dcgmGpuInstanceProfileInfo_t = dcgmGpuInstanceProfileInfo_v1;
#[doc = " Structure to represent GPU instance profiles"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmGpuInstanceProfiles_v1 {
    #[doc = "!< Version Number (dcgmGpuInstanceProfiles_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Profile count"]
    pub profileCount: ::std::os::raw::c_uint,
    #[doc = "!< GPU instance profile information"]
    pub profileInfo: dcgmGpuInstanceProfileInfo_v1,
}
#[doc = " Typedef for \\ref dcgmGpuInstanceProfiles_v1"]
pub type dcgmGpuInstanceProfiles_t = dcgmGpuInstanceProfiles_v1;
#[doc = " Structure to represent Compute instance profile information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmComputeInstanceProfileInfo_v1 {
    #[doc = "!< Version Number (dcgmComputeInstanceProfileInfo_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< GPU instance ID"]
    pub gpuInstanceId: ::std::os::raw::c_uint,
    #[doc = "!< Unique profile ID within the GPU instance"]
    pub id: ::std::os::raw::c_uint,
    #[doc = "!< GPU Slice count"]
    pub sliceCount: ::std::os::raw::c_uint,
    #[doc = "!< Compute instance count"]
    pub instanceCount: ::std::os::raw::c_uint,
    #[doc = "!< Streaming Multiprocessor count"]
    pub multiprocessorCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared Copy Engine count"]
    pub sharedCopyEngineCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared Decoder Engine count"]
    pub sharedDecoderCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared Encoder Engine count"]
    pub sharedEncoderCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared JPEG Engine count"]
    pub sharedJpegCount: ::std::os::raw::c_uint,
    #[doc = "!< Shared OFA Engine count"]
    pub sharedOfaCount: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmComputeInstanceProfileInfo_v1"]
pub type dcgmComputeInstanceProfileInfo_t = dcgmComputeInstanceProfileInfo_v1;
#[doc = " Structure to represent Compute instance profiles"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmComputeInstanceProfiles_v1 {
    #[doc = "!< Version Number (dcgmComputeInstanceProfiles_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Profile count"]
    pub profileCount: ::std::os::raw::c_uint,
    #[doc = "!< Compute instance profile information"]
    pub profileInfo: dcgmComputeInstanceProfileInfo_v1,
}
#[doc = " Typedef for \\ref dcgmComputeInstanceProfiles_v1"]
pub type dcgmComputeInstanceProfiles_t = dcgmComputeInstanceProfiles_v1;
pub const dcgmPowerProfileType_t_DCGM_POWER_PROFILE_MAX_P: dcgmPowerProfileType_t = 0;
pub const dcgmPowerProfileType_t_DCGM_POWER_PROFILE_MAX_Q: dcgmPowerProfileType_t = 1;
pub const dcgmPowerProfileType_t_DCGM_POWER_PROFILE_COMPUTE: dcgmPowerProfileType_t = 2;
pub const dcgmPowerProfileType_t_DCGM_POWER_PROFILE_MEMORY_BOUND: dcgmPowerProfileType_t = 3;
pub const dcgmPowerProfileType_t_DCGM_POWER_PROFILE_NETWORK: dcgmPowerProfileType_t = 4;
pub const dcgmPowerProfileType_t_DCGM_POWER_PROFILE_BALANCED: dcgmPowerProfileType_t = 5;
pub const dcgmPowerProfileType_t_DCGM_POWER_PROFILE_LLM_INFERENCE: dcgmPowerProfileType_t = 6;
pub const dcgmPowerProfileType_t_DCGM_POWER_PROFILE_LLM_TRAINING: dcgmPowerProfileType_t = 7;
pub const dcgmPowerProfileType_t_DCGM_POWER_PROFILE_RBM: dcgmPowerProfileType_t = 8;
pub const dcgmPowerProfileType_t_DCGM_POWER_PROFILE_DCPCIE: dcgmPowerProfileType_t = 9;
pub const dcgmPowerProfileType_t_DCGM_POWER_PROFILE_HMMA_SPARSE: dcgmPowerProfileType_t = 10;
pub const dcgmPowerProfileType_t_DCGM_POWER_PROFILE_HMMA_DENSE: dcgmPowerProfileType_t = 11;
pub const dcgmPowerProfileType_t_DCGM_POWER_PROFILE_SYNC_BALANCED: dcgmPowerProfileType_t = 12;
pub const dcgmPowerProfileType_t_DCGM_POWER_PROFILE_HPC: dcgmPowerProfileType_t = 13;
pub const dcgmPowerProfileType_t_DCGM_POWER_PROFILE_MIG: dcgmPowerProfileType_t = 14;
pub const dcgmPowerProfileType_t_DCGM_POWER_PROFILE_MAX: dcgmPowerProfileType_t = 15;
pub type dcgmPowerProfileType_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmWorkloadPowerProfileInfo_v1 {
    #[doc = "!< the API version number"]
    pub version: ::std::os::raw::c_uint,
    pub profileId: dcgmPowerProfileType_t,
    pub priority: ::std::os::raw::c_uint,
    pub conflictingMask: [::std::os::raw::c_uint; 8usize],
}
pub type dcgmWorkloadPowerProfileInfo_t = dcgmWorkloadPowerProfileInfo_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmWorkloadPowerProfileProfilesInfo_v1 {
    #[doc = "!< the API version number"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Array of workload power profile info parameters"]
    pub workloadPowerProfile: [dcgmWorkloadPowerProfileInfo_v1; 255usize],
    pub profileCount: ::std::os::raw::c_uint,
}
pub type dcgmWorkloadPowerProfileProfilesInfo_t = dcgmWorkloadPowerProfileProfilesInfo_v1;
#[doc = " Device workload profile information\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceWorkloadPowerProfilesStatus_v1 {
    #[doc = "!< the API version number"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Bitmask of valid workload power profiles"]
    pub profileMask: [::std::os::raw::c_uint; 8usize],
    pub requestedProfileMask: [::std::os::raw::c_uint; 8usize],
    pub enforcedProfileMask: [::std::os::raw::c_uint; 8usize],
}
#[doc = " Device workload profile information\n"]
pub type dcgmDeviceWorkloadPowerProfilesStatus_t = dcgmDeviceWorkloadPowerProfilesStatus_v1;
#[doc = " Used to represent Performance state settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmConfigPerfStateSettings_t {
    #[doc = "!< Sync Boost Mode (0: Disabled, 1 : Enabled, DCGM_INT32_BLANK : Ignored). Note that\n!< using this setting may result in lower clocks than targetClocks"]
    pub syncBoost: ::std::os::raw::c_uint,
    #[doc = "!< Target clocks. Set smClock and memClock to DCGM_INT32_BLANK to ignore/use\n!< compatible values. For GPUs > Maxwell, setting this implies autoBoost=0"]
    pub targetClocks: dcgmClockSet_t,
}
#[doc = " Used to represents the power capping limit for each GPU in the group or to represent the power\n budget for the entire group"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmConfigPowerLimit_t {
    #[doc = "!< Flag to represent power cap for each GPU or power budget for the group of GPUs"]
    pub type_: dcgmConfigPowerLimitType_t,
    #[doc = "!< Power Limit in Watts (Set a value OR DCGM_INT32_BLANK to Ignore)"]
    pub val: ::std::os::raw::c_uint,
}
#[doc = " Structure to represent default and target configuration for a device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmConfig_v1 {
    #[doc = "!< Version number (dcgmConfig_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< GPU ID"]
    pub gpuId: ::std::os::raw::c_uint,
    #[doc = "!< ECC Mode  (0: Disabled, 1 : Enabled, DCGM_INT32_BLANK : Ignored)"]
    pub eccMode: ::std::os::raw::c_uint,
    #[doc = "!< Compute Mode (One of DCGM_CONFIG_COMPUTEMODE_? OR DCGM_INT32_BLANK to Ignore)"]
    pub computeMode: ::std::os::raw::c_uint,
    #[doc = "!< Performance State Settings (clocks / boost mode)"]
    pub perfState: dcgmConfigPerfStateSettings_t,
    #[doc = "!< Power Limits"]
    pub powerLimit: dcgmConfigPowerLimit_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmConfig_v2 {
    #[doc = "!< Version number (dcgmConfig_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< GPU ID"]
    pub gpuId: ::std::os::raw::c_uint,
    #[doc = "!< ECC Mode  (0: Disabled, 1 : Enabled, DCGM_INT32_BLANK : Ignored)"]
    pub eccMode: ::std::os::raw::c_uint,
    #[doc = "!< Compute Mode (One of DCGM_CONFIG_COMPUTEMODE_? OR DCGM_INT32_BLANK to Ignore)"]
    pub computeMode: ::std::os::raw::c_uint,
    #[doc = "!< Performance State Settings (clocks / boost mode)"]
    pub perfState: dcgmConfigPerfStateSettings_t,
    #[doc = "!< Power Limits"]
    pub powerLimit: dcgmConfigPowerLimit_t,
    pub workloadPowerProfiles: [::std::os::raw::c_uint; 8usize],
}
#[doc = " Typedef for \\ref dcgmConfig_v1"]
pub type dcgmConfig_t = dcgmConfig_v2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmPolicyViolation_v1 {
    #[doc = "!< Version number (dcgmPolicyViolation_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< true/false notification on ECC Double Bit Errors"]
    pub notifyOnEccDbe: ::std::os::raw::c_uint,
    #[doc = "!< true/false notification on PCI Events"]
    pub notifyOnPciEvent: ::std::os::raw::c_uint,
    #[doc = "!< number of retired pages to occur before notification"]
    pub notifyOnMaxRetiredPages: ::std::os::raw::c_uint,
}
pub type dcgmPolicyViolation_t = dcgmPolicyViolation_v1;
#[doc = "!< Double bit errors -- boolean in dcgmPolicyConditionParams_t"]
pub const dcgmPolicyConditionIdx_enum_DCGM_POLICY_COND_IDX_DBE: dcgmPolicyConditionIdx_enum = 0;
#[doc = "!< PCI events/errors -- boolean in dcgmPolicyConditionParams_t"]
pub const dcgmPolicyConditionIdx_enum_DCGM_POLICY_COND_IDX_PCI: dcgmPolicyConditionIdx_enum = 1;
#[doc = "!< Maximum number of retired pages -- number\n!< required in dcgmPolicyConditionParams_t"]
pub const dcgmPolicyConditionIdx_enum_DCGM_POLICY_COND_IDX_MAX_PAGES_RETIRED:
    dcgmPolicyConditionIdx_enum = 2;
#[doc = "!< Thermal violation -- number required in dcgmPolicyConditionParams_t"]
pub const dcgmPolicyConditionIdx_enum_DCGM_POLICY_COND_IDX_THERMAL: dcgmPolicyConditionIdx_enum = 3;
#[doc = "!< Power violation -- number required in dcgmPolicyConditionParams_t"]
pub const dcgmPolicyConditionIdx_enum_DCGM_POLICY_COND_IDX_POWER: dcgmPolicyConditionIdx_enum = 4;
#[doc = "!< NVLINK errors -- boolean in dcgmPolicyConditionParams_t"]
pub const dcgmPolicyConditionIdx_enum_DCGM_POLICY_COND_IDX_NVLINK: dcgmPolicyConditionIdx_enum = 5;
#[doc = "!< XID errors -- number required in dcgmPolicyConditionParams_t"]
pub const dcgmPolicyConditionIdx_enum_DCGM_POLICY_COND_IDX_XID: dcgmPolicyConditionIdx_enum = 6;
#[doc = " Enumeration for policy conditions.\n When used as part of dcgmPolicy_t these have corresponding parameters to\n allow them to be switched on/off or set specific violation thresholds"]
pub type dcgmPolicyConditionIdx_enum = ::std::os::raw::c_uint;
#[doc = " Enumeration for policy conditions.\n When used as part of dcgmPolicy_t these have corresponding parameters to\n allow them to be switched on/off or set specific violation thresholds"]
pub use self::dcgmPolicyConditionIdx_enum as dcgmPolicyConditionIdx_t;
#[doc = "!< Double bit errors -- boolean in dcgmPolicyConditionParams_t"]
pub const dcgmPolicyCondition_enum_DCGM_POLICY_COND_DBE: dcgmPolicyCondition_enum = 1;
#[doc = "!< PCI events/errors -- boolean in dcgmPolicyConditionParams_t"]
pub const dcgmPolicyCondition_enum_DCGM_POLICY_COND_PCI: dcgmPolicyCondition_enum = 2;
#[doc = "!< Maximum number of retired pages -- number\n!< required in dcgmPolicyConditionParams_t"]
pub const dcgmPolicyCondition_enum_DCGM_POLICY_COND_MAX_PAGES_RETIRED: dcgmPolicyCondition_enum = 4;
#[doc = "!< Thermal violation -- number required in dcgmPolicyConditionParams_t"]
pub const dcgmPolicyCondition_enum_DCGM_POLICY_COND_THERMAL: dcgmPolicyCondition_enum = 8;
#[doc = "!< Power violation -- number required in dcgmPolicyConditionParams_t"]
pub const dcgmPolicyCondition_enum_DCGM_POLICY_COND_POWER: dcgmPolicyCondition_enum = 16;
#[doc = "!< NVLINK errors -- boolean in dcgmPolicyConditionParams_t"]
pub const dcgmPolicyCondition_enum_DCGM_POLICY_COND_NVLINK: dcgmPolicyCondition_enum = 32;
#[doc = "!< XID errors -- number required in dcgmPolicyConditionParams_t"]
pub const dcgmPolicyCondition_enum_DCGM_POLICY_COND_XID: dcgmPolicyCondition_enum = 64;
#[doc = " Bitmask enumeration for policy conditions.\n When used as part of dcgmPolicy_t these have corresponding parameters to\n allow them to be switched on/off or set specific violation thresholds"]
pub type dcgmPolicyCondition_enum = ::std::os::raw::c_uint;
#[doc = " Bitmask enumeration for policy conditions.\n When used as part of dcgmPolicy_t these have corresponding parameters to\n allow them to be switched on/off or set specific violation thresholds"]
pub use self::dcgmPolicyCondition_enum as dcgmPolicyCondition_t;
#[doc = " Structure for policy condition parameters.\n This structure contains a tag that represents the type of the value being passed\n as well as a \"val\" which is a union of the possible value types.  For example,\n to pass a true boolean: tag = BOOL, val.boolean = 1."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dcgmPolicyConditionParams_st {
    pub tag: dcgmPolicyConditionParams_st__bindgen_ty_1,
    pub val: dcgmPolicyConditionParams_st__bindgen_ty_2,
}
pub const dcgmPolicyConditionParams_st_BOOL: dcgmPolicyConditionParams_st__bindgen_ty_1 = 0;
pub const dcgmPolicyConditionParams_st_LLONG: dcgmPolicyConditionParams_st__bindgen_ty_1 = 1;
pub type dcgmPolicyConditionParams_st__bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union dcgmPolicyConditionParams_st__bindgen_ty_2 {
    pub boolean: ::std::os::raw::c_uint,
    pub llval: ::std::os::raw::c_ulonglong,
}
#[doc = " Structure for policy condition parameters.\n This structure contains a tag that represents the type of the value being passed\n as well as a \"val\" which is a union of the possible value types.  For example,\n to pass a true boolean: tag = BOOL, val.boolean = 1."]
pub type dcgmPolicyConditionParams_t = dcgmPolicyConditionParams_st;
#[doc = "!< automatic mode"]
pub const dcgmPolicyMode_enum_DCGM_POLICY_MODE_AUTOMATED: dcgmPolicyMode_enum = 0;
#[doc = "!< manual mode"]
pub const dcgmPolicyMode_enum_DCGM_POLICY_MODE_MANUAL: dcgmPolicyMode_enum = 1;
#[doc = " Enumeration for policy modes"]
pub type dcgmPolicyMode_enum = ::std::os::raw::c_uint;
#[doc = " Enumeration for policy modes"]
pub use self::dcgmPolicyMode_enum as dcgmPolicyMode_t;
#[doc = "!< no isolation of GPUs on error"]
pub const dcgmPolicyIsolation_enum_DCGM_POLICY_ISOLATION_NONE: dcgmPolicyIsolation_enum = 0;
#[doc = " Enumeration for policy isolation modes"]
pub type dcgmPolicyIsolation_enum = ::std::os::raw::c_uint;
#[doc = " Enumeration for policy isolation modes"]
pub use self::dcgmPolicyIsolation_enum as dcgmPolicyIsolation_t;
#[doc = "!< no action"]
pub const dcgmPolicyAction_enum_DCGM_POLICY_ACTION_NONE: dcgmPolicyAction_enum = 0;
#[doc = "!< Deprecated - perform a GPU reset on violation"]
pub const dcgmPolicyAction_enum_DCGM_POLICY_ACTION_GPURESET: dcgmPolicyAction_enum = 1;
#[doc = " Enumeration for policy actions"]
pub type dcgmPolicyAction_enum = ::std::os::raw::c_uint;
#[doc = " Enumeration for policy actions"]
pub use self::dcgmPolicyAction_enum as dcgmPolicyAction_t;
#[doc = "!< no validation after an action is performed"]
pub const dcgmPolicyValidation_enum_DCGM_POLICY_VALID_NONE: dcgmPolicyValidation_enum = 0;
#[doc = "!< run a short System Validation on the system after failure"]
pub const dcgmPolicyValidation_enum_DCGM_POLICY_VALID_SV_SHORT: dcgmPolicyValidation_enum = 1;
#[doc = "!< run a medium System Validation test after failure"]
pub const dcgmPolicyValidation_enum_DCGM_POLICY_VALID_SV_MED: dcgmPolicyValidation_enum = 2;
#[doc = "!< run a extensive System Validation test after failure"]
pub const dcgmPolicyValidation_enum_DCGM_POLICY_VALID_SV_LONG: dcgmPolicyValidation_enum = 3;
#[doc = "!< run a more extensive System Validation test after failure"]
pub const dcgmPolicyValidation_enum_DCGM_POLICY_VALID_SV_XLONG: dcgmPolicyValidation_enum = 4;
#[doc = " Enumeration for policy validation actions"]
pub type dcgmPolicyValidation_enum = ::std::os::raw::c_uint;
#[doc = " Enumeration for policy validation actions"]
pub use self::dcgmPolicyValidation_enum as dcgmPolicyValidation_t;
#[doc = "!< on failure of validation perform no action"]
pub const dcgmPolicyFailureResp_enum_DCGM_POLICY_FAILURE_NONE: dcgmPolicyFailureResp_enum = 0;
#[doc = " Enumeration for policy failure responses"]
pub type dcgmPolicyFailureResp_enum = ::std::os::raw::c_uint;
#[doc = " Enumeration for policy failure responses"]
pub use self::dcgmPolicyFailureResp_enum as dcgmPolicyFailureResp_t;
#[doc = " Structure to fill when a user queries for policy violations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmPolicyViolationNotify_t {
    #[doc = "!< gpu ID"]
    pub gpuId: ::std::os::raw::c_uint,
    #[doc = "!< a violation based on the bit values in \\ref dcgmPolicyCondition_t"]
    pub violationOccurred: ::std::os::raw::c_uint,
}
#[doc = " Define the structure that specifies a policy to be enforced for a GPU"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dcgmPolicy_v1 {
    #[doc = "!< version number (dcgmPolicy_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Condition(s) to access \\ref dcgmPolicyCondition_t"]
    pub condition: dcgmPolicyCondition_t,
    #[doc = "!< Mode of operation \\ref dcgmPolicyMode_t"]
    pub mode: dcgmPolicyMode_t,
    #[doc = "!< Isolation level after a policy violation \\ref dcgmPolicyIsolation_t"]
    pub isolation: dcgmPolicyIsolation_t,
    #[doc = "!< Action to perform after a policy violation \\ref dcgmPolicyAction_t action"]
    pub action: dcgmPolicyAction_t,
    #[doc = "!< Validation to perform after action is taken \\ref dcgmPolicyValidation_t"]
    pub validation: dcgmPolicyValidation_t,
    #[doc = "!< Failure to validation response \\ref dcgmPolicyFailureResp_t"]
    pub response: dcgmPolicyFailureResp_t,
    #[doc = "!< Parameters for the \\a condition fields"]
    pub parms: [dcgmPolicyConditionParams_t; 7usize],
}
#[doc = " Typedef for \\ref dcgmPolicy_v1"]
pub type dcgmPolicy_t = dcgmPolicy_v1;
#[doc = " Define the ECC DBE return structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmPolicyConditionDbe_t {
    #[doc = "!< timestamp of the error"]
    pub timestamp: ::std::os::raw::c_longlong,
    #[doc = "!< location of the error"]
    pub location: dcgmPolicyConditionDbe_t__bindgen_ty_1,
    #[doc = "!< number of errors"]
    pub numerrors: ::std::os::raw::c_uint,
}
pub const dcgmPolicyConditionDbe_t_L1: dcgmPolicyConditionDbe_t__bindgen_ty_1 = 0;
pub const dcgmPolicyConditionDbe_t_L2: dcgmPolicyConditionDbe_t__bindgen_ty_1 = 1;
pub const dcgmPolicyConditionDbe_t_DEVICE: dcgmPolicyConditionDbe_t__bindgen_ty_1 = 2;
pub const dcgmPolicyConditionDbe_t_REGISTER: dcgmPolicyConditionDbe_t__bindgen_ty_1 = 3;
pub const dcgmPolicyConditionDbe_t_TEXTURE: dcgmPolicyConditionDbe_t__bindgen_ty_1 = 4;
pub type dcgmPolicyConditionDbe_t__bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " Define the PCI replay error return structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmPolicyConditionPci_t {
    #[doc = "!< timestamp of the error"]
    pub timestamp: ::std::os::raw::c_longlong,
    #[doc = "!< value of the PCIe replay counter"]
    pub counter: ::std::os::raw::c_uint,
}
#[doc = " Define the maximum pending retired pages limit return structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmPolicyConditionMpr_t {
    #[doc = "!< timestamp of the error"]
    pub timestamp: ::std::os::raw::c_longlong,
    #[doc = "!< number of pending pages due to SBE"]
    pub sbepages: ::std::os::raw::c_uint,
    #[doc = "!< number of pending pages due to DBE"]
    pub dbepages: ::std::os::raw::c_uint,
}
#[doc = " Define the thermal policy violations return structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmPolicyConditionThermal_t {
    #[doc = "!< timestamp of the error"]
    pub timestamp: ::std::os::raw::c_longlong,
    #[doc = "!< Temperature reached that violated policy"]
    pub thermalViolation: ::std::os::raw::c_uint,
}
#[doc = " Define the power policy violations return structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmPolicyConditionPower_t {
    #[doc = "!< timestamp of the error"]
    pub timestamp: ::std::os::raw::c_longlong,
    #[doc = "!< Power value reached that violated policy"]
    pub powerViolation: ::std::os::raw::c_uint,
}
#[doc = " Define the nvlink policy violations return structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmPolicyConditionNvlink_t {
    #[doc = "!< timestamp of the error"]
    pub timestamp: ::std::os::raw::c_longlong,
    #[doc = "!< Nvlink counter field ID that violated policy"]
    pub fieldId: ::std::os::raw::c_ushort,
    #[doc = "!< Nvlink counter value that violated policy"]
    pub counter: ::std::os::raw::c_uint,
}
#[doc = " Define the xid policy violations return structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmPolicyConditionXID_t {
    #[doc = "!< Timestamp of the error"]
    pub timestamp: ::std::os::raw::c_longlong,
    #[doc = "!< The XID error number"]
    pub errnum: ::std::os::raw::c_uint,
}
#[doc = " Define the structure that is given to the callback function"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dcgmPolicyCallbackResponse_v2 {
    #[doc = "!< version number (dcgmPolicyCallbackResponse_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Condition that was violated"]
    pub condition: dcgmPolicyCondition_t,
    pub val: dcgmPolicyCallbackResponse_v2__bindgen_ty_1,
    #[doc = "!< GPU ID of GPU which violated the policy."]
    pub gpuId: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dcgmPolicyCallbackResponse_v2__bindgen_ty_1 {
    #[doc = "!< ECC DBE return structure"]
    pub dbe: dcgmPolicyConditionDbe_t,
    #[doc = "!< PCI replay error return structure"]
    pub pci: dcgmPolicyConditionPci_t,
    #[doc = "!< Max retired pages limit return structure"]
    pub mpr: dcgmPolicyConditionMpr_t,
    #[doc = "!< Thermal policy violations return structure"]
    pub thermal: dcgmPolicyConditionThermal_t,
    #[doc = "!< Power policy violations return structure"]
    pub power: dcgmPolicyConditionPower_t,
    #[doc = "!< Nvlink policy violations return structure"]
    pub nvlink: dcgmPolicyConditionNvlink_t,
    #[doc = "!< XID policy violations return structure"]
    pub xid: dcgmPolicyConditionXID_t,
}
#[doc = " Typedef for \\ref dcgmPolicyCallbackResponse_v2"]
pub type dcgmPolicyCallbackResponse_t = dcgmPolicyCallbackResponse_v2;
#[doc = " Represents a callback to receive updates from asynchronous functions.\n Currently the only implemented callback function is dcgmPolicyRegister_v2."]
pub type fpRecvUpdates = ::std::option::Option<
    unsafe extern "C" fn(
        response: *mut dcgmPolicyCallbackResponse_t,
        userData: u64,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " This structure is used to represent value for the field to be queried."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dcgmFieldValue_v1 {
    #[doc = "!< version number (dcgmFieldValue_version1)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< One of DCGM_FI_?"]
    pub fieldId: ::std::os::raw::c_ushort,
    #[doc = "!< One of DCGM_FT_?"]
    pub fieldType: ::std::os::raw::c_ushort,
    #[doc = "!< Status for the querying the field. DCGM_ST_OK or one of DCGM_ST_?"]
    pub status: ::std::os::raw::c_int,
    #[doc = "!< Timestamp in usec since 1970"]
    pub ts: i64,
    #[doc = "!< Value"]
    pub value: dcgmFieldValue_v1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dcgmFieldValue_v1__bindgen_ty_1 {
    #[doc = "!< Int64 value"]
    pub i64_: i64,
    #[doc = "!< Double value"]
    pub dbl: f64,
    #[doc = "!< NULL terminated string"]
    pub str_: [::std::os::raw::c_char; 256usize],
    #[doc = "!< Binary blob"]
    pub blob: [::std::os::raw::c_char; 4096usize],
}
#[doc = " This structure is used to represent value for the field to be queried."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dcgmFieldValue_v2 {
    #[doc = "!< version number (dcgmFieldValue_version2)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Entity group this field value's entity belongs to"]
    pub entityGroupId: dcgm_field_entity_group_t,
    #[doc = "!< Entity this field value belongs to"]
    pub entityId: dcgm_field_eid_t,
    #[doc = "!< One of DCGM_FI_?"]
    pub fieldId: ::std::os::raw::c_ushort,
    #[doc = "!< One of DCGM_FT_?"]
    pub fieldType: ::std::os::raw::c_ushort,
    #[doc = "!< Status for the querying the field. DCGM_ST_OK or one of DCGM_ST_?"]
    pub status: ::std::os::raw::c_int,
    #[doc = "!< Unused for now to align ts to an 8-byte boundary."]
    pub unused: ::std::os::raw::c_uint,
    #[doc = "!< Timestamp in usec since 1970"]
    pub ts: i64,
    #[doc = "!< Value"]
    pub value: dcgmFieldValue_v2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dcgmFieldValue_v2__bindgen_ty_1 {
    #[doc = "!< Int64 value"]
    pub i64_: i64,
    #[doc = "!< Double value"]
    pub dbl: f64,
    #[doc = "!< NULL terminated string"]
    pub str_: [::std::os::raw::c_char; 256usize],
    #[doc = "!< Binary blob"]
    pub blob: [::std::os::raw::c_char; 4096usize],
}
#[doc = " User callback function for processing one or more field updates. This callback will\n be invoked one or more times per field until all of the expected field values have been\n enumerated. It is up to the callee to detect when the field id changes\n\n @param gpuId                IN: GPU ID of the GPU this field value set belongs to\n @param values               IN: Field values. These values must be copied as they will be destroyed as soon as this\n                                 call returns.\n @param numValues            IN: Number of entries that are valid in values[]\n @param userData             IN: User data pointer passed to the update function that generated this callback\n\n @returns\n          0 if OK\n         <0 if enumeration should stop. This allows to callee to abort field value enumeration.\n"]
pub type dcgmFieldValueEnumeration_f = ::std::option::Option<
    unsafe extern "C" fn(
        gpuId: ::std::os::raw::c_uint,
        values: *mut dcgmFieldValue_v1,
        numValues: ::std::os::raw::c_int,
        userData: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " User callback function for processing one or more field updates. This callback will\n be invoked one or more times per field until all of the expected field values have been\n enumerated. It is up to the callee to detect when the field id changes\n\n @param entityGroupId        IN: entityGroup of the entity this field value set belongs to\n @param entityId             IN: Entity this field value set belongs to\n @param values               IN: Field values. These values must be copied as they will be destroyed as soon as this\n                                 call returns.\n @param numValues            IN: Number of entries that are valid in values[]\n @param userData             IN: User data pointer passed to the update function that generated this callback\n\n @returns\n          0 if OK\n         <0 if enumeration should stop. This allows to callee to abort field value enumeration.\n"]
pub type dcgmFieldValueEntityEnumeration_f = ::std::option::Option<
    unsafe extern "C" fn(
        entityGroupId: dcgm_field_entity_group_t,
        entityId: dcgm_field_eid_t,
        values: *mut dcgmFieldValue_v1,
        numValues: ::std::os::raw::c_int,
        userData: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Summary of time series data in int64 format.\n\n Each value will either be set or be a BLANK value.\n Check for blank with the DCGM_INT64_IS_BLANK() macro.\n \\sa See dcgmvalue.h for the actual values of BLANK values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmStatSummaryInt64_t {
    #[doc = "!< Minimum value of the samples looked at"]
    pub minValue: ::std::os::raw::c_longlong,
    #[doc = "!< Maximum value of the samples looked at"]
    pub maxValue: ::std::os::raw::c_longlong,
    #[doc = "!< Simple average of the samples looked at. Blank values are ignored for this calculation"]
    pub average: ::std::os::raw::c_longlong,
}
#[doc = " Same as dcgmStatSummaryInt64_t, but with 32-bit integer values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmStatSummaryInt32_t {
    #[doc = "!< Minimum value of the samples looked at"]
    pub minValue: ::std::os::raw::c_int,
    #[doc = "!< Maximum value of the samples looked at"]
    pub maxValue: ::std::os::raw::c_int,
    #[doc = "!< Simple average of the samples looked at. Blank values are ignored for this calculation"]
    pub average: ::std::os::raw::c_int,
}
#[doc = " Summary of time series data in double-precision format.\n Each value will either be set or be a BLANK value.\n Check for blank with the DCGM_FP64_IS_BLANK() macro.\n \\sa See dcgmvalue.h for the actual values of BLANK values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmStatSummaryFp64_t {
    #[doc = "!< Minimum value of the samples looked at"]
    pub minValue: f64,
    #[doc = "!< Maximum value of the samples looked at"]
    pub maxValue: f64,
    #[doc = "!< Simple average of the samples looked at. Blank values are ignored for this calculation"]
    pub average: f64,
}
#[doc = "!< PCIe system watches (must have 1m of data before query)"]
pub const dcgmHealthSystems_enum_DCGM_HEALTH_WATCH_PCIE: dcgmHealthSystems_enum = 1;
#[doc = "!< NVLINK system watches"]
pub const dcgmHealthSystems_enum_DCGM_HEALTH_WATCH_NVLINK: dcgmHealthSystems_enum = 2;
#[doc = "!< Power management unit watches"]
pub const dcgmHealthSystems_enum_DCGM_HEALTH_WATCH_PMU: dcgmHealthSystems_enum = 4;
#[doc = "!< Micro-controller unit watches"]
pub const dcgmHealthSystems_enum_DCGM_HEALTH_WATCH_MCU: dcgmHealthSystems_enum = 8;
#[doc = "!< Memory watches"]
pub const dcgmHealthSystems_enum_DCGM_HEALTH_WATCH_MEM: dcgmHealthSystems_enum = 16;
#[doc = "!< Streaming multiprocessor watches"]
pub const dcgmHealthSystems_enum_DCGM_HEALTH_WATCH_SM: dcgmHealthSystems_enum = 32;
#[doc = "!< Inforom watches"]
pub const dcgmHealthSystems_enum_DCGM_HEALTH_WATCH_INFOROM: dcgmHealthSystems_enum = 64;
#[doc = "!< Temperature watches (must have 1m of data before query)"]
pub const dcgmHealthSystems_enum_DCGM_HEALTH_WATCH_THERMAL: dcgmHealthSystems_enum = 128;
#[doc = "!< Power watches (must have 1m of data before query)"]
pub const dcgmHealthSystems_enum_DCGM_HEALTH_WATCH_POWER: dcgmHealthSystems_enum = 256;
#[doc = "!< Driver-related watches"]
pub const dcgmHealthSystems_enum_DCGM_HEALTH_WATCH_DRIVER: dcgmHealthSystems_enum = 512;
#[doc = "!< Non-fatal errors in NvSwitch"]
pub const dcgmHealthSystems_enum_DCGM_HEALTH_WATCH_NVSWITCH_NONFATAL: dcgmHealthSystems_enum = 1024;
#[doc = "!< Fatal errors in NvSwitch"]
pub const dcgmHealthSystems_enum_DCGM_HEALTH_WATCH_NVSWITCH_FATAL: dcgmHealthSystems_enum = 2048;
#[doc = "!< All watches enabled"]
pub const dcgmHealthSystems_enum_DCGM_HEALTH_WATCH_ALL: dcgmHealthSystems_enum = 4294967295;
#[doc = " Systems structure used to enable or disable health watch systems"]
pub type dcgmHealthSystems_enum = ::std::os::raw::c_uint;
#[doc = " Systems structure used to enable or disable health watch systems"]
pub use self::dcgmHealthSystems_enum as dcgmHealthSystems_t;
#[doc = "!< All results within this system are reporting normal"]
pub const dcgmHealthWatchResult_enum_DCGM_HEALTH_RESULT_PASS: dcgmHealthWatchResult_enum = 0;
#[doc = "!< A warning has been issued, refer to the response for more information"]
pub const dcgmHealthWatchResult_enum_DCGM_HEALTH_RESULT_WARN: dcgmHealthWatchResult_enum = 10;
#[doc = "!< A failure has been issued, refer to the response for more information"]
pub const dcgmHealthWatchResult_enum_DCGM_HEALTH_RESULT_FAIL: dcgmHealthWatchResult_enum = 20;
#[doc = " Health Watch test results"]
pub type dcgmHealthWatchResult_enum = ::std::os::raw::c_uint;
#[doc = " Health Watch test results"]
pub use self::dcgmHealthWatchResult_enum as dcgmHealthWatchResults_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagErrorDetail_t {
    pub msg: [::std::os::raw::c_char; 1024usize],
    pub code: ::std::os::raw::c_uint,
}
#[doc = " Error details\n\n Since DCGM 3.3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagErrorDetail_v2 {
    pub msg: [::std::os::raw::c_char; 512usize],
    pub gpuId: ::std::os::raw::c_int,
    pub code: ::std::os::raw::c_uint,
    #[doc = "!< See dcgmErrorCategory_t"]
    pub category: ::std::os::raw::c_uint,
    #[doc = "!< See dcgmErrorSeverity_t"]
    pub severity: ::std::os::raw::c_uint,
}
#[doc = "!< This test passed as diagnostics"]
pub const dcgmDiagResult_enum_DCGM_DIAG_RESULT_PASS: dcgmDiagResult_enum = 0;
#[doc = "!< This test was skipped"]
pub const dcgmDiagResult_enum_DCGM_DIAG_RESULT_SKIP: dcgmDiagResult_enum = 1;
#[doc = "!< This test passed with warnings"]
pub const dcgmDiagResult_enum_DCGM_DIAG_RESULT_WARN: dcgmDiagResult_enum = 2;
#[doc = "!< This test failed the diagnostics"]
pub const dcgmDiagResult_enum_DCGM_DIAG_RESULT_FAIL: dcgmDiagResult_enum = 3;
#[doc = "!< This test wasn't executed"]
pub const dcgmDiagResult_enum_DCGM_DIAG_RESULT_NOT_RUN: dcgmDiagResult_enum = 4;
#[doc = " Diagnostic test results"]
pub type dcgmDiagResult_enum = ::std::os::raw::c_uint;
#[doc = " Diagnostic test results"]
pub use self::dcgmDiagResult_enum as dcgmDiagResult_t;
#[doc = " Diagnostic plugin per-entity info results v1\n\n Since DCGM 4.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagInfo_v1 {
    #[doc = "!< The entity associated with the info. Use group DCGM_FE_NONE for global scope."]
    pub entity: dcgmGroupEntityPair_t,
    #[doc = "!< Any message associated with the error reported by the plugin."]
    pub msg: [::std::os::raw::c_char; 512usize],
    #[doc = "!< The index of the test reporting the error."]
    pub testId: ::std::os::raw::c_uint,
}
#[doc = " Diagnostic plugin per-entity error results v1\n\n Since DCGM 4.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagError_v1 {
    #[doc = "!< The entity associated with the error. Use group DCGM_FE_NONE for global scope."]
    pub entity: dcgmGroupEntityPair_t,
    #[doc = "!< The error code being reported."]
    pub code: ::std::os::raw::c_uint,
    #[doc = "!< The category of error reported. See dcgmErrorCategory_t in dcgm_errors.h."]
    pub category: ::std::os::raw::c_uint,
    #[doc = "!< The severity of the error reported. See dcgmErrorSeverity_t in dcgm_errors.h."]
    pub severity: ::std::os::raw::c_uint,
    #[doc = "!< Any message associated with the error reported by the plugin."]
    pub msg: [::std::os::raw::c_char; 512usize],
    #[doc = "!< The index of the test reporting the error."]
    pub testId: ::std::os::raw::c_uint,
}
#[doc = " Diagnostic plugin per-entity error results v1\n\n Since DCGM 4.0\n See also PluginInterface.h: dcgmDiagEntityResults_v1."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagEntityResult_v1 {
    #[doc = "!< The entity associated with the result. Use group DCGM_FE_NONE for global scope."]
    pub entity: dcgmGroupEntityPair_t,
    #[doc = "!< Result for this entity."]
    pub result: dcgmDiagResult_t,
    #[doc = "!< The index of the test reporting the error."]
    pub testId: ::std::os::raw::c_uint,
}
#[doc = " Per test aux data structure v1\n\n Since DCGM 4.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagTestAuxData_v1 {
    #[doc = "!< version number (dcgmDiagTestAuxData_version1)"]
    pub version: ::std::os::raw::c_uint,
    pub data: [::std::os::raw::c_char; 2048usize],
}
#[doc = " Information about each test run.\n\n Since DCGM 4.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagTestRun_v1 {
    #[doc = "!< The name of the test."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "!< Plugin name that this test belongs to"]
    pub pluginName: [::std::os::raw::c_char; 32usize],
    #[doc = "!< Overall result of the plugin (PASS, FAIL, SKIP, WARN, NOT_RUN)."]
    pub result: dcgmDiagResult_t,
    #[doc = "!< Number of errors, always 0 on PASS."]
    pub numErrors: ::std::os::raw::c_uchar,
    #[doc = "!< Number of info msgs."]
    pub numInfo: ::std::os::raw::c_uchar,
    #[doc = "!< Index into DiagResponse.categories"]
    pub categoryIndex: ::std::os::raw::c_uchar,
    #[doc = "!< padding byte"]
    pub _unused: ::std::os::raw::c_uchar,
    #[doc = "!< Number of entity results."]
    pub numResults: ::std::os::raw::c_ushort,
    #[doc = "!< Per-entity error indices for this run."]
    pub errorIndices: [::std::os::raw::c_uchar; 32usize],
    #[doc = "!< Per-entity info indices for this run."]
    pub infoIndices: [::std::os::raw::c_uchar; 16usize],
    #[doc = "!< Per-entity result indices for this run."]
    pub resultIndices: [::std::os::raw::c_ushort; 1024usize],
    pub auxData: dcgmDiagTestAuxData_v1,
}
#[doc = " Additional entity details for entity-centric diagnostic run.\n\n Since DCGM 4.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagEntity_v1 {
    #[doc = "!< Entity group and entity id."]
    pub entity: dcgmGroupEntityPair_t,
    #[doc = "!< Serial number (string; GPU only?)"]
    pub serialNum: [::std::os::raw::c_char; 256usize],
    #[doc = "!< PCI device ID (string; GPU only?)"]
    pub skuDeviceId: [::std::os::raw::c_char; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmIncidentInfo_t {
    #[doc = "!< system to which this information belongs"]
    pub system: dcgmHealthSystems_t,
    #[doc = "!< health diagnosis of this incident"]
    pub health: dcgmHealthWatchResults_t,
    #[doc = "!< Information about the error(s) and their error codes"]
    pub error: dcgmDiagErrorDetail_t,
    #[doc = "!< identify which entity has this error"]
    pub entityInfo: dcgmGroupEntityPair_t,
}
#[doc = " Health response structure version 4 - Simply list the incidents instead of reporting by entity\n\n Since DCGM 2.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmHealthResponse_v5 {
    #[doc = "!< The version number of this struct"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< The overall health of this entire host"]
    pub overallHealth: dcgmHealthWatchResults_t,
    #[doc = "!< The number of health incidents reported in this struct"]
    pub incidentCount: ::std::os::raw::c_uint,
    #[doc = "!< Report of the errors detected"]
    pub incidents: [dcgmIncidentInfo_t; 1024usize],
}
#[doc = " Typedef for \\ref dcgmHealthResponse_v5"]
pub type dcgmHealthResponse_t = dcgmHealthResponse_v5;
#[doc = " Structure used to set health watches via the dcgmHealthSet_v2 API"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmHealthSetParams_v2 {
    #[doc = "< Version of this struct. Should be dcgmHealthSet_version2"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "< Group ID representing collection of one or more entities. Look\nat \\ref dcgmGroupCreate for details on creating the group.\nAlternatively, pass in the group id as \\a DCGM_GROUP_ALL_GPUS\nto perform operation on all the GPUs or \\a DCGM_GROUP_ALL_NVSWITCHES\nto perform operation on all the NvSwitches."]
    pub groupId: dcgmGpuGrp_t,
    #[doc = "< An enum representing systems that should be enabled for health\nchecks logically OR'd together. Refer to \\ref dcgmHealthSystems_t\nfor details."]
    pub systems: dcgmHealthSystems_t,
    #[doc = "< How often to query the underlying health information from the\nNVIDIA driver in usec. This should be the same as how often you call\ndcgmHealthCheck"]
    pub updateInterval: ::std::os::raw::c_longlong,
    #[doc = "< How long to keep data cached for this field in seconds. This should\nbe at least your maximum time between calling dcgmHealthCheck"]
    pub maxKeepAge: f64,
}
#[doc = " per process utilization rates"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmProcessUtilInfo_t {
    pub pid: ::std::os::raw::c_uint,
    pub smUtil: f64,
    pub memUtil: f64,
}
#[doc = "Internal structure used to get the PID and the corresponding utilization rate"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmProcessUtilSample_t {
    pub util: f64,
    pub pid: ::std::os::raw::c_uint,
}
#[doc = " Info corresponding to single PID"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmPidSingleInfo_t {
    #[doc = "!< ID of the GPU this pertains to. GPU_ID_INVALID = summary information for multiple GPUs"]
    pub gpuId: ::std::os::raw::c_uint,
    #[doc = "!< Energy consumed by the gpu in milli-watt/seconds"]
    pub energyConsumed: ::std::os::raw::c_longlong,
    #[doc = "!< PCI-E bytes read from the GPU"]
    pub pcieRxBandwidth: dcgmStatSummaryInt64_t,
    #[doc = "!< PCI-E bytes written to the GPU"]
    pub pcieTxBandwidth: dcgmStatSummaryInt64_t,
    #[doc = "!< Count of PCI-E replays that occurred"]
    pub pcieReplays: ::std::os::raw::c_longlong,
    #[doc = "!< Process start time in microseconds since 1970"]
    pub startTime: ::std::os::raw::c_longlong,
    #[doc = "!< Process end time in microseconds since 1970 or reported as 0 if the process is not completed"]
    pub endTime: ::std::os::raw::c_longlong,
    #[doc = "!< Process SM and Memory Utilization (in percent)"]
    pub processUtilization: dcgmProcessUtilInfo_t,
    #[doc = "!< GPU SM Utilization in percent"]
    pub smUtilization: dcgmStatSummaryInt32_t,
    #[doc = "!< GPU Memory Utilization in percent"]
    pub memoryUtilization: dcgmStatSummaryInt32_t,
    #[doc = "!< Deprecated - Count of ECC single bit errors that occurred"]
    pub eccSingleBit: ::std::os::raw::c_uint,
    #[doc = "!< Count of ECC double bit errors that occurred"]
    pub eccDoubleBit: ::std::os::raw::c_uint,
    #[doc = "!< Memory clock in MHz"]
    pub memoryClock: dcgmStatSummaryInt32_t,
    #[doc = "!< SM clock in MHz"]
    pub smClock: dcgmStatSummaryInt32_t,
    #[doc = "!< Number of valid entries in xidCriticalErrorsTs"]
    pub numXidCriticalErrors: ::std::os::raw::c_int,
    #[doc = "!< Timestamps of the critical XID errors that occurred"]
    pub xidCriticalErrorsTs: [::std::os::raw::c_longlong; 10usize],
    #[doc = "!< Count of otherComputePids entries that are valid"]
    pub numOtherComputePids: ::std::os::raw::c_int,
    #[doc = "!< Other compute processes that ran. 0=no process"]
    pub otherComputePids: [::std::os::raw::c_uint; 16usize],
    #[doc = "!< Count of otherGraphicsPids entries that are valid"]
    pub numOtherGraphicsPids: ::std::os::raw::c_int,
    #[doc = "!< Other graphics processes that ran. 0=no process"]
    pub otherGraphicsPids: [::std::os::raw::c_uint; 16usize],
    #[doc = "!< Maximum amount of GPU memory that was used in bytes"]
    pub maxGpuMemoryUsed: ::std::os::raw::c_longlong,
    #[doc = "!< Number of microseconds we were at reduced clocks due to power violation"]
    pub powerViolationTime: ::std::os::raw::c_longlong,
    #[doc = "!< Number of microseconds we were at reduced clocks due to thermal violation"]
    pub thermalViolationTime: ::std::os::raw::c_longlong,
    #[doc = "!< Amount of microseconds we were at reduced clocks\n!< due to the reliability limit"]
    pub reliabilityViolationTime: ::std::os::raw::c_longlong,
    #[doc = "!< Amount of microseconds we were at reduced clocks due to being at the\n!< board's max voltage"]
    pub boardLimitViolationTime: ::std::os::raw::c_longlong,
    #[doc = "!< Amount of microseconds we were at reduced clocks due to low utilization"]
    pub lowUtilizationTime: ::std::os::raw::c_longlong,
    #[doc = "!< Amount of microseconds we were at reduced clocks due to sync boost"]
    pub syncBoostTime: ::std::os::raw::c_longlong,
    #[doc = "!< The overall health of the system. \\ref dcgmHealthWatchResults_t"]
    pub overallHealth: dcgmHealthWatchResults_t,
    pub incidentCount: ::std::os::raw::c_uint,
    pub systems: [dcgmPidSingleInfo_t__bindgen_ty_1; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmPidSingleInfo_t__bindgen_ty_1 {
    #[doc = "!< system to which this information belongs"]
    pub system: dcgmHealthSystems_t,
    #[doc = "!< health of the specified system on this GPU"]
    pub health: dcgmHealthWatchResults_t,
}
#[doc = " To store process statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmPidInfo_v2 {
    #[doc = "!< Version of this message  (dcgmPidInfo_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< PID of the process"]
    pub pid: ::std::os::raw::c_uint,
    pub unused: ::std::os::raw::c_uint,
    #[doc = "!< Number of GPUs that are valid in GPUs"]
    pub numGpus: ::std::os::raw::c_int,
    #[doc = "!< Summary information for all GPUs listed in gpus[]"]
    pub summary: dcgmPidSingleInfo_t,
    #[doc = "!< Per-GPU information for this PID"]
    pub gpus: [dcgmPidSingleInfo_t; 32usize],
}
#[doc = " Typedef for \\ref dcgmPidInfo_v2"]
pub type dcgmPidInfo_t = dcgmPidInfo_v2;
#[doc = " Info corresponding to the job on a GPU"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmGpuUsageInfo_t {
    #[doc = "!< ID of the GPU this pertains to. GPU_ID_INVALID = summary information for multiple GPUs"]
    pub gpuId: ::std::os::raw::c_uint,
    #[doc = "!< Energy consumed in milli-watt/seconds"]
    pub energyConsumed: ::std::os::raw::c_longlong,
    #[doc = "!< Power usage Min/Max/Avg in watts"]
    pub powerUsage: dcgmStatSummaryFp64_t,
    #[doc = "!< PCI-E bytes read from the GPU"]
    pub pcieRxBandwidth: dcgmStatSummaryInt64_t,
    #[doc = "!< PCI-E bytes written to the GPU"]
    pub pcieTxBandwidth: dcgmStatSummaryInt64_t,
    #[doc = "!< Count of PCI-E replays that occurred"]
    pub pcieReplays: ::std::os::raw::c_longlong,
    #[doc = "!< User provided job start time in microseconds since 1970"]
    pub startTime: ::std::os::raw::c_longlong,
    #[doc = "!< User provided job end time in microseconds since 1970"]
    pub endTime: ::std::os::raw::c_longlong,
    #[doc = "!< GPU SM Utilization in percent"]
    pub smUtilization: dcgmStatSummaryInt32_t,
    #[doc = "!< GPU Memory Utilization in percent"]
    pub memoryUtilization: dcgmStatSummaryInt32_t,
    #[doc = "!< Deprecated - Count of ECC single bit errors that occurred"]
    pub eccSingleBit: ::std::os::raw::c_uint,
    #[doc = "!< Count of ECC double bit errors that occurred"]
    pub eccDoubleBit: ::std::os::raw::c_uint,
    #[doc = "!< Memory clock in MHz"]
    pub memoryClock: dcgmStatSummaryInt32_t,
    #[doc = "!< SM clock in MHz"]
    pub smClock: dcgmStatSummaryInt32_t,
    #[doc = "!< Number of valid entries in xidCriticalErrorsTs"]
    pub numXidCriticalErrors: ::std::os::raw::c_int,
    #[doc = "!< Timestamps of the critical XID errors that occurred"]
    pub xidCriticalErrorsTs: [::std::os::raw::c_longlong; 10usize],
    #[doc = "!< Count of computePids entries that are valid"]
    pub numComputePids: ::std::os::raw::c_int,
    #[doc = "!< List of compute processes that ran during the job\n!< 0=no process"]
    pub computePidInfo: [dcgmProcessUtilInfo_t; 16usize],
    #[doc = "!< Count of graphicsPids entries that are valid"]
    pub numGraphicsPids: ::std::os::raw::c_int,
    #[doc = "!< List of compute processes that ran during the job\n!< 0=no process"]
    pub graphicsPidInfo: [dcgmProcessUtilInfo_t; 16usize],
    #[doc = "!< Maximum amount of GPU memory that was used in bytes"]
    pub maxGpuMemoryUsed: ::std::os::raw::c_longlong,
    #[doc = "!< Number of microseconds we were at reduced clocks due to power violation"]
    pub powerViolationTime: ::std::os::raw::c_longlong,
    #[doc = "!< Number of microseconds we were at reduced clocks due to thermal violation"]
    pub thermalViolationTime: ::std::os::raw::c_longlong,
    #[doc = "!< Amount of microseconds we were at reduced clocks\n!< due to the reliability limit"]
    pub reliabilityViolationTime: ::std::os::raw::c_longlong,
    #[doc = "!< Amount of microseconds we were at reduced clocks\n!< due to being at the board's max voltage"]
    pub boardLimitViolationTime: ::std::os::raw::c_longlong,
    #[doc = "!< Amount of microseconds we were at reduced clocks due to low utilization"]
    pub lowUtilizationTime: ::std::os::raw::c_longlong,
    #[doc = "!< Amount of microseconds we were at reduced clocks due to sync boost"]
    pub syncBoostTime: ::std::os::raw::c_longlong,
    #[doc = "!< The overall health of the system. \\ref dcgmHealthWatchResults_t"]
    pub overallHealth: dcgmHealthWatchResults_t,
    pub incidentCount: ::std::os::raw::c_uint,
    pub systems: [dcgmGpuUsageInfo_t__bindgen_ty_1; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmGpuUsageInfo_t__bindgen_ty_1 {
    #[doc = "!< system to which this information belongs"]
    pub system: dcgmHealthSystems_t,
    #[doc = "!< health of the specified system on this GPU"]
    pub health: dcgmHealthWatchResults_t,
}
#[doc = " To store job statistics\n The following fields are not applicable in the summary info:\n - pcieRxBandwidth (Min/Max)\n - pcieTxBandwidth (Min/Max)\n - smUtilization (Min/Max)\n - memoryUtilization (Min/Max)\n - memoryClock (Min/Max)\n - smClock (Min/Max)\n - processSamples\n\n The average value in the above fields (in the summary) is the\n average of the averages of respective fields from all GPUs"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmJobInfo_v3 {
    #[doc = "!< Version of this message  (dcgmPidInfo_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Number of GPUs that are valid in gpus[]"]
    pub numGpus: ::std::os::raw::c_int,
    #[doc = "!< Summary information for all GPUs listed in gpus[]"]
    pub summary: dcgmGpuUsageInfo_t,
    #[doc = "!< Per-GPU information for this PID"]
    pub gpus: [dcgmGpuUsageInfo_t; 32usize],
}
#[doc = " Typedef for \\ref dcgmJobInfo_v3"]
pub type dcgmJobInfo_t = dcgmJobInfo_v3;
#[doc = " Running process information for a compute or graphics process"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmRunningProcess_v1 {
    #[doc = "!< Version of this message (dcgmRunningProcess_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< PID of the process"]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< GPU memory used by this process in bytes."]
    pub memoryUsed: ::std::os::raw::c_ulonglong,
}
#[doc = " Typedef for \\ref dcgmRunningProcess_v1"]
pub type dcgmRunningProcess_t = dcgmRunningProcess_v1;
#[doc = "!< Uninitialized"]
pub const dcgmDiagnosticLevel_t_DCGM_DIAG_LVL_INVALID: dcgmDiagnosticLevel_t = 0;
#[doc = "!< run a very basic health check on the system"]
pub const dcgmDiagnosticLevel_t_DCGM_DIAG_LVL_SHORT: dcgmDiagnosticLevel_t = 10;
#[doc = "!< run a medium-length diagnostic (a few minutes)"]
pub const dcgmDiagnosticLevel_t_DCGM_DIAG_LVL_MED: dcgmDiagnosticLevel_t = 20;
#[doc = "!< run a extensive diagnostic (several minutes)"]
pub const dcgmDiagnosticLevel_t_DCGM_DIAG_LVL_LONG: dcgmDiagnosticLevel_t = 30;
#[doc = "!< run a very extensive diagnostic (many minutes)"]
pub const dcgmDiagnosticLevel_t_DCGM_DIAG_LVL_XLONG: dcgmDiagnosticLevel_t = 40;
#[doc = " Enumeration for diagnostic levels"]
pub type dcgmDiagnosticLevel_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagTestResult_v2 {
    #[doc = "!< The result of the test"]
    pub status: dcgmDiagResult_t,
    #[doc = "!< The error message and error code, if any"]
    pub error: dcgmDiagErrorDetail_t,
    #[doc = "!< Information details returned from the test, if any"]
    pub info: [::std::os::raw::c_char; 1024usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagTestResult_v3 {
    #[doc = "!< The result of the test"]
    pub status: dcgmDiagResult_t,
    #[doc = "!< The error message and error code, if any"]
    pub error: [dcgmDiagErrorDetail_v2; 5usize],
    #[doc = "!< Information details returned from the test, if any"]
    pub info: [::std::os::raw::c_char; 512usize],
}
#[doc = "!< Memory test index"]
pub const dcgmPerGpuTestIndices_enum_DCGM_MEMORY_INDEX: dcgmPerGpuTestIndices_enum = 0;
#[doc = "!< Diagnostic test index"]
pub const dcgmPerGpuTestIndices_enum_DCGM_DIAGNOSTIC_INDEX: dcgmPerGpuTestIndices_enum = 1;
#[doc = "!< PCIe test index"]
pub const dcgmPerGpuTestIndices_enum_DCGM_PCI_INDEX: dcgmPerGpuTestIndices_enum = 2;
#[doc = "!< SM Stress test index"]
pub const dcgmPerGpuTestIndices_enum_DCGM_SM_STRESS_INDEX: dcgmPerGpuTestIndices_enum = 3;
#[doc = "!< Targeted Stress test index"]
pub const dcgmPerGpuTestIndices_enum_DCGM_TARGETED_STRESS_INDEX: dcgmPerGpuTestIndices_enum = 4;
#[doc = "!< Targeted Power test index"]
pub const dcgmPerGpuTestIndices_enum_DCGM_TARGETED_POWER_INDEX: dcgmPerGpuTestIndices_enum = 5;
#[doc = "!< Memory bandwidth test index"]
pub const dcgmPerGpuTestIndices_enum_DCGM_MEMORY_BANDWIDTH_INDEX: dcgmPerGpuTestIndices_enum = 6;
#[doc = "!< Memtest test index"]
pub const dcgmPerGpuTestIndices_enum_DCGM_MEMTEST_INDEX: dcgmPerGpuTestIndices_enum = 7;
#[doc = "!< Pulse test index"]
pub const dcgmPerGpuTestIndices_enum_DCGM_PULSE_TEST_INDEX: dcgmPerGpuTestIndices_enum = 8;
#[doc = "!< EUD test index"]
pub const dcgmPerGpuTestIndices_enum_DCGM_EUD_TEST_INDEX: dcgmPerGpuTestIndices_enum = 9;
#[doc = "!< NVBandwidth index"]
pub const dcgmPerGpuTestIndices_enum_DCGM_NVBANDWIDTH_INDEX: dcgmPerGpuTestIndices_enum = 10;
pub const dcgmPerGpuTestIndices_enum_DCGM_UNUSED2_TEST_INDEX: dcgmPerGpuTestIndices_enum = 11;
pub const dcgmPerGpuTestIndices_enum_DCGM_UNUSED3_TEST_INDEX: dcgmPerGpuTestIndices_enum = 12;
pub const dcgmPerGpuTestIndices_enum_DCGM_UNUSED4_TEST_INDEX: dcgmPerGpuTestIndices_enum = 13;
pub const dcgmPerGpuTestIndices_enum_DCGM_UNUSED5_TEST_INDEX: dcgmPerGpuTestIndices_enum = 14;
#[doc = "!< Software test index"]
pub const dcgmPerGpuTestIndices_enum_DCGM_SOFTWARE_INDEX: dcgmPerGpuTestIndices_enum = 15;
#[doc = "!< Context create test index"]
pub const dcgmPerGpuTestIndices_enum_DCGM_CONTEXT_CREATE_INDEX: dcgmPerGpuTestIndices_enum = 16;
#[doc = "!< Unknown test"]
pub const dcgmPerGpuTestIndices_enum_DCGM_UNKNOWN_INDEX: dcgmPerGpuTestIndices_enum = 17;
#[doc = " Diagnostic per gpu tests - fixed indices for dcgmDiagResponsePerGpu_t.results[]"]
pub type dcgmPerGpuTestIndices_enum = ::std::os::raw::c_uint;
#[doc = " Diagnostic per gpu tests - fixed indices for dcgmDiagResponsePerGpu_t.results[]"]
pub use self::dcgmPerGpuTestIndices_enum as dcgmPerGpuTestIndices_t;
#[doc = " Per GPU diagnostics result structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagResponsePerGpu_v4 {
    #[doc = "!< ID for the GPU this information pertains"]
    pub gpuId: ::std::os::raw::c_uint,
    #[doc = "!< Per GPU hardware diagnostic test return code"]
    pub hwDiagnosticReturn: ::std::os::raw::c_uint,
    #[doc = "!< Array with a result for each per-gpu test"]
    pub results: [dcgmDiagTestResult_v2; 13usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagResponsePerGpu_v5 {
    #[doc = "!< ID for the GPU this information pertains"]
    pub gpuId: ::std::os::raw::c_uint,
    #[doc = "!< Per GPU hardware diagnostic test return code"]
    pub hwDiagnosticReturn: ::std::os::raw::c_uint,
    #[doc = "!< Array with a result for each per-gpu test"]
    pub results: [dcgmDiagTestResult_v3; 13usize],
}
#[doc = " Per gpu response structure v3\n\n Since DCGM 2.4"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagResponsePerGpu_v3 {
    #[doc = "!< ID for the GPU this information pertains"]
    pub gpuId: ::std::os::raw::c_uint,
    #[doc = "!< Per GPU hardware diagnostic test return code"]
    pub hwDiagnosticReturn: ::std::os::raw::c_uint,
    #[doc = "!< Array with a result for each per-gpu test"]
    pub results: [dcgmDiagTestResult_v2; 9usize],
}
#[doc = "!< test for presence of drivers on the denylist (e.g. nouveau)"]
pub const dcgmSoftwareTest_enum_DCGM_SWTEST_DENYLIST: dcgmSoftwareTest_enum = 0;
#[doc = "!< test for presence (and version) of NVML lib"]
pub const dcgmSoftwareTest_enum_DCGM_SWTEST_NVML_LIBRARY: dcgmSoftwareTest_enum = 1;
#[doc = "!< test for presence (and version) of CUDA lib"]
pub const dcgmSoftwareTest_enum_DCGM_SWTEST_CUDA_MAIN_LIBRARY: dcgmSoftwareTest_enum = 2;
#[doc = "!< test for presence (and version) of CUDA RT lib"]
pub const dcgmSoftwareTest_enum_DCGM_SWTEST_CUDA_RUNTIME_LIBRARY: dcgmSoftwareTest_enum = 3;
#[doc = "!< test for character device permissions"]
pub const dcgmSoftwareTest_enum_DCGM_SWTEST_PERMISSIONS: dcgmSoftwareTest_enum = 4;
#[doc = "!< test for persistence mode enabled"]
pub const dcgmSoftwareTest_enum_DCGM_SWTEST_PERSISTENCE_MODE: dcgmSoftwareTest_enum = 5;
#[doc = "!< test for CUDA environment vars that may slow tests"]
pub const dcgmSoftwareTest_enum_DCGM_SWTEST_ENVIRONMENT: dcgmSoftwareTest_enum = 6;
#[doc = "!< test for pending frame buffer page retirement"]
pub const dcgmSoftwareTest_enum_DCGM_SWTEST_PAGE_RETIREMENT: dcgmSoftwareTest_enum = 7;
#[doc = "!< test for graphics processes running"]
pub const dcgmSoftwareTest_enum_DCGM_SWTEST_GRAPHICS_PROCESSES: dcgmSoftwareTest_enum = 8;
#[doc = "!< test for inforom corruption"]
pub const dcgmSoftwareTest_enum_DCGM_SWTEST_INFOROM: dcgmSoftwareTest_enum = 9;
#[doc = "!< test for running Fabric Manager"]
pub const dcgmSoftwareTest_enum_DCGM_SWTEST_FABRIC_MANAGER: dcgmSoftwareTest_enum = 10;
pub type dcgmSoftwareTest_enum = ::std::os::raw::c_uint;
pub use self::dcgmSoftwareTest_enum as dcgmSoftwareTest_t;
#[doc = " Global diagnostics result structure v11\n\n Since DCGM 4.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagResponse_v11 {
    #[doc = "!< version number (dcgmDiagResponse_v11)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Number of tests included in this response."]
    pub numTests: ::std::os::raw::c_uchar,
    #[doc = "!< Number of errors included in this response."]
    pub numErrors: ::std::os::raw::c_uchar,
    #[doc = "!< Number of info msgs included in this response."]
    pub numInfo: ::std::os::raw::c_uchar,
    #[doc = "!< Number of categories included in this response."]
    pub numCategories: ::std::os::raw::c_uchar,
    #[doc = "!< Number of entities included with this response."]
    pub numEntities: ::std::os::raw::c_ushort,
    #[doc = "!< Number of results included in this response."]
    pub numResults: ::std::os::raw::c_ushort,
    #[doc = "!< Test run information for each relevant test."]
    pub tests: [dcgmDiagTestRun_v1; 20usize],
    #[doc = "!< Per-entity details."]
    pub entities: [dcgmDiagEntity_v1; 1024usize],
    #[doc = "!< Per-entity errors."]
    pub errors: [dcgmDiagError_v1; 32usize],
    #[doc = "!< Per-entity info messages."]
    pub info: [dcgmDiagInfo_v1; 16usize],
    #[doc = "!< Per-entity result."]
    pub results: [dcgmDiagEntityResult_v1; 20480usize],
    #[doc = "!< List of plugin categories."]
    pub categories: [[::std::os::raw::c_char; 20usize]; 5usize],
    #[doc = "!< A string representing DCGM's version"]
    pub dcgmVersion: [::std::os::raw::c_char; 12usize],
    #[doc = "!< A string representing the driver version"]
    pub driverVersion: [::std::os::raw::c_char; 256usize],
    #[doc = "!< Needed for binary compatibility with v10 and earlier."]
    pub _unused: [::std::os::raw::c_char; 682880usize],
}
#[doc = " Global diagnostics result structure v10\n\n Since DCGM 3.3.7"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagResponse_v10 {
    #[doc = "!< version number (dcgmDiagResponse_v10)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< number of valid per GPU results"]
    pub gpuCount: ::std::os::raw::c_uint,
    #[doc = "!< number of valid levelOne results"]
    pub levelOneTestCount: ::std::os::raw::c_uint,
    #[doc = "!< Basic, system-wide test results."]
    pub levelOneResults: [dcgmDiagTestResult_v3; 16usize],
    #[doc = "!< per GPU test results"]
    pub perGpuResponses: [dcgmDiagResponsePerGpu_v5; 32usize],
    #[doc = "!< System-wide error reported from NVVS"]
    pub systemError: dcgmDiagErrorDetail_v2,
    #[doc = "!< The SKU device id for each GPU"]
    pub devIds: [[::std::os::raw::c_char; 5usize]; 32usize],
    #[doc = "!< Serial for the device"]
    pub devSerials: [[::std::os::raw::c_char; 256usize]; 32usize],
    #[doc = "!< A string representing DCGM's version"]
    pub dcgmVersion: [::std::os::raw::c_char; 12usize],
    #[doc = "!< A string representing the driver version"]
    pub driverVersion: [::std::os::raw::c_char; 256usize],
    #[doc = "!< Aux data that each test returned."]
    pub auxDataPerTest: [dcgmDiagTestAuxData_v1; 13usize],
}
#[doc = " Global diagnostics result structure v9\n\n Since DCGM 3.3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagResponse_v9 {
    #[doc = "!< version number (dcgmDiagResult_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< number of valid per GPU results"]
    pub gpuCount: ::std::os::raw::c_uint,
    #[doc = "!< number of valid levelOne results"]
    pub levelOneTestCount: ::std::os::raw::c_uint,
    #[doc = "!< Basic, system-wide test results."]
    pub levelOneResults: [dcgmDiagTestResult_v3; 16usize],
    #[doc = "!< per GPU test results"]
    pub perGpuResponses: [dcgmDiagResponsePerGpu_v5; 32usize],
    #[doc = "!< System-wide error reported from NVVS"]
    pub systemError: dcgmDiagErrorDetail_v2,
    #[doc = "!< The SKU device id for each GPU"]
    pub devIds: [[::std::os::raw::c_char; 5usize]; 32usize],
    #[doc = "!< Serial for the device"]
    pub devSerials: [[::std::os::raw::c_char; 256usize]; 32usize],
    #[doc = "!< A string representing DCGM's version"]
    pub dcgmVersion: [::std::os::raw::c_char; 12usize],
    #[doc = "!< A string representing the driver version"]
    pub driverVersion: [::std::os::raw::c_char; 256usize],
    #[doc = "!< No longer used"]
    pub _unused: [::std::os::raw::c_char; 596usize],
}
#[doc = " Global diagnostics result structure v8\n\n Since DCGM 3.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagResponse_v8 {
    #[doc = "!< version number (dcgmDiagResult_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< number of valid per GPU results"]
    pub gpuCount: ::std::os::raw::c_uint,
    #[doc = "!< number of valid levelOne results"]
    pub levelOneTestCount: ::std::os::raw::c_uint,
    #[doc = "!< Basic, system-wide test results."]
    pub levelOneResults: [dcgmDiagTestResult_v2; 16usize],
    #[doc = "!< per GPU test results"]
    pub perGpuResponses: [dcgmDiagResponsePerGpu_v4; 32usize],
    #[doc = "!< System-wide error reported from NVVS"]
    pub systemError: dcgmDiagErrorDetail_t,
    #[doc = "!< The SKU device id for each GPU"]
    pub devIds: [[::std::os::raw::c_char; 5usize]; 32usize],
    #[doc = "!< A string representing DCGM's version"]
    pub dcgmVersion: [::std::os::raw::c_char; 12usize],
    #[doc = "!< A string representing the driver version"]
    pub driverVersion: [::std::os::raw::c_char; 256usize],
    #[doc = "!< No longer used"]
    pub _unused: [::std::os::raw::c_char; 596usize],
}
#[doc = " Global diagnostics result structure v7\n\n Since DCGM 2.4"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagResponse_v7 {
    #[doc = "!< version number (dcgmDiagResult_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< number of valid per GPU results"]
    pub gpuCount: ::std::os::raw::c_uint,
    #[doc = "!< number of valid levelOne results"]
    pub levelOneTestCount: ::std::os::raw::c_uint,
    #[doc = "!< Basic, system-wide test results."]
    pub levelOneResults: [dcgmDiagTestResult_v2; 16usize],
    #[doc = "!< per GPU test results"]
    pub perGpuResponses: [dcgmDiagResponsePerGpu_v3; 32usize],
    #[doc = "!< System-wide error reported from NVVS"]
    pub systemError: dcgmDiagErrorDetail_t,
    #[doc = "!< No longer used"]
    pub _unused: [::std::os::raw::c_char; 1024usize],
}
#[doc = " Typedef for \\ref dcgmDiagResponse_v11"]
pub type dcgmDiagResponse_t = dcgmDiagResponse_v11;
#[doc = " Diagnostics live status structure v1\n\n Since DCGM 4.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDiagStatus_v1 {
    #[doc = "!< The version of this struct"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< The number of tests that will execute"]
    pub totalTests: ::std::os::raw::c_uint,
    #[doc = "!< The number of tests that have completed."]
    pub completedTests: ::std::os::raw::c_uint,
    #[doc = "!< The last completed test's name"]
    pub testName: [::std::os::raw::c_char; 128usize],
    #[doc = "!< The last completed test's first error code -\n!< DCGM_FR_OK for success, otherwise DCGM_FR_*."]
    pub errorCode: ::std::os::raw::c_uint,
}
#[doc = " Diagnostics live status structure v1\n\n Since DCGM 4.0"]
pub type dcgmDiagStatus_t = dcgmDiagStatus_v1;
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_UNINITIALIZED: dcgmGpuLevel_enum = 0;
#[doc = "!< multi-GPU board"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_BOARD: dcgmGpuLevel_enum = 1;
#[doc = "!< all devices that only need traverse a single PCIe switch"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_SINGLE: dcgmGpuLevel_enum = 2;
#[doc = "!< all devices that need not traverse a host bridge"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_MULTIPLE: dcgmGpuLevel_enum = 4;
#[doc = "!< all devices that are connected to the same host bridge"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_HOSTBRIDGE: dcgmGpuLevel_enum = 8;
#[doc = "!< all devices that are connected to the same CPU but possibly multiple host bridges"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_CPU: dcgmGpuLevel_enum = 16;
#[doc = "!< all devices in the system"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_SYSTEM: dcgmGpuLevel_enum = 32;
#[doc = "!< GPUs connected via a single NVLINK link"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK1: dcgmGpuLevel_enum = 256;
#[doc = "!< GPUs connected via two NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK2: dcgmGpuLevel_enum = 512;
#[doc = "!< GPUs connected via three NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK3: dcgmGpuLevel_enum = 1024;
#[doc = "!< GPUs connected via four NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK4: dcgmGpuLevel_enum = 2048;
#[doc = "!< GPUs connected via five NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK5: dcgmGpuLevel_enum = 4096;
#[doc = "!< GPUs connected via six NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK6: dcgmGpuLevel_enum = 8192;
#[doc = "!< GPUs connected via seven NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK7: dcgmGpuLevel_enum = 16384;
#[doc = "!< GPUs connected via eight NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK8: dcgmGpuLevel_enum = 32768;
#[doc = "!< GPUs connected via nine NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK9: dcgmGpuLevel_enum = 65536;
#[doc = "!< GPUs connected via ten NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK10: dcgmGpuLevel_enum = 131072;
#[doc = "!< GPUs connected via eleven NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK11: dcgmGpuLevel_enum = 262144;
#[doc = "!< GPUs connected via twelve NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK12: dcgmGpuLevel_enum = 524288;
#[doc = "!< GPUs connected via twelve NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK13: dcgmGpuLevel_enum = 1048576;
#[doc = "!< GPUs connected via twelve NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK14: dcgmGpuLevel_enum = 2097152;
#[doc = "!< GPUs connected via twelve NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK15: dcgmGpuLevel_enum = 4194304;
#[doc = "!< GPUs connected via twelve NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK16: dcgmGpuLevel_enum = 8388608;
#[doc = "!< GPUs connected via twelve NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK17: dcgmGpuLevel_enum = 16777216;
#[doc = "!< GPUs connected via twelve NVLINK links"]
pub const dcgmGpuLevel_enum_DCGM_TOPOLOGY_NVLINK18: dcgmGpuLevel_enum = 33554432;
#[doc = " Represents level relationships within a system between two GPUs\n The enums are spaced to allow for future relationships.\n These match the definitions in nvml.h"]
pub type dcgmGpuLevel_enum = ::std::os::raw::c_uint;
#[doc = " Represents level relationships within a system between two GPUs\n The enums are spaced to allow for future relationships.\n These match the definitions in nvml.h"]
pub use self::dcgmGpuLevel_enum as dcgmGpuTopologyLevel_t;
#[doc = " Device topology information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceTopology_v1 {
    #[doc = "!< version number (dcgmDeviceTopology_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< affinity mask for the specified GPU\n!< a 1 represents affinity to the CPU in that\n!< bit position supports up to 256 cores"]
    pub cpuAffinityMask: [::std::os::raw::c_ulong; 8usize],
    #[doc = "!< number of valid entries in gpuPaths"]
    pub numGpus: ::std::os::raw::c_uint,
    pub gpuPaths: [dcgmDeviceTopology_v1__bindgen_ty_1; 31usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmDeviceTopology_v1__bindgen_ty_1 {
    #[doc = "!< gpuId to which the path represents"]
    pub gpuId: ::std::os::raw::c_uint,
    #[doc = "!< path to the gpuId from this GPU. Note that this is a bit-mask\n!< of DCGM_TOPOLOGY_* values and can contain both PCIe topology\n!< and NvLink topology where applicable. For instance:\n!< 0x210 = DCGM_TOPOLOGY_CPU | DCGM_TOPOLOGY_NVLINK2\n!< Use the macros DCGM_TOPOLOGY_PATH_NVLINK and\n!< DCGM_TOPOLOGY_PATH_PCI to mask the NvLink and PCI paths, respectively."]
    pub path: dcgmGpuTopologyLevel_t,
    #[doc = "!< bits representing the local links connected to gpuId\n!< e.g. if this field == 3, links 0 and 1 are connected,\n!< field is only valid if NVLINKS actually exist between GPUs"]
    pub localNvLinkIds: ::std::os::raw::c_uint,
}
#[doc = " Typedef for \\ref dcgmDeviceTopology_v1"]
pub type dcgmDeviceTopology_t = dcgmDeviceTopology_v1;
#[doc = " Group topology information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmGroupTopology_v1 {
    #[doc = "!< version number (dcgmGroupTopology_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< the CPU affinity mask for all GPUs in the group\n!< a 1 represents affinity to the CPU in that bit\n!< position supports up to 256 cores"]
    pub groupCpuAffinityMask: [::std::os::raw::c_ulong; 8usize],
    #[doc = "!< a zero value indicates that 1 or more GPUs\n!< in the group have a different CPU affinity and thus\n!< may not be optimal for certain algorithms"]
    pub numaOptimalFlag: ::std::os::raw::c_uint,
    #[doc = "!< the slowest path amongst GPUs in the group"]
    pub slowestPath: dcgmGpuTopologyLevel_t,
}
#[doc = " Typedef for \\ref dcgmGroupTopology_v1"]
pub type dcgmGroupTopology_t = dcgmGroupTopology_v1;
#[doc = " DCGM Memory usage information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmIntrospectMemory_v1 {
    #[doc = "!< version number (dcgmIntrospectMemory_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< number of bytes"]
    pub bytesUsed: ::std::os::raw::c_longlong,
}
#[doc = " Typedef for \\ref dcgmIntrospectMemory_t"]
pub type dcgmIntrospectMemory_t = dcgmIntrospectMemory_v1;
#[doc = " DCGM CPU Utilization information.  Multiply values by 100 to get them in %."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmIntrospectCpuUtil_v1 {
    #[doc = "!< version number (dcgmMetadataCpuUtil_version)"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< fraction of device's CPU resources that were used"]
    pub total: f64,
    #[doc = "!< fraction of device's CPU resources that were used in kernel mode"]
    pub kernel: f64,
    #[doc = "!< fraction of device's CPU resources that were used in user mode"]
    pub user: f64,
}
#[doc = " Typedef for \\ref dcgmIntrospectCpuUtil_t"]
pub type dcgmIntrospectCpuUtil_t = dcgmIntrospectCpuUtil_v1;
#[doc = " @}"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmRunDiag_v7 {
    #[doc = "!< version of this message"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< flags specifying binary options for running it. See DCGM_RUN_FLAGS_*"]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "!< 0-5 for the debug level the GPU diagnostic will use for logging."]
    pub debugLevel: ::std::os::raw::c_uint,
    #[doc = "!< group of GPUs to verify. Cannot be specified together with gpuList."]
    pub groupId: dcgmGpuGrp_t,
    #[doc = "!< 0-3 for which tests to run. Optional."]
    pub validate: dcgmPolicyValidation_t,
    #[doc = "!< Specified list of test names. Optional."]
    pub testNames: [[::std::os::raw::c_char; 50usize]; 20usize],
    #[doc = "!< Parameters to set for specified tests\n!< in the format:\n!< testName.parameterName=parameterValue. Optional."]
    pub testParms: [[::std::os::raw::c_char; 100usize]; 100usize],
    #[doc = "!< Comma-separated list of GPUs. Cannot be specified with the groupId."]
    pub fakeGpuList: [::std::os::raw::c_char; 50usize],
    #[doc = "!< Comma-separated list of GPUs. Cannot be specified with the groupId."]
    pub gpuList: [::std::os::raw::c_char; 50usize],
    #[doc = "!< Alternate name for the debug log file that should be used"]
    pub debugLogFile: [::std::os::raw::c_char; 128usize],
    #[doc = "!< Path that the plugin's statistics files should be written to"]
    pub statsPath: [::std::os::raw::c_char; 128usize],
    #[doc = "!< Contents of nvvs config file (likely yaml)"]
    pub configFileContents: [::std::os::raw::c_char; 10000usize],
    #[doc = "!< Clocks event reasons to ignore as either integer mask\n!<  or csv list of reasons"]
    pub clocksEventMask: [::std::os::raw::c_char; 50usize],
    #[doc = "!< Custom path to the diagnostic plugins - No longer supported as of 2.2.9"]
    pub pluginPath: [::std::os::raw::c_char; 128usize],
    #[doc = "!< The current iteration that will be executed"]
    pub currentIteration: ::std::os::raw::c_uint,
    #[doc = "!< The total iterations that will be executed"]
    pub totalIterations: ::std::os::raw::c_uint,
    #[doc = "!< The timeout for the diagnostic in seconds"]
    pub timeoutSeconds: ::std::os::raw::c_uint,
    #[doc = "!< No longer used"]
    pub _unusedBuf: [::std::os::raw::c_char; 128usize],
    #[doc = "!< How often the fail early checks should occur when enabled."]
    pub failCheckInterval: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmRunDiag_v8 {
    #[doc = "!< version of this message"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< flags specifying binary options for running it. See DCGM_RUN_FLAGS_*"]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "!< 0-5 for the debug level the GPU diagnostic will use for logging."]
    pub debugLevel: ::std::os::raw::c_uint,
    #[doc = "!< group of GPUs to verify. Cannot be specified together with gpuList."]
    pub groupId: dcgmGpuGrp_t,
    #[doc = "!< 0-3 for which tests to run. Optional."]
    pub validate: dcgmPolicyValidation_t,
    #[doc = "!< Specified list of test names. Optional."]
    pub testNames: [[::std::os::raw::c_char; 50usize]; 20usize],
    pub testParms: [[::std::os::raw::c_char; 1050usize]; 100usize],
    #[doc = "!< Comma-separated list of GPUs. Cannot be specified with the groupId."]
    pub fakeGpuList: [::std::os::raw::c_char; 50usize],
    #[doc = "!< Comma-separated list of GPUs. Cannot be specified with the groupId."]
    pub gpuList: [::std::os::raw::c_char; 50usize],
    #[doc = "!< Alternate name for the debug log file that should be used"]
    pub debugLogFile: [::std::os::raw::c_char; 128usize],
    #[doc = "!< Path that the plugin's statistics files should be written to"]
    pub statsPath: [::std::os::raw::c_char; 128usize],
    #[doc = "!< Contents of nvvs config file (likely yaml)"]
    pub configFileContents: [::std::os::raw::c_char; 10000usize],
    #[doc = "!< Clocks event reasons to ignore as either integer mask\n!<  or csv list of reasons"]
    pub clocksEventMask: [::std::os::raw::c_char; 50usize],
    #[doc = "!< Custom path to the diagnostic plugins - No longer supported as of 2.2.9"]
    pub pluginPath: [::std::os::raw::c_char; 128usize],
    #[doc = "!< The current iteration that will be executed"]
    pub currentIteration: ::std::os::raw::c_uint,
    #[doc = "!< The total iterations that will be executed"]
    pub totalIterations: ::std::os::raw::c_uint,
    #[doc = "!< The timeout for the diagnostic in seconds"]
    pub timeoutSeconds: ::std::os::raw::c_uint,
    #[doc = "!< No longer used"]
    pub _unusedBuf: [::std::os::raw::c_char; 128usize],
    #[doc = "!< How often the fail early checks should occur when enabled."]
    pub failCheckInterval: ::std::os::raw::c_uint,
    #[doc = "!< The expected number of entities the diag will run on."]
    pub expectedNumEntities: [::std::os::raw::c_char; 50usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmRunDiag_v9 {
    #[doc = "!< version of this message"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< flags specifying binary options for running it. See DCGM_RUN_FLAGS_*"]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "!< 0-5 for the debug level the GPU diagnostic will use for logging."]
    pub debugLevel: ::std::os::raw::c_uint,
    #[doc = "!< group of GPUs to verify. Cannot be specified together with entityIds. When entityIds is\n!< specified, this value should be set to DCGM_GROUP_NULL."]
    pub groupId: dcgmGpuGrp_t,
    #[doc = "!< 0-3 for which tests to run. Optional."]
    pub validate: dcgmPolicyValidation_t,
    #[doc = "!< Specified list of test names. Optional."]
    pub testNames: [[::std::os::raw::c_char; 50usize]; 20usize],
    pub testParms: [[::std::os::raw::c_char; 1050usize]; 100usize],
    #[doc = "!< Comma-separated list of GPUs. Cannot be specified with the groupId or\n!< entityIds."]
    pub fakeGpuList: [::std::os::raw::c_char; 50usize],
    #[doc = "!< Alternate name for the debug log file that should be used"]
    pub debugLogFile: [::std::os::raw::c_char; 128usize],
    #[doc = "!< Path that the plugin's statistics files should be written to"]
    pub statsPath: [::std::os::raw::c_char; 128usize],
    #[doc = "!< Contents of nvvs config file (likely yaml)"]
    pub configFileContents: [::std::os::raw::c_char; 10000usize],
    #[doc = "!< Clocks event reasons to ignore as either integer mask or\n!< csv list of reasons"]
    pub clocksEventMask: [::std::os::raw::c_char; 50usize],
    #[doc = "!< Custom path to the diagnostic plugins - No longer supported as of 2.2.9"]
    pub pluginPath: [::std::os::raw::c_char; 128usize],
    #[doc = "!< The current iteration that will be executed"]
    pub currentIteration: ::std::os::raw::c_uint,
    #[doc = "!< The total iterations that will be executed"]
    pub totalIterations: ::std::os::raw::c_uint,
    #[doc = "!< The timeout for the diagnostic in seconds"]
    pub timeoutSeconds: ::std::os::raw::c_uint,
    #[doc = "!< No longer used"]
    pub _unusedBuf: [::std::os::raw::c_char; 128usize],
    #[doc = "!< How often the fail early checks should occur when enabled."]
    pub failCheckInterval: ::std::os::raw::c_uint,
    #[doc = "!< The expected number of entities the diag will run on."]
    pub expectedNumEntities: [::std::os::raw::c_char; 50usize],
    #[doc = "!< Comma-separated list of entity ids. Cannot be specified with the\n!< groupId."]
    pub entityIds: [::std::os::raw::c_char; 2048usize],
    #[doc = "!< The watch frequency for fields being watched"]
    pub watchFrequency: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmRunDiag_v10 {
    #[doc = "!< version of this message"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< flags specifying binary options for running it. See DCGM_RUN_FLAGS_*"]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "!< 0-5 for the debug level the GPU diagnostic will use for logging."]
    pub debugLevel: ::std::os::raw::c_uint,
    #[doc = "!< group of GPUs to verify. Cannot be specified together with entityIds. When entityIds is\n!< specified, this value should be set to DCGM_GROUP_NULL."]
    pub groupId: dcgmGpuGrp_t,
    #[doc = "!< 0-3 for which tests to run. Optional."]
    pub validate: dcgmPolicyValidation_t,
    #[doc = "!< Specified list of test names. Optional."]
    pub testNames: [[::std::os::raw::c_char; 50usize]; 20usize],
    pub testParms: [[::std::os::raw::c_char; 1050usize]; 100usize],
    #[doc = "!< Comma-separated list of GPUs. Cannot be specified with the groupId or\n!< entityIds."]
    pub fakeGpuList: [::std::os::raw::c_char; 50usize],
    #[doc = "!< Alternate name for the debug log file that should be used"]
    pub debugLogFile: [::std::os::raw::c_char; 128usize],
    #[doc = "!< Path that the plugin's statistics files should be written to"]
    pub statsPath: [::std::os::raw::c_char; 128usize],
    #[doc = "!< Contents of nvvs config file (likely yaml)"]
    pub configFileContents: [::std::os::raw::c_char; 10000usize],
    #[doc = "!< Clocks event reasons to ignore as either integer mask or\n!< csv list of reasons"]
    pub clocksEventMask: [::std::os::raw::c_char; 50usize],
    #[doc = "!< Custom path to the diagnostic plugins - No longer supported as of 2.2.9"]
    pub pluginPath: [::std::os::raw::c_char; 128usize],
    #[doc = "!< The current iteration that will be executed"]
    pub currentIteration: ::std::os::raw::c_uint,
    #[doc = "!< The total iterations that will be executed"]
    pub totalIterations: ::std::os::raw::c_uint,
    #[doc = "!< The timeout for the diagnostic in seconds"]
    pub timeoutSeconds: ::std::os::raw::c_uint,
    #[doc = "!< No longer used"]
    pub _unusedBuf: [::std::os::raw::c_char; 128usize],
    #[doc = "!< How often the fail early checks should occur when enabled."]
    pub failCheckInterval: ::std::os::raw::c_uint,
    #[doc = "!< The expected number of entities the diag will run on."]
    pub expectedNumEntities: [::std::os::raw::c_char; 50usize],
    #[doc = "!< Comma-separated list of entity ids. Cannot be specified with the\n!< groupId."]
    pub entityIds: [::std::os::raw::c_char; 2048usize],
    #[doc = "!< The watch frequency for fields being watched"]
    pub watchFrequency: ::std::os::raw::c_uint,
    #[doc = "!< String of error codes to be ignored on different entities"]
    pub ignoreErrorCodes: [::std::os::raw::c_char; 512usize],
}
#[doc = "!< NVLink link recovery error occurred"]
pub const dcgmGpuNVLinkErrorType_enum_DCGM_GPU_NVLINK_ERROR_RECOVERY_REQUIRED:
    dcgmGpuNVLinkErrorType_enum = 1;
#[doc = "!< NVLink link fatal error occurred"]
pub const dcgmGpuNVLinkErrorType_enum_DCGM_GPU_NVLINK_ERROR_FATAL: dcgmGpuNVLinkErrorType_enum = 2;
#[doc = " Identifies a GPU NVLink error type returned by DCGM_FI_DEV_GPU_NVLINK_ERRORS"]
pub type dcgmGpuNVLinkErrorType_enum = ::std::os::raw::c_uint;
#[doc = " Identifies a GPU NVLink error type returned by DCGM_FI_DEV_GPU_NVLINK_ERRORS"]
pub use self::dcgmGpuNVLinkErrorType_enum as dcgmGpuNVLinkErrorType_t;
#[doc = " @}"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmTopoSchedHint_v1 {
    #[doc = "!< version of this message"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< bit-mask of the GPU ids to choose from"]
    pub inputGpuIds: u64,
    #[doc = "!< the number of GPUs that DCGM should choose"]
    pub numGpus: u32,
    #[doc = "!< Hints to ignore certain factors for the scheduling hint"]
    pub hintFlags: u64,
}
#[doc = " @}"]
pub type dcgmTopoSchedHint_t = dcgmTopoSchedHint_v1;
#[doc = "!< NvLink is unsupported by this GPU (Default for GPUs)"]
pub const dcgmNvLinkLinkState_enum_DcgmNvLinkLinkStateNotSupported: dcgmNvLinkLinkState_enum = 0;
#[doc = "!< NvLink is supported for this link but this link is disabled\n!< (Default for NvSwitches)"]
pub const dcgmNvLinkLinkState_enum_DcgmNvLinkLinkStateDisabled: dcgmNvLinkLinkState_enum = 1;
#[doc = "!< This NvLink link is down (inactive)"]
pub const dcgmNvLinkLinkState_enum_DcgmNvLinkLinkStateDown: dcgmNvLinkLinkState_enum = 2;
#[doc = "!< This NvLink link is up (active)"]
pub const dcgmNvLinkLinkState_enum_DcgmNvLinkLinkStateUp: dcgmNvLinkLinkState_enum = 3;
#[doc = " NvLink link states"]
pub type dcgmNvLinkLinkState_enum = ::std::os::raw::c_uint;
#[doc = " NvLink link states"]
pub use self::dcgmNvLinkLinkState_enum as dcgmNvLinkLinkState_t;
#[doc = " State of NvLink links for a GPU"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmNvLinkGpuLinkStatus_v1 {
    #[doc = "!< Entity ID of the GPU (gpuId)"]
    pub entityId: dcgm_field_eid_t,
    #[doc = "!< Per-GPU link states"]
    pub linkState: [dcgmNvLinkLinkState_t; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmNvLinkGpuLinkStatus_v2 {
    #[doc = "!< Entity ID of the GPU (gpuId)"]
    pub entityId: dcgm_field_eid_t,
    #[doc = "!< Per-GPU link states"]
    pub linkState: [dcgmNvLinkLinkState_t; 12usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmNvLinkGpuLinkStatus_v3 {
    #[doc = "!< Entity ID of the GPU (gpuId)"]
    pub entityId: dcgm_field_eid_t,
    #[doc = "!< Per-GPU link states"]
    pub linkState: [dcgmNvLinkLinkState_t; 18usize],
}
#[doc = " State of NvLink links for a NvSwitch"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmNvLinkNvSwitchLinkStatus_t {
    #[doc = "!< Entity ID of the NvSwitch (physicalId)"]
    pub entityId: dcgm_field_eid_t,
    #[doc = "!< Per-NvSwitch link states"]
    pub linkState: [dcgmNvLinkLinkState_t; 256usize],
}
#[doc = " Status of all of the NvLinks in a given system"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmNvLinkStatus_v4 {
    #[doc = "!< Version of this request. Should be dcgmNvLinkStatus_version1"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Number of entries in gpus[] that are populated"]
    pub numGpus: ::std::os::raw::c_uint,
    #[doc = "!< Per-GPU NvLink link statuses"]
    pub gpus: [dcgmNvLinkGpuLinkStatus_v3; 32usize],
    #[doc = "!< Number of entries in nvSwitches[] that are populated"]
    pub numNvSwitches: ::std::os::raw::c_uint,
    #[doc = "!< Per-NvSwitch link statuses"]
    pub nvSwitches: [dcgmNvLinkNvSwitchLinkStatus_t; 12usize],
}
#[doc = " Status of all of the NvLinks in a given system"]
pub type dcgmNvLinkStatus_t = dcgmNvLinkStatus_v4;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dcgmSummaryResponse_t {
    #[doc = "!< type of field that is summarized (int64 or fp64)"]
    pub fieldType: ::std::os::raw::c_uint,
    #[doc = "!< the number of populated summaries in \\ref values"]
    pub summaryCount: ::std::os::raw::c_uint,
    #[doc = "!< array for storing the values of each summary. The summaries are stored\n!< in order. For example, if MIN AND MAX are requested, then 0 will be MIN\n!< and 1 will be MAX. If AVG and DIFF were requested, then AVG would be 0\n!< and 1 would be DIFF"]
    pub values: [dcgmSummaryResponse_t__bindgen_ty_1; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dcgmSummaryResponse_t__bindgen_ty_1 {
    pub i64_: i64,
    pub fp64: f64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dcgmFieldSummaryRequest_v1 {
    #[doc = "!< version of this message - dcgmFieldSummaryRequest_v1"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< field id to be summarized"]
    pub fieldId: ::std::os::raw::c_ushort,
    #[doc = "!< the type of entity whose field we're getting"]
    pub entityGroupId: dcgm_field_entity_group_t,
    #[doc = "!< ordinal id for this entity"]
    pub entityId: dcgm_field_eid_t,
    #[doc = "!< bit-mask of DCGM_SUMMARY_*, the requested summaries"]
    pub summaryTypeMask: u32,
    #[doc = "!< start time for the interval being summarized. 0 means to use\n!< any data before."]
    pub startTime: u64,
    #[doc = "!< end time for the interval being summarized. 0 means to use\n!< any data after."]
    pub endTime: u64,
    #[doc = "!< response data for this request"]
    pub response: dcgmSummaryResponse_t,
}
pub type dcgmFieldSummaryRequest_t = dcgmFieldSummaryRequest_v1;
#[doc = "!< Core DCGM - always loaded"]
pub const dcgmModuleId_t_DcgmModuleIdCore: dcgmModuleId_t = 0;
#[doc = "!< NvSwitch Module"]
pub const dcgmModuleId_t_DcgmModuleIdNvSwitch: dcgmModuleId_t = 1;
#[doc = "!< VGPU Module"]
pub const dcgmModuleId_t_DcgmModuleIdVGPU: dcgmModuleId_t = 2;
#[doc = "!< Introspection Module"]
pub const dcgmModuleId_t_DcgmModuleIdIntrospect: dcgmModuleId_t = 3;
#[doc = "!< Health Module"]
pub const dcgmModuleId_t_DcgmModuleIdHealth: dcgmModuleId_t = 4;
#[doc = "!< Policy Module"]
pub const dcgmModuleId_t_DcgmModuleIdPolicy: dcgmModuleId_t = 5;
#[doc = "!< Config Module"]
pub const dcgmModuleId_t_DcgmModuleIdConfig: dcgmModuleId_t = 6;
#[doc = "!< GPU Diagnostic Module"]
pub const dcgmModuleId_t_DcgmModuleIdDiag: dcgmModuleId_t = 7;
#[doc = "!< Profiling Module"]
pub const dcgmModuleId_t_DcgmModuleIdProfiling: dcgmModuleId_t = 8;
#[doc = "!< System Monitoring Module"]
pub const dcgmModuleId_t_DcgmModuleIdSysmon: dcgmModuleId_t = 9;
#[doc = "!< Always last. 1 greater than largest value above"]
pub const dcgmModuleId_t_DcgmModuleIdCount: dcgmModuleId_t = 10;
#[doc = " Module IDs"]
pub type dcgmModuleId_t = ::std::os::raw::c_uint;
#[doc = "!< Module has not been loaded yet"]
pub const dcgmModuleStatus_t_DcgmModuleStatusNotLoaded: dcgmModuleStatus_t = 0;
#[doc = "!< Module is on the denylist; can't be loaded"]
pub const dcgmModuleStatus_t_DcgmModuleStatusDenylisted: dcgmModuleStatus_t = 1;
#[doc = "!< Loading the module failed"]
pub const dcgmModuleStatus_t_DcgmModuleStatusFailed: dcgmModuleStatus_t = 2;
#[doc = "!< Module has been loaded"]
pub const dcgmModuleStatus_t_DcgmModuleStatusLoaded: dcgmModuleStatus_t = 3;
#[doc = "!< Module has been unloaded, happens during shutdown"]
pub const dcgmModuleStatus_t_DcgmModuleStatusUnloaded: dcgmModuleStatus_t = 4;
#[doc = "< Module has been paused. This is a temporary state that will\nmove to DcgmModuleStatusLoaded once the module is resumed.\nThis status implies that the module is loaded."]
pub const dcgmModuleStatus_t_DcgmModuleStatusPaused: dcgmModuleStatus_t = 5;
#[doc = " Module Status. Modules are lazy loaded, so they will be in status DcgmModuleStatusNotLoaded\n until they are used. One modules are used, they will move to another status."]
pub type dcgmModuleStatus_t = ::std::os::raw::c_uint;
#[doc = " Status of all of the modules of the host engine"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmModuleGetStatusesModule_t {
    #[doc = "!< ID of this module"]
    pub id: dcgmModuleId_t,
    #[doc = "!< Status of this module"]
    pub status: dcgmModuleStatus_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmModuleGetStatuses_v1 {
    #[doc = "!< Version of this request. Should be dcgmModuleGetStatuses_version1"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Number of entries in statuses[] that are populated"]
    pub numStatuses: ::std::os::raw::c_uint,
    #[doc = "!< Per-module status information"]
    pub statuses: [dcgmModuleGetStatusesModule_t; 16usize],
}
pub type dcgmModuleGetStatuses_t = dcgmModuleGetStatuses_v1;
#[doc = " Options for dcgmStartEmbedded_v2\n\n Added in DCGM 2.0.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmStartEmbeddedV2Params_v1 {
    #[doc = "< Version number. Use dcgmStartEmbeddedV2Params_version1"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "< IN: Collect data automatically or manually when asked by the user."]
    pub opMode: dcgmOperationMode_t,
    #[doc = "< OUT: DCGM Handle to use for API calls"]
    pub dcgmHandle: dcgmHandle_t,
    #[doc = "< IN: File that DCGM should log to. NULL = do not log. '-' = stdout"]
    pub logFile: *const ::std::os::raw::c_char,
    #[doc = "< IN: Severity at which DCGM should log to logFile"]
    pub severity: DcgmLoggingSeverity_t,
    #[doc = "< IN: Number of modules in denyList[]"]
    pub denyListCount: ::std::os::raw::c_uint,
    pub denyList: [::std::os::raw::c_uint; 10usize],
}
#[doc = " Options for dcgmStartEmbeddedV2Params_v2\n\n Added in DCGM 2.4.0, renamed members in 3.0.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmStartEmbeddedV2Params_v2 {
    #[doc = "< Version number. Use dcgmStartEmbeddedV2Params_version2"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "< IN: Collect data automatically or manually when asked by the user."]
    pub opMode: dcgmOperationMode_t,
    #[doc = "< OUT: DCGM Handle to use for API calls"]
    pub dcgmHandle: dcgmHandle_t,
    #[doc = "< IN: File that DCGM should log to. NULL = do not log. '-' = stdout"]
    pub logFile: *const ::std::os::raw::c_char,
    #[doc = "< IN: Severity at which DCGM should log to logFile"]
    pub severity: DcgmLoggingSeverity_t,
    #[doc = "< IN: Number of modules to be added to the denylist in denyList[]"]
    pub denyListCount: ::std::os::raw::c_uint,
    #[doc = "< IN: Service account for unprivileged processes"]
    pub serviceAccount: *const ::std::os::raw::c_char,
    #[doc = "< IN: IDs of modules to be added to the denylist"]
    pub denyList: [::std::os::raw::c_uint; 10usize],
}
#[doc = " Structure to return all of the profiling metric groups that are available for the given groupId."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmProfMetricGroupInfo_v2 {
    #[doc = "!< Major ID of this metric group. Metric groups with the same majorId cannot be\n!< watched concurrently with other metric groups with the same majorId"]
    pub majorId: ::std::os::raw::c_ushort,
    #[doc = "!< Minor ID of this metric group. This distinguishes metric groups within the same\n!< major metric group from each other"]
    pub minorId: ::std::os::raw::c_ushort,
    #[doc = "!< Number of field IDs that are populated in fieldIds[]"]
    pub numFieldIds: ::std::os::raw::c_uint,
    #[doc = "!< DCGM Field IDs that are part of this profiling\n!< group. See DCGM_FI_PROF_* definitions in\n!< dcgm_fields.h for details."]
    pub fieldIds: [::std::os::raw::c_ushort; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmProfGetMetricGroups_v3 {
    #[doc = "!< Version of this request. Should be dcgmProfGetMetricGroups_version"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Not used for now. Set to 0"]
    pub unused: ::std::os::raw::c_uint,
    #[doc = "!< GPU ID we should get the metric groups for."]
    pub gpuId: ::std::os::raw::c_uint,
    #[doc = "!< Number of entries in metricGroups[] that are populated"]
    pub numMetricGroups: ::std::os::raw::c_uint,
    #[doc = "!< Info for each metric group"]
    pub metricGroups: [dcgmProfMetricGroupInfo_v2; 10usize],
}
pub type dcgmProfGetMetricGroups_t = dcgmProfGetMetricGroups_v3;
#[doc = " Version 1 of dcgmSettingsSetLoggingSeverity_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmSettingsSetLoggingSeverity_v1 {
    pub targetLogger: ::std::os::raw::c_int,
    pub targetSeverity: DcgmLoggingSeverity_t,
}
#[doc = " Version 2 of dcgmSettingsSetLoggingSeverity_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmSettingsSetLoggingSeverity_v2 {
    pub version: ::std::os::raw::c_uint,
    pub targetLogger: ::std::os::raw::c_int,
    pub targetSeverity: DcgmLoggingSeverity_t,
}
#[doc = " Version 2 of dcgmSettingsSetLoggingSeverity_t"]
pub type dcgmSettingsSetLoggingSeverity_t = dcgmSettingsSetLoggingSeverity_v2;
#[doc = " Structure to describe the DCGM build environment ver 2.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgmVersionInfo_v2 {
    pub version: ::std::os::raw::c_uint,
    #[doc = " Raw form of the DCGM build info. There may be multiple kv-pairs separated by semicolon (;).<br>\n Every pair is separated by a colon char (:). Only the very first colon is considered as a separation.<br>\n Values can contain colon chars. Values and Keys cannot contain semicolon chars.<br>\n Usually defined keys are:\n      <p style=\"margin-left:20px\">\n      <i>version</i> : DCGM Version.<br>\n      <i>arch</i>    : Target DCGM Architecture.<br>\n      <i>buildid</i> : Build ID. Usually a sequential number.<br>\n      <i>commit</i>  : Commit ID (Usually a git commit hash).<br>\n      <i>author</i>  : Author of the commit above.<br>\n      <i>branch</i>  : Branch (Usually a git branch that was used for the build).<br>\n      <i>buildtype</i> : Build Type.<br>\n      <i>builddate</i> : Date of the build.<br>\n      <i>buildplatform</i>   : Platform where the build was made.<br>\n      </p>\n Any or all keys may be absent.<br>\n This values are for reference only are not supposed to participate in some complicated logic.<br>"]
    pub rawBuildInfoString: [::std::os::raw::c_char; 512usize],
}
#[doc = "!< The Fabric Manager isn't supported for this GPU"]
pub const dcgmFabricManagerStatus_t_DcgmFMStatusNotSupported: dcgmFabricManagerStatus_t = 0;
#[doc = "!< The Fabric Manager has not started for this GPU yet."]
pub const dcgmFabricManagerStatus_t_DcgmFMStatusNotStarted: dcgmFabricManagerStatus_t = 1;
#[doc = "!< The Fabric Manager is still starting up"]
pub const dcgmFabricManagerStatus_t_DcgmFMStatusInProgress: dcgmFabricManagerStatus_t = 2;
#[doc = "!< The Fabric Manager has started successfully"]
pub const dcgmFabricManagerStatus_t_DcgmFMStatusSuccess: dcgmFabricManagerStatus_t = 3;
#[doc = "!< The Fabric Manager finished training, but failed"]
pub const dcgmFabricManagerStatus_t_DcgmFMStatusFailure: dcgmFabricManagerStatus_t = 4;
#[doc = "!< NVML returned an unrecognized status for the fabric manager"]
pub const dcgmFabricManagerStatus_t_DcgmFMStatusUnrecognized: dcgmFabricManagerStatus_t = 5;
#[doc = "!< NVML returned NVML_ERROR_FUNCTION_NOT_FOUND when querying fabric manager status"]
pub const dcgmFabricManagerStatus_t_DcgmFMStatusNvmlTooOld: dcgmFabricManagerStatus_t = 6;
#[doc = "!< The count of valid statuses, always 1 more than the last status"]
pub const dcgmFabricManagerStatus_t_DcgmFMStatusCount: dcgmFabricManagerStatus_t = 7;
pub type dcgmFabricManagerStatus_t = ::std::os::raw::c_uint;
#[doc = " Structure to describe the DCGM build environment ver 2.0"]
pub type dcgmVersionInfo_t = dcgmVersionInfo_v2;
#[doc = "!< 0 No error"]
pub const dcgmError_enum_DCGM_FR_OK: dcgmError_enum = 0;
#[doc = "!< 1 Unknown error code"]
pub const dcgmError_enum_DCGM_FR_UNKNOWN: dcgmError_enum = 1;
#[doc = "!< 2 Unrecognized error code"]
pub const dcgmError_enum_DCGM_FR_UNRECOGNIZED: dcgmError_enum = 2;
#[doc = "!< 3 Unacceptable rate of PCI errors"]
pub const dcgmError_enum_DCGM_FR_PCI_REPLAY_RATE: dcgmError_enum = 3;
#[doc = "!< 4 Uncorrectable volatile double bit error"]
pub const dcgmError_enum_DCGM_FR_VOLATILE_DBE_DETECTED: dcgmError_enum = 4;
#[doc = "!< 5 Unacceptable rate of volatile single bit errors"]
pub const dcgmError_enum_DCGM_FR_VOLATILE_SBE_DETECTED: dcgmError_enum = 5;
#[doc = "!< 6 Pending page retirements detected"]
pub const dcgmError_enum_DCGM_FR_PENDING_PAGE_RETIREMENTS: dcgmError_enum = 6;
#[doc = "!< 7 Unacceptable total page retirements detected"]
pub const dcgmError_enum_DCGM_FR_RETIRED_PAGES_LIMIT: dcgmError_enum = 7;
#[doc = "!< 8 Unacceptable total page retirements due to uncorrectable errors"]
pub const dcgmError_enum_DCGM_FR_RETIRED_PAGES_DBE_LIMIT: dcgmError_enum = 8;
#[doc = "!< 9 Corrupt inforom found"]
pub const dcgmError_enum_DCGM_FR_CORRUPT_INFOROM: dcgmError_enum = 9;
#[doc = "!< 10 Clocks being optimized for thermal performance"]
pub const dcgmError_enum_DCGM_FR_CLOCKS_EVENT_THERMAL: dcgmError_enum = 10;
pub const dcgmError_enum_DCGM_FR_CLOCK_THROTTLE_THERMAL: dcgmError_enum = 10;
#[doc = "!< 11 Cannot get a reading for power from NVML"]
pub const dcgmError_enum_DCGM_FR_POWER_UNREADABLE: dcgmError_enum = 11;
#[doc = "!< 12 Clock being optimized to meet the product's power limit requirements"]
pub const dcgmError_enum_DCGM_FR_CLOCKS_EVENT_POWER: dcgmError_enum = 12;
#[doc = "!< Deprecated: Use DCGM_FR_CLOCKS_EVENT_POWER instead"]
pub const dcgmError_enum_DCGM_FR_CLOCK_THROTTLE_POWER: dcgmError_enum = 12;
#[doc = "!< 13 Unacceptable rate of NVLink errors"]
pub const dcgmError_enum_DCGM_FR_NVLINK_ERROR_THRESHOLD: dcgmError_enum = 13;
#[doc = "!< 14 NVLink is down"]
pub const dcgmError_enum_DCGM_FR_NVLINK_DOWN: dcgmError_enum = 14;
#[doc = "!< 15 Fatal errors on the NVSwitch"]
pub const dcgmError_enum_DCGM_FR_NVSWITCH_FATAL_ERROR: dcgmError_enum = 15;
#[doc = "!< 16 Non-fatal errors on the NVSwitch"]
pub const dcgmError_enum_DCGM_FR_NVSWITCH_NON_FATAL_ERROR: dcgmError_enum = 16;
#[doc = "!< 17 NVSwitch is down - NOT USED: DEPRECATED"]
pub const dcgmError_enum_DCGM_FR_NVSWITCH_DOWN: dcgmError_enum = 17;
#[doc = "!< 18 Cannot access a file"]
pub const dcgmError_enum_DCGM_FR_NO_ACCESS_TO_FILE: dcgmError_enum = 18;
#[doc = "!< 19 Error occurred on an NVML API - NOT USED: DEPRECATED"]
pub const dcgmError_enum_DCGM_FR_NVML_API: dcgmError_enum = 19;
#[doc = "!< 20 Disagreement in GPU count between /dev and NVML"]
pub const dcgmError_enum_DCGM_FR_DEVICE_COUNT_MISMATCH: dcgmError_enum = 20;
#[doc = "!< 21 Bad parameter passed to API"]
pub const dcgmError_enum_DCGM_FR_BAD_PARAMETER: dcgmError_enum = 21;
#[doc = "!< 22 Cannot open a library that must be accessed"]
pub const dcgmError_enum_DCGM_FR_CANNOT_OPEN_LIB: dcgmError_enum = 22;
#[doc = "!< 23 A driver on the denylist (nouveau) is active"]
pub const dcgmError_enum_DCGM_FR_DENYLISTED_DRIVER: dcgmError_enum = 23;
#[doc = "!< 24 NVML library is missing expected functions - NOT USED: DEPRECATED"]
pub const dcgmError_enum_DCGM_FR_NVML_LIB_BAD: dcgmError_enum = 24;
#[doc = "!< 25 Graphics processes are active on this GPU"]
pub const dcgmError_enum_DCGM_FR_GRAPHICS_PROCESSES: dcgmError_enum = 25;
#[doc = "!< 26 Bad connection to nv-hostengine - NOT USED: DEPRECATED"]
pub const dcgmError_enum_DCGM_FR_HOSTENGINE_CONN: dcgmError_enum = 26;
#[doc = "!< 27 Error querying a field from DCGM"]
pub const dcgmError_enum_DCGM_FR_FIELD_QUERY: dcgmError_enum = 27;
#[doc = "!< 28 The environment has variables that hurt CUDA"]
pub const dcgmError_enum_DCGM_FR_BAD_CUDA_ENV: dcgmError_enum = 28;
#[doc = "!< 29 Persistence mode is disabled"]
pub const dcgmError_enum_DCGM_FR_PERSISTENCE_MODE: dcgmError_enum = 29;
#[doc = "!< 30 The bandwidth is unacceptably low"]
pub const dcgmError_enum_DCGM_FR_LOW_BANDWIDTH: dcgmError_enum = 30;
#[doc = "!< 31 Latency is too high"]
pub const dcgmError_enum_DCGM_FR_HIGH_LATENCY: dcgmError_enum = 31;
#[doc = "!< 32 Cannot find a tag for a field"]
pub const dcgmError_enum_DCGM_FR_CANNOT_GET_FIELD_TAG: dcgmError_enum = 32;
#[doc = "!< 33 The value for the specified error field is above 0"]
pub const dcgmError_enum_DCGM_FR_FIELD_VIOLATION: dcgmError_enum = 33;
#[doc = "!< 34 The value for the specified field is above the threshold"]
pub const dcgmError_enum_DCGM_FR_FIELD_THRESHOLD: dcgmError_enum = 34;
#[doc = "!< 35 The value for the specified error field is above 0"]
pub const dcgmError_enum_DCGM_FR_FIELD_VIOLATION_DBL: dcgmError_enum = 35;
#[doc = "!< 36 The value for the specified field is above the threshold"]
pub const dcgmError_enum_DCGM_FR_FIELD_THRESHOLD_DBL: dcgmError_enum = 36;
#[doc = "!< 37 Field type cannot be supported"]
pub const dcgmError_enum_DCGM_FR_UNSUPPORTED_FIELD_TYPE: dcgmError_enum = 37;
#[doc = "!< 38 The value for the specified field is above the threshold"]
pub const dcgmError_enum_DCGM_FR_FIELD_THRESHOLD_TS: dcgmError_enum = 38;
#[doc = "!< 39 The value for the specified field is above the threshold"]
pub const dcgmError_enum_DCGM_FR_FIELD_THRESHOLD_TS_DBL: dcgmError_enum = 39;
#[doc = "!< 40 Thermal violations detected"]
pub const dcgmError_enum_DCGM_FR_THERMAL_VIOLATIONS: dcgmError_enum = 40;
#[doc = "!< 41 Thermal violations detected with a timestamp"]
pub const dcgmError_enum_DCGM_FR_THERMAL_VIOLATIONS_TS: dcgmError_enum = 41;
#[doc = "!< 42 Temperature is too high"]
pub const dcgmError_enum_DCGM_FR_TEMP_VIOLATION: dcgmError_enum = 42;
#[doc = "!< 43 Non-benign clocks event is occurring"]
pub const dcgmError_enum_DCGM_FR_CLOCKS_EVENT_VIOLATION: dcgmError_enum = 43;
pub const dcgmError_enum_DCGM_FR_THROTTLING_VIOLATION: dcgmError_enum = 43;
#[doc = "!< 44 An internal error was detected"]
pub const dcgmError_enum_DCGM_FR_INTERNAL: dcgmError_enum = 44;
#[doc = "!< 45 PCIe generation is too low"]
pub const dcgmError_enum_DCGM_FR_PCIE_GENERATION: dcgmError_enum = 45;
#[doc = "!< 46 PCIe width is too low"]
pub const dcgmError_enum_DCGM_FR_PCIE_WIDTH: dcgmError_enum = 46;
#[doc = "!< 47 Test was aborted by a user signal"]
pub const dcgmError_enum_DCGM_FR_ABORTED: dcgmError_enum = 47;
#[doc = "!< 48 This test is disabled for this GPU"]
pub const dcgmError_enum_DCGM_FR_TEST_DISABLED: dcgmError_enum = 48;
#[doc = "!< 49 Cannot get telemetry for a needed value"]
pub const dcgmError_enum_DCGM_FR_CANNOT_GET_STAT: dcgmError_enum = 49;
#[doc = "!< 50 Stress level is too low (bad performance)"]
pub const dcgmError_enum_DCGM_FR_STRESS_LEVEL: dcgmError_enum = 50;
#[doc = "!< 51 Error calling the specified CUDA API"]
pub const dcgmError_enum_DCGM_FR_CUDA_API: dcgmError_enum = 51;
#[doc = "!< 52 Faulty memory detected on this GPU"]
pub const dcgmError_enum_DCGM_FR_FAULTY_MEMORY: dcgmError_enum = 52;
#[doc = "!< 53 Unable to set field watches in DCGM - NOT USED: DEPRECATED"]
pub const dcgmError_enum_DCGM_FR_CANNOT_SET_WATCHES: dcgmError_enum = 53;
#[doc = "!< 54 CUDA context is no longer bound"]
pub const dcgmError_enum_DCGM_FR_CUDA_UNBOUND: dcgmError_enum = 54;
#[doc = "!< 55 ECC memory is disabled right now"]
pub const dcgmError_enum_DCGM_FR_ECC_DISABLED: dcgmError_enum = 55;
#[doc = "!< 56 Cannot allocate memory on the GPU"]
pub const dcgmError_enum_DCGM_FR_MEMORY_ALLOC: dcgmError_enum = 56;
#[doc = "!< 57 CUDA detected unrecovable double-bit error"]
pub const dcgmError_enum_DCGM_FR_CUDA_DBE: dcgmError_enum = 57;
#[doc = "!< 58 Memory error detected"]
pub const dcgmError_enum_DCGM_FR_MEMORY_MISMATCH: dcgmError_enum = 58;
#[doc = "!< 59 No CUDA device discoverable for existing GPU"]
pub const dcgmError_enum_DCGM_FR_CUDA_DEVICE: dcgmError_enum = 59;
#[doc = "!< 60 ECC memory is unsupported by this SKU"]
pub const dcgmError_enum_DCGM_FR_ECC_UNSUPPORTED: dcgmError_enum = 60;
#[doc = "!< 61 ECC memory is in a pending state - NOT USED: DEPRECATED"]
pub const dcgmError_enum_DCGM_FR_ECC_PENDING: dcgmError_enum = 61;
#[doc = "!< 62 Memory bandwidth is too low"]
pub const dcgmError_enum_DCGM_FR_MEMORY_BANDWIDTH: dcgmError_enum = 62;
#[doc = "!< 63 Cannot hit the target power draw"]
pub const dcgmError_enum_DCGM_FR_TARGET_POWER: dcgmError_enum = 63;
#[doc = "!< 64 The specified API call failed"]
pub const dcgmError_enum_DCGM_FR_API_FAIL: dcgmError_enum = 64;
#[doc = "!< 65 The specified API call failed for the specified GPU"]
pub const dcgmError_enum_DCGM_FR_API_FAIL_GPU: dcgmError_enum = 65;
#[doc = "!< 66 Cannot create a CUDA context on this GPU"]
pub const dcgmError_enum_DCGM_FR_CUDA_CONTEXT: dcgmError_enum = 66;
#[doc = "!< 67 DCGM API failure"]
pub const dcgmError_enum_DCGM_FR_DCGM_API: dcgmError_enum = 67;
#[doc = "!< 68 Need multiple GPUs to run this test"]
pub const dcgmError_enum_DCGM_FR_CONCURRENT_GPUS: dcgmError_enum = 68;
#[doc = "!< 69 More errors than fit in the return struct - NOT USED: DEPRECATED"]
pub const dcgmError_enum_DCGM_FR_TOO_MANY_ERRORS: dcgmError_enum = 69;
#[doc = "!< 70 More than 100 CRC errors are happening per second"]
pub const dcgmError_enum_DCGM_FR_NVLINK_CRC_ERROR_THRESHOLD: dcgmError_enum = 70;
#[doc = "!< 71 NVLink error for a field that should always be 0"]
pub const dcgmError_enum_DCGM_FR_NVLINK_ERROR_CRITICAL: dcgmError_enum = 71;
#[doc = "!< 72 The enforced power limit is too low to hit the target"]
pub const dcgmError_enum_DCGM_FR_ENFORCED_POWER_LIMIT: dcgmError_enum = 72;
#[doc = "!< 73 Cannot allocate memory on the host"]
pub const dcgmError_enum_DCGM_FR_MEMORY_ALLOC_HOST: dcgmError_enum = 73;
#[doc = "!< 74 Bad GPU operating mode for running plugin - NOT USED: DEPRECATED"]
pub const dcgmError_enum_DCGM_FR_GPU_OP_MODE: dcgmError_enum = 74;
#[doc = "!< 75 No memory clocks with the needed MHz found - NOT USED: DEPRECATED"]
pub const dcgmError_enum_DCGM_FR_NO_MEMORY_CLOCKS: dcgmError_enum = 75;
#[doc = "!< 76 No graphics clocks with the needed MHz found - NOT USED: DEPRECATED"]
pub const dcgmError_enum_DCGM_FR_NO_GRAPHICS_CLOCKS: dcgmError_enum = 76;
#[doc = "!< 77 Note that we had to restore a GPU's state"]
pub const dcgmError_enum_DCGM_FR_HAD_TO_RESTORE_STATE: dcgmError_enum = 77;
#[doc = "!< 78 L1TAG test is unsupported by this SKU"]
pub const dcgmError_enum_DCGM_FR_L1TAG_UNSUPPORTED: dcgmError_enum = 78;
#[doc = "!< 79 L1TAG test failed on a miscompare"]
pub const dcgmError_enum_DCGM_FR_L1TAG_MISCOMPARE: dcgmError_enum = 79;
#[doc = "!< 80 Row remapping failed (Ampere or newer GPUs)"]
pub const dcgmError_enum_DCGM_FR_ROW_REMAP_FAILURE: dcgmError_enum = 80;
#[doc = "!< 81 Uncontained error - XID 95"]
pub const dcgmError_enum_DCGM_FR_UNCONTAINED_ERROR: dcgmError_enum = 81;
#[doc = "!< 82 No GPU information given to plugin"]
pub const dcgmError_enum_DCGM_FR_EMPTY_GPU_LIST: dcgmError_enum = 82;
#[doc = "!< 83 Pending page retirements due to a DBE"]
pub const dcgmError_enum_DCGM_FR_DBE_PENDING_PAGE_RETIREMENTS: dcgmError_enum = 83;
#[doc = "!< 84 Uncorrectable row remapping"]
pub const dcgmError_enum_DCGM_FR_UNCORRECTABLE_ROW_REMAP: dcgmError_enum = 84;
#[doc = "!< 85 Row remapping is pending"]
pub const dcgmError_enum_DCGM_FR_PENDING_ROW_REMAP: dcgmError_enum = 85;
#[doc = "!< 86 P2P copy test detected an error writing to this GPU"]
pub const dcgmError_enum_DCGM_FR_BROKEN_P2P_MEMORY_DEVICE: dcgmError_enum = 86;
#[doc = "!< 87 P2P copy test detected an error writing from this GPU"]
pub const dcgmError_enum_DCGM_FR_BROKEN_P2P_WRITER_DEVICE: dcgmError_enum = 87;
#[doc = "!< 88 An NvLink is down for the specified NVSwitch - NOT USED: DEPRECATED"]
pub const dcgmError_enum_DCGM_FR_NVSWITCH_NVLINK_DOWN: dcgmError_enum = 88;
#[doc = "!< 89 EUD binary permissions are incorrect"]
pub const dcgmError_enum_DCGM_FR_EUD_BINARY_PERMISSIONS: dcgmError_enum = 89;
#[doc = "!< 90 EUD plugin is not running as root"]
pub const dcgmError_enum_DCGM_FR_EUD_NON_ROOT_USER: dcgmError_enum = 90;
#[doc = "!< 91 EUD plugin failed to spawn the EUD binary"]
pub const dcgmError_enum_DCGM_FR_EUD_SPAWN_FAILURE: dcgmError_enum = 91;
#[doc = "!< 92 EUD plugin timed out"]
pub const dcgmError_enum_DCGM_FR_EUD_TIMEOUT: dcgmError_enum = 92;
#[doc = "!< 93 EUD process remains running after the plugin considers it finished"]
pub const dcgmError_enum_DCGM_FR_EUD_ZOMBIE: dcgmError_enum = 93;
#[doc = "!< 94 EUD process exited with a non-zero exit code"]
pub const dcgmError_enum_DCGM_FR_EUD_NON_ZERO_EXIT_CODE: dcgmError_enum = 94;
#[doc = "!< 95 EUD test failed"]
pub const dcgmError_enum_DCGM_FR_EUD_TEST_FAILED: dcgmError_enum = 95;
#[doc = "!< 96 We cannot create a file in this directory."]
pub const dcgmError_enum_DCGM_FR_FILE_CREATE_PERMISSIONS: dcgmError_enum = 96;
#[doc = "!< 97 Pause/Resume failed"]
pub const dcgmError_enum_DCGM_FR_PAUSE_RESUME_FAILED: dcgmError_enum = 97;
#[doc = "!< 98 PCIe test caught correctable errors"]
pub const dcgmError_enum_DCGM_FR_PCIE_H_REPLAY_VIOLATION: dcgmError_enum = 98;
#[doc = "!< 99 Expected nvlinks up per gpu"]
pub const dcgmError_enum_DCGM_FR_GPU_EXPECTED_NVLINKS_UP: dcgmError_enum = 99;
#[doc = "!< 100 Expected nvlinks up per nvswitch"]
pub const dcgmError_enum_DCGM_FR_NVSWITCH_EXPECTED_NVLINKS_UP: dcgmError_enum = 100;
#[doc = "!< 101 XID error detected"]
pub const dcgmError_enum_DCGM_FR_XID_ERROR: dcgmError_enum = 101;
#[doc = "!< 102 Single bit error detected"]
pub const dcgmError_enum_DCGM_FR_SBE_VIOLATION: dcgmError_enum = 102;
#[doc = "!< 103 Double bit error detected"]
pub const dcgmError_enum_DCGM_FR_DBE_VIOLATION: dcgmError_enum = 103;
#[doc = "!< 104 PCIe replay errors detected"]
pub const dcgmError_enum_DCGM_FR_PCIE_REPLAY_VIOLATION: dcgmError_enum = 104;
#[doc = "!< 105 SBE threshold violated"]
pub const dcgmError_enum_DCGM_FR_SBE_THRESHOLD_VIOLATION: dcgmError_enum = 105;
#[doc = "!< 106 DBE threshold violated"]
pub const dcgmError_enum_DCGM_FR_DBE_THRESHOLD_VIOLATION: dcgmError_enum = 106;
#[doc = "!< 107 PCIE replay count violated"]
pub const dcgmError_enum_DCGM_FR_PCIE_REPLAY_THRESHOLD_VIOLATION: dcgmError_enum = 107;
#[doc = "!< 108 The fabricmanager is not initialized"]
pub const dcgmError_enum_DCGM_FR_CUDA_FM_NOT_INITIALIZED: dcgmError_enum = 108;
#[doc = "!< 109 NvSwitch fatal error detected"]
pub const dcgmError_enum_DCGM_FR_SXID_ERROR: dcgmError_enum = 109;
#[doc = "!< 110 GPU GFLOPs threshold violated"]
pub const dcgmError_enum_DCGM_FR_GFLOPS_THRESHOLD_VIOLATION: dcgmError_enum = 110;
#[doc = "!< 111 NaN value detected on this GPU"]
pub const dcgmError_enum_DCGM_FR_NAN_VALUE: dcgmError_enum = 111;
#[doc = "!< 112 Fabric Manager did not finish training"]
pub const dcgmError_enum_DCGM_FR_FABRIC_MANAGER_TRAINING_ERROR: dcgmError_enum = 112;
#[doc = "!< 113 P2P copy test detected an error writing to this GPU over PCIE"]
pub const dcgmError_enum_DCGM_FR_BROKEN_P2P_PCIE_MEMORY_DEVICE: dcgmError_enum = 113;
pub const dcgmError_enum_DCGM_FR_BROKEN_P2P_PCIE_WRITER_DEVICE: dcgmError_enum = 114;
pub const dcgmError_enum_DCGM_FR_BROKEN_P2P_NVLINK_MEMORY_DEVICE: dcgmError_enum = 115;
pub const dcgmError_enum_DCGM_FR_BROKEN_P2P_NVLINK_WRITER_DEVICE: dcgmError_enum = 116;
#[doc = "!< 117 Indicates that the test was skipped"]
pub const dcgmError_enum_DCGM_FR_TEST_SKIPPED: dcgmError_enum = 117;
#[doc = "!< 117 MUST BE THE LAST ERROR CODE"]
pub const dcgmError_enum_DCGM_FR_ERROR_SENTINEL: dcgmError_enum = 118;
#[doc = "/\n/** @defgroup dcgmErrorEnums Error Codes\n  @{\n/\n/"]
pub type dcgmError_enum = ::std::os::raw::c_uint;
#[doc = "/\n/** @defgroup dcgmErrorEnums Error Codes\n  @{\n/\n/"]
pub use self::dcgmError_enum as dcgmError_t;
#[doc = "!< 0 NONE"]
pub const dcgmErrorSeverity_enum_DCGM_ERROR_NONE: dcgmErrorSeverity_enum = 0;
#[doc = "!< 1 Can perform workload, but needs to be monitored."]
pub const dcgmErrorSeverity_enum_DCGM_ERROR_MONITOR: dcgmErrorSeverity_enum = 1;
#[doc = "!< 2 Cannot perform workload. GPU should be isolated."]
pub const dcgmErrorSeverity_enum_DCGM_ERROR_ISOLATE: dcgmErrorSeverity_enum = 2;
#[doc = "!< 3 This error code is not recognized"]
pub const dcgmErrorSeverity_enum_DCGM_ERROR_UNKNOWN: dcgmErrorSeverity_enum = 3;
#[doc = "!< 4 This error should be triaged"]
pub const dcgmErrorSeverity_enum_DCGM_ERROR_TRIAGE: dcgmErrorSeverity_enum = 4;
#[doc = "!< 5 This error can be configured"]
pub const dcgmErrorSeverity_enum_DCGM_ERROR_CONFIG: dcgmErrorSeverity_enum = 5;
#[doc = "!< 6 Drain and reset GPU"]
pub const dcgmErrorSeverity_enum_DCGM_ERROR_RESET: dcgmErrorSeverity_enum = 6;
pub type dcgmErrorSeverity_enum = ::std::os::raw::c_uint;
pub use self::dcgmErrorSeverity_enum as dcgmErrorSeverity_t;
#[doc = "!< 0 NONE"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_NONE: dcgmErrorCategory_enum = 0;
#[doc = "!< 1 Performance Threshold"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_PERF_THRESHOLD: dcgmErrorCategory_enum = 1;
#[doc = "!< 2 Performance Violation"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_PERF_VIOLATION: dcgmErrorCategory_enum = 2;
#[doc = "!< 3 Software Configuration"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_SOFTWARE_CONFIG: dcgmErrorCategory_enum = 3;
#[doc = "!< 4 Software Library"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_SOFTWARE_LIBRARY: dcgmErrorCategory_enum = 4;
#[doc = "!< 5 Software XID"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_SOFTWARE_XID: dcgmErrorCategory_enum = 5;
#[doc = "!< 6 Software Cuda"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_SOFTWARE_CUDA: dcgmErrorCategory_enum = 6;
#[doc = "!< 7 Software EUD"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_SOFTWARE_EUD: dcgmErrorCategory_enum = 7;
#[doc = "!< 8 Software Other"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_SOFTWARE_OTHER: dcgmErrorCategory_enum = 8;
#[doc = "!< 9 Hardware Thermal"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_HARDWARE_THERMAL: dcgmErrorCategory_enum = 9;
#[doc = "!< 10 Hardware Memory"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_HARDWARE_MEMORY: dcgmErrorCategory_enum = 10;
#[doc = "!< 11 Hardware NvLink"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_HARDWARE_NVLINK: dcgmErrorCategory_enum = 11;
#[doc = "!< 12 Hardware NvSwitch"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_HARDWARE_NVSWITCH: dcgmErrorCategory_enum = 12;
#[doc = "!< 13 Hardware PCIe"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_HARDWARE_PCIE: dcgmErrorCategory_enum = 13;
#[doc = "!< 14 Hardware Power"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_HARDWARE_POWER: dcgmErrorCategory_enum = 14;
#[doc = "!< 15 Hardware Other"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_HARDWARE_OTHER: dcgmErrorCategory_enum = 15;
#[doc = "!< 16 Internal Other"]
pub const dcgmErrorCategory_enum_DCGM_FR_EC_INTERNAL_OTHER: dcgmErrorCategory_enum = 16;
pub type dcgmErrorCategory_enum = ::std::os::raw::c_uint;
pub use self::dcgmErrorCategory_enum as dcgmErrorCategory_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcgm_error_meta_t {
    pub errorId: dcgmError_t,
    pub msgFormat: *const ::std::os::raw::c_char,
    pub suggestion: *const ::std::os::raw::c_char,
    pub severity: ::std::os::raw::c_int,
    pub category: ::std::os::raw::c_int,
}
pub struct DcgmLib {
    __library: ::libloading::Library,
    pub DcgmFieldGetById: Result<
        unsafe extern "C" fn(fieldId: ::std::os::raw::c_ushort) -> dcgm_field_meta_p,
        ::libloading::Error,
    >,
    pub DcgmFieldGetByTag: Result<
        unsafe extern "C" fn(tag: *const ::std::os::raw::c_char) -> dcgm_field_meta_p,
        ::libloading::Error,
    >,
    pub DcgmFieldsInit:
        Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub DcgmFieldsTerm:
        Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub DcgmFieldsGetEntityGroupString: Result<
        unsafe extern "C" fn(
            entityGroupId: dcgm_field_entity_group_t,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub errorString: Result<
        unsafe extern "C" fn(result: dcgmReturn_t) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub dcgmInit: Result<unsafe extern "C" fn() -> dcgmReturn_t, ::libloading::Error>,
    pub dcgmShutdown: Result<unsafe extern "C" fn() -> dcgmReturn_t, ::libloading::Error>,
    pub dcgmStartEmbedded: Result<
        unsafe extern "C" fn(
            opMode: dcgmOperationMode_t,
            pDcgmHandle: *mut dcgmHandle_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmStartEmbedded_v2: Result<
        unsafe extern "C" fn(params: *mut dcgmStartEmbeddedV2Params_v1) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmStopEmbedded: Result<
        unsafe extern "C" fn(pDcgmHandle: dcgmHandle_t) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmConnect: Result<
        unsafe extern "C" fn(
            ipAddress: *const ::std::os::raw::c_char,
            pDcgmHandle: *mut dcgmHandle_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmConnect_v2: Result<
        unsafe extern "C" fn(
            ipAddress: *const ::std::os::raw::c_char,
            connectParams: *mut dcgmConnectV2Params_t,
            pDcgmHandle: *mut dcgmHandle_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmDisconnect: Result<
        unsafe extern "C" fn(pDcgmHandle: dcgmHandle_t) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmVersionInfo: Result<
        unsafe extern "C" fn(pVersionInfo: *mut dcgmVersionInfo_t) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmHostengineVersionInfo: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            pVersionInfo: *mut dcgmVersionInfo_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmHostengineSetLoggingSeverity: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            logging: *mut dcgmSettingsSetLoggingSeverity_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmHostengineIsHealthy: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            heHealth: *mut dcgmHostengineHealth_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmModuleIdToName: Result<
        unsafe extern "C" fn(
            id: dcgmModuleId_t,
            name: *mut *const ::std::os::raw::c_char,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetAllDevices: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            gpuIdList: *mut ::std::os::raw::c_uint,
            count: *mut ::std::os::raw::c_int,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetAllSupportedDevices: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            gpuIdList: *mut ::std::os::raw::c_uint,
            count: *mut ::std::os::raw::c_int,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetDeviceAttributes: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            gpuId: ::std::os::raw::c_uint,
            pDcgmAttr: *mut dcgmDeviceAttributes_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetEntityGroupEntities: Result<
        unsafe extern "C" fn(
            dcgmHandle: dcgmHandle_t,
            entityGroup: dcgm_field_entity_group_t,
            entities: *mut dcgm_field_eid_t,
            numEntities: *mut ::std::os::raw::c_int,
            flags: ::std::os::raw::c_uint,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetGpuInstanceHierarchy: Result<
        unsafe extern "C" fn(
            dcgmHandle: dcgmHandle_t,
            hierarchy: *mut dcgmMigHierarchy_v2,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetNvLinkLinkStatus: Result<
        unsafe extern "C" fn(
            dcgmHandle: dcgmHandle_t,
            linkStatus: *mut dcgmNvLinkStatus_v4,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetCpuHierarchy: Result<
        unsafe extern "C" fn(
            dcgmHandle: dcgmHandle_t,
            cpuHierarchy: *mut dcgmCpuHierarchy_v1,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetCpuHierarchy_v2: Result<
        unsafe extern "C" fn(
            dcgmHandle: dcgmHandle_t,
            cpuHierarchy: *mut dcgmCpuHierarchy_v2,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGroupCreate: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            type_: dcgmGroupType_t,
            groupName: *const ::std::os::raw::c_char,
            pDcgmGrpId: *mut dcgmGpuGrp_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGroupDestroy: Result<
        unsafe extern "C" fn(pDcgmHandle: dcgmHandle_t, groupId: dcgmGpuGrp_t) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGroupAddDevice: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            gpuId: ::std::os::raw::c_uint,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGroupAddEntity: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            entityGroupId: dcgm_field_entity_group_t,
            entityId: dcgm_field_eid_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGroupRemoveDevice: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            gpuId: ::std::os::raw::c_uint,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGroupRemoveEntity: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            entityGroupId: dcgm_field_entity_group_t,
            entityId: dcgm_field_eid_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGroupGetInfo: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            pDcgmGroupInfo: *mut dcgmGroupInfo_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGroupGetAllIds: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupIdList: *mut dcgmGpuGrp_t,
            count: *mut ::std::os::raw::c_uint,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmFieldGroupCreate: Result<
        unsafe extern "C" fn(
            dcgmHandle: dcgmHandle_t,
            numFieldIds: ::std::os::raw::c_int,
            fieldIds: *mut ::std::os::raw::c_ushort,
            fieldGroupName: *const ::std::os::raw::c_char,
            dcgmFieldGroupId: *mut dcgmFieldGrp_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmFieldGroupDestroy: Result<
        unsafe extern "C" fn(
            dcgmHandle: dcgmHandle_t,
            dcgmFieldGroupId: dcgmFieldGrp_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmFieldGroupGetInfo: Result<
        unsafe extern "C" fn(
            dcgmHandle: dcgmHandle_t,
            fieldGroupInfo: *mut dcgmFieldGroupInfo_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmFieldGroupGetAll: Result<
        unsafe extern "C" fn(
            dcgmHandle: dcgmHandle_t,
            allGroupInfo: *mut dcgmAllFieldGroup_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmStatusCreate: Result<
        unsafe extern "C" fn(statusHandle: *mut dcgmStatus_t) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmStatusDestroy: Result<
        unsafe extern "C" fn(statusHandle: dcgmStatus_t) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmStatusGetCount: Result<
        unsafe extern "C" fn(
            statusHandle: dcgmStatus_t,
            count: *mut ::std::os::raw::c_uint,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmStatusPopError: Result<
        unsafe extern "C" fn(
            statusHandle: dcgmStatus_t,
            pDcgmErrorInfo: *mut dcgmErrorInfo_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmStatusClear: Result<
        unsafe extern "C" fn(statusHandle: dcgmStatus_t) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmConfigSet: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            pDeviceConfig: *mut dcgmConfig_t,
            statusHandle: dcgmStatus_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmConfigGet: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            type_: dcgmConfigType_t,
            count: ::std::os::raw::c_int,
            deviceConfigList: *mut dcgmConfig_t,
            statusHandle: dcgmStatus_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmConfigEnforce: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            statusHandle: dcgmStatus_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmWatchFields: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            fieldGroupId: dcgmFieldGrp_t,
            updateFreq: ::std::os::raw::c_longlong,
            maxKeepAge: f64,
            maxKeepSamples: ::std::os::raw::c_int,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmUnwatchFields: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            fieldGroupId: dcgmFieldGrp_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetValuesSince: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            fieldGroupId: dcgmFieldGrp_t,
            sinceTimestamp: ::std::os::raw::c_longlong,
            nextSinceTimestamp: *mut ::std::os::raw::c_longlong,
            enumCB: dcgmFieldValueEnumeration_f,
            userData: *mut ::std::os::raw::c_void,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetValuesSince_v2: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            fieldGroupId: dcgmFieldGrp_t,
            sinceTimestamp: ::std::os::raw::c_longlong,
            nextSinceTimestamp: *mut ::std::os::raw::c_longlong,
            enumCB: dcgmFieldValueEntityEnumeration_f,
            userData: *mut ::std::os::raw::c_void,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetLatestValues: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            fieldGroupId: dcgmFieldGrp_t,
            enumCB: dcgmFieldValueEnumeration_f,
            userData: *mut ::std::os::raw::c_void,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetLatestValues_v2: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            fieldGroupId: dcgmFieldGrp_t,
            enumCB: dcgmFieldValueEntityEnumeration_f,
            userData: *mut ::std::os::raw::c_void,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetLatestValuesForFields: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            gpuId: ::std::os::raw::c_int,
            fields: *mut ::std::os::raw::c_ushort,
            count: ::std::os::raw::c_uint,
            values: *mut dcgmFieldValue_v1,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmEntityGetLatestValues: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            entityGroup: dcgm_field_entity_group_t,
            entityId: ::std::os::raw::c_int,
            fields: *mut ::std::os::raw::c_ushort,
            count: ::std::os::raw::c_uint,
            values: *mut dcgmFieldValue_v1,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmEntitiesGetLatestValues: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            entities: *mut dcgmGroupEntityPair_t,
            entityCount: ::std::os::raw::c_uint,
            fields: *mut ::std::os::raw::c_ushort,
            fieldCount: ::std::os::raw::c_uint,
            flags: ::std::os::raw::c_uint,
            values: *mut dcgmFieldValue_v2,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetFieldSummary: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            request: *mut dcgmFieldSummaryRequest_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmUpdateAllFields: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            waitForUpdate: ::std::os::raw::c_int,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmWatchPidFields: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            updateFreq: ::std::os::raw::c_longlong,
            maxKeepAge: f64,
            maxKeepSamples: ::std::os::raw::c_int,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetPidInfo: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            pidInfo: *mut dcgmPidInfo_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmWatchJobFields: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            updateFreq: ::std::os::raw::c_longlong,
            maxKeepAge: f64,
            maxKeepSamples: ::std::os::raw::c_int,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmJobStartStats: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            jobId: *mut ::std::os::raw::c_char,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmJobStopStats: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            jobId: *mut ::std::os::raw::c_char,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmJobGetStats: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            jobId: *mut ::std::os::raw::c_char,
            pJobInfo: *mut dcgmJobInfo_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmJobRemove: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            jobId: *mut ::std::os::raw::c_char,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmJobRemoveAll: Result<
        unsafe extern "C" fn(pDcgmHandle: dcgmHandle_t) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmHealthSet: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            systems: dcgmHealthSystems_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmHealthSet_v2: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            params: *mut dcgmHealthSetParams_v2,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmHealthGet: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            systems: *mut dcgmHealthSystems_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmHealthCheck: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            results: *mut dcgmHealthResponse_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmPolicySet: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            policy: *mut dcgmPolicy_t,
            statusHandle: dcgmStatus_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmPolicyGet: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            count: ::std::os::raw::c_int,
            policy: *mut dcgmPolicy_t,
            statusHandle: dcgmStatus_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmPolicyRegister_v2: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            condition: dcgmPolicyCondition_t,
            callback: fpRecvUpdates,
            userData: u64,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmPolicyUnregister: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            condition: dcgmPolicyCondition_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmActionValidate: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            validate: dcgmPolicyValidation_t,
            response: *mut dcgmDiagResponse_v11,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmActionValidate_v2: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            drd: *mut dcgmRunDiag_v10,
            response: *mut dcgmDiagResponse_v11,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmRunDiagnostic: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            diagLevel: dcgmDiagnosticLevel_t,
            diagResponse: *mut dcgmDiagResponse_v11,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmPolicyTrigger: Result<
        unsafe extern "C" fn(pDcgmHandle: dcgmHandle_t) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetDeviceWorkloadPowerProfileInfo: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            gpuId: ::std::os::raw::c_uint,
            profilesInfo: *mut dcgmWorkloadPowerProfileProfilesInfo_v1,
            profileStatus: *mut dcgmDeviceWorkloadPowerProfilesStatus_v1,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetDeviceTopology: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            gpuId: ::std::os::raw::c_uint,
            pDcgmDeviceTopology: *mut dcgmDeviceTopology_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmGetGroupTopology: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            groupId: dcgmGpuGrp_t,
            pDcgmGroupTopology: *mut dcgmGroupTopology_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmIntrospectGetHostengineMemoryUsage: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            memoryInfo: *mut dcgmIntrospectMemory_t,
            waitIfNoData: ::std::os::raw::c_int,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmIntrospectGetHostengineCpuUtilization: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            cpuUtil: *mut dcgmIntrospectCpuUtil_t,
            waitIfNoData: ::std::os::raw::c_int,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmSelectGpusByTopology: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            inputGpuIds: u64,
            numGpus: u32,
            outputGpuIds: *mut u64,
            hintFlags: u64,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmModuleDenylist: Result<
        unsafe extern "C" fn(pDcgmHandle: dcgmHandle_t, moduleId: dcgmModuleId_t) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmModuleGetStatuses: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            moduleStatuses: *mut dcgmModuleGetStatuses_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmProfGetSupportedMetricGroups: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            metricGroups: *mut dcgmProfGetMetricGroups_t,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmProfPause: Result<
        unsafe extern "C" fn(pDcgmHandle: dcgmHandle_t) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmProfResume: Result<
        unsafe extern "C" fn(pDcgmHandle: dcgmHandle_t) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmAddFakeInstances: Result<
        unsafe extern "C" fn(
            pDcgmHandle: dcgmHandle_t,
            hierarchy: *mut dcgmMigHierarchy_v2,
        ) -> dcgmReturn_t,
        ::libloading::Error,
    >,
    pub dcgmErrorMeta: Result<*mut [dcgm_error_meta_t; 0usize], ::libloading::Error>,
    pub dcgmErrorGetPriorityByCode: Result<
        unsafe extern "C" fn(code: ::std::os::raw::c_uint) -> dcgmErrorSeverity_t,
        ::libloading::Error,
    >,
    pub dcgmErrorGetCategoryByCode: Result<
        unsafe extern "C" fn(code: ::std::os::raw::c_uint) -> dcgmErrorCategory_t,
        ::libloading::Error,
    >,
    pub dcgmErrorGetFormatMsgByCode: Result<
        unsafe extern "C" fn(code: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub dcgmGetErrorMeta: Result<
        unsafe extern "C" fn(error: dcgmError_t) -> *const dcgm_error_meta_t,
        ::libloading::Error,
    >,
}
impl DcgmLib {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let DcgmFieldGetById = __library.get(b"DcgmFieldGetById\0").map(|sym| *sym);
        let DcgmFieldGetByTag = __library.get(b"DcgmFieldGetByTag\0").map(|sym| *sym);
        let DcgmFieldsInit = __library.get(b"DcgmFieldsInit\0").map(|sym| *sym);
        let DcgmFieldsTerm = __library.get(b"DcgmFieldsTerm\0").map(|sym| *sym);
        let DcgmFieldsGetEntityGroupString = __library
            .get(b"DcgmFieldsGetEntityGroupString\0")
            .map(|sym| *sym);
        let errorString = __library.get(b"errorString\0").map(|sym| *sym);
        let dcgmInit = __library.get(b"dcgmInit\0").map(|sym| *sym);
        let dcgmShutdown = __library.get(b"dcgmShutdown\0").map(|sym| *sym);
        let dcgmStartEmbedded = __library.get(b"dcgmStartEmbedded\0").map(|sym| *sym);
        let dcgmStartEmbedded_v2 = __library.get(b"dcgmStartEmbedded_v2\0").map(|sym| *sym);
        let dcgmStopEmbedded = __library.get(b"dcgmStopEmbedded\0").map(|sym| *sym);
        let dcgmConnect = __library.get(b"dcgmConnect\0").map(|sym| *sym);
        let dcgmConnect_v2 = __library.get(b"dcgmConnect_v2\0").map(|sym| *sym);
        let dcgmDisconnect = __library.get(b"dcgmDisconnect\0").map(|sym| *sym);
        let dcgmVersionInfo = __library.get(b"dcgmVersionInfo\0").map(|sym| *sym);
        let dcgmHostengineVersionInfo = __library
            .get(b"dcgmHostengineVersionInfo\0")
            .map(|sym| *sym);
        let dcgmHostengineSetLoggingSeverity = __library
            .get(b"dcgmHostengineSetLoggingSeverity\0")
            .map(|sym| *sym);
        let dcgmHostengineIsHealthy = __library.get(b"dcgmHostengineIsHealthy\0").map(|sym| *sym);
        let dcgmModuleIdToName = __library.get(b"dcgmModuleIdToName\0").map(|sym| *sym);
        let dcgmGetAllDevices = __library.get(b"dcgmGetAllDevices\0").map(|sym| *sym);
        let dcgmGetAllSupportedDevices = __library
            .get(b"dcgmGetAllSupportedDevices\0")
            .map(|sym| *sym);
        let dcgmGetDeviceAttributes = __library.get(b"dcgmGetDeviceAttributes\0").map(|sym| *sym);
        let dcgmGetEntityGroupEntities = __library
            .get(b"dcgmGetEntityGroupEntities\0")
            .map(|sym| *sym);
        let dcgmGetGpuInstanceHierarchy = __library
            .get(b"dcgmGetGpuInstanceHierarchy\0")
            .map(|sym| *sym);
        let dcgmGetNvLinkLinkStatus = __library.get(b"dcgmGetNvLinkLinkStatus\0").map(|sym| *sym);
        let dcgmGetCpuHierarchy = __library.get(b"dcgmGetCpuHierarchy\0").map(|sym| *sym);
        let dcgmGetCpuHierarchy_v2 = __library.get(b"dcgmGetCpuHierarchy_v2\0").map(|sym| *sym);
        let dcgmGroupCreate = __library.get(b"dcgmGroupCreate\0").map(|sym| *sym);
        let dcgmGroupDestroy = __library.get(b"dcgmGroupDestroy\0").map(|sym| *sym);
        let dcgmGroupAddDevice = __library.get(b"dcgmGroupAddDevice\0").map(|sym| *sym);
        let dcgmGroupAddEntity = __library.get(b"dcgmGroupAddEntity\0").map(|sym| *sym);
        let dcgmGroupRemoveDevice = __library.get(b"dcgmGroupRemoveDevice\0").map(|sym| *sym);
        let dcgmGroupRemoveEntity = __library.get(b"dcgmGroupRemoveEntity\0").map(|sym| *sym);
        let dcgmGroupGetInfo = __library.get(b"dcgmGroupGetInfo\0").map(|sym| *sym);
        let dcgmGroupGetAllIds = __library.get(b"dcgmGroupGetAllIds\0").map(|sym| *sym);
        let dcgmFieldGroupCreate = __library.get(b"dcgmFieldGroupCreate\0").map(|sym| *sym);
        let dcgmFieldGroupDestroy = __library.get(b"dcgmFieldGroupDestroy\0").map(|sym| *sym);
        let dcgmFieldGroupGetInfo = __library.get(b"dcgmFieldGroupGetInfo\0").map(|sym| *sym);
        let dcgmFieldGroupGetAll = __library.get(b"dcgmFieldGroupGetAll\0").map(|sym| *sym);
        let dcgmStatusCreate = __library.get(b"dcgmStatusCreate\0").map(|sym| *sym);
        let dcgmStatusDestroy = __library.get(b"dcgmStatusDestroy\0").map(|sym| *sym);
        let dcgmStatusGetCount = __library.get(b"dcgmStatusGetCount\0").map(|sym| *sym);
        let dcgmStatusPopError = __library.get(b"dcgmStatusPopError\0").map(|sym| *sym);
        let dcgmStatusClear = __library.get(b"dcgmStatusClear\0").map(|sym| *sym);
        let dcgmConfigSet = __library.get(b"dcgmConfigSet\0").map(|sym| *sym);
        let dcgmConfigGet = __library.get(b"dcgmConfigGet\0").map(|sym| *sym);
        let dcgmConfigEnforce = __library.get(b"dcgmConfigEnforce\0").map(|sym| *sym);
        let dcgmWatchFields = __library.get(b"dcgmWatchFields\0").map(|sym| *sym);
        let dcgmUnwatchFields = __library.get(b"dcgmUnwatchFields\0").map(|sym| *sym);
        let dcgmGetValuesSince = __library.get(b"dcgmGetValuesSince\0").map(|sym| *sym);
        let dcgmGetValuesSince_v2 = __library.get(b"dcgmGetValuesSince_v2\0").map(|sym| *sym);
        let dcgmGetLatestValues = __library.get(b"dcgmGetLatestValues\0").map(|sym| *sym);
        let dcgmGetLatestValues_v2 = __library.get(b"dcgmGetLatestValues_v2\0").map(|sym| *sym);
        let dcgmGetLatestValuesForFields = __library
            .get(b"dcgmGetLatestValuesForFields\0")
            .map(|sym| *sym);
        let dcgmEntityGetLatestValues = __library
            .get(b"dcgmEntityGetLatestValues\0")
            .map(|sym| *sym);
        let dcgmEntitiesGetLatestValues = __library
            .get(b"dcgmEntitiesGetLatestValues\0")
            .map(|sym| *sym);
        let dcgmGetFieldSummary = __library.get(b"dcgmGetFieldSummary\0").map(|sym| *sym);
        let dcgmUpdateAllFields = __library.get(b"dcgmUpdateAllFields\0").map(|sym| *sym);
        let dcgmWatchPidFields = __library.get(b"dcgmWatchPidFields\0").map(|sym| *sym);
        let dcgmGetPidInfo = __library.get(b"dcgmGetPidInfo\0").map(|sym| *sym);
        let dcgmWatchJobFields = __library.get(b"dcgmWatchJobFields\0").map(|sym| *sym);
        let dcgmJobStartStats = __library.get(b"dcgmJobStartStats\0").map(|sym| *sym);
        let dcgmJobStopStats = __library.get(b"dcgmJobStopStats\0").map(|sym| *sym);
        let dcgmJobGetStats = __library.get(b"dcgmJobGetStats\0").map(|sym| *sym);
        let dcgmJobRemove = __library.get(b"dcgmJobRemove\0").map(|sym| *sym);
        let dcgmJobRemoveAll = __library.get(b"dcgmJobRemoveAll\0").map(|sym| *sym);
        let dcgmHealthSet = __library.get(b"dcgmHealthSet\0").map(|sym| *sym);
        let dcgmHealthSet_v2 = __library.get(b"dcgmHealthSet_v2\0").map(|sym| *sym);
        let dcgmHealthGet = __library.get(b"dcgmHealthGet\0").map(|sym| *sym);
        let dcgmHealthCheck = __library.get(b"dcgmHealthCheck\0").map(|sym| *sym);
        let dcgmPolicySet = __library.get(b"dcgmPolicySet\0").map(|sym| *sym);
        let dcgmPolicyGet = __library.get(b"dcgmPolicyGet\0").map(|sym| *sym);
        let dcgmPolicyRegister_v2 = __library.get(b"dcgmPolicyRegister_v2\0").map(|sym| *sym);
        let dcgmPolicyUnregister = __library.get(b"dcgmPolicyUnregister\0").map(|sym| *sym);
        let dcgmActionValidate = __library.get(b"dcgmActionValidate\0").map(|sym| *sym);
        let dcgmActionValidate_v2 = __library.get(b"dcgmActionValidate_v2\0").map(|sym| *sym);
        let dcgmRunDiagnostic = __library.get(b"dcgmRunDiagnostic\0").map(|sym| *sym);
        let dcgmPolicyTrigger = __library.get(b"dcgmPolicyTrigger\0").map(|sym| *sym);
        let dcgmGetDeviceWorkloadPowerProfileInfo = __library
            .get(b"dcgmGetDeviceWorkloadPowerProfileInfo\0")
            .map(|sym| *sym);
        let dcgmGetDeviceTopology = __library.get(b"dcgmGetDeviceTopology\0").map(|sym| *sym);
        let dcgmGetGroupTopology = __library.get(b"dcgmGetGroupTopology\0").map(|sym| *sym);
        let dcgmIntrospectGetHostengineMemoryUsage = __library
            .get(b"dcgmIntrospectGetHostengineMemoryUsage\0")
            .map(|sym| *sym);
        let dcgmIntrospectGetHostengineCpuUtilization = __library
            .get(b"dcgmIntrospectGetHostengineCpuUtilization\0")
            .map(|sym| *sym);
        let dcgmSelectGpusByTopology = __library.get(b"dcgmSelectGpusByTopology\0").map(|sym| *sym);
        let dcgmModuleDenylist = __library.get(b"dcgmModuleDenylist\0").map(|sym| *sym);
        let dcgmModuleGetStatuses = __library.get(b"dcgmModuleGetStatuses\0").map(|sym| *sym);
        let dcgmProfGetSupportedMetricGroups = __library
            .get(b"dcgmProfGetSupportedMetricGroups\0")
            .map(|sym| *sym);
        let dcgmProfPause = __library.get(b"dcgmProfPause\0").map(|sym| *sym);
        let dcgmProfResume = __library.get(b"dcgmProfResume\0").map(|sym| *sym);
        let dcgmAddFakeInstances = __library.get(b"dcgmAddFakeInstances\0").map(|sym| *sym);
        let dcgmErrorMeta = __library
            .get::<*mut [dcgm_error_meta_t; 0usize]>(b"dcgmErrorMeta\0")
            .map(|sym| *sym);
        let dcgmErrorGetPriorityByCode = __library
            .get(b"dcgmErrorGetPriorityByCode\0")
            .map(|sym| *sym);
        let dcgmErrorGetCategoryByCode = __library
            .get(b"dcgmErrorGetCategoryByCode\0")
            .map(|sym| *sym);
        let dcgmErrorGetFormatMsgByCode = __library
            .get(b"dcgmErrorGetFormatMsgByCode\0")
            .map(|sym| *sym);
        let dcgmGetErrorMeta = __library.get(b"dcgmGetErrorMeta\0").map(|sym| *sym);
        Ok(DcgmLib {
            __library,
            DcgmFieldGetById,
            DcgmFieldGetByTag,
            DcgmFieldsInit,
            DcgmFieldsTerm,
            DcgmFieldsGetEntityGroupString,
            errorString,
            dcgmInit,
            dcgmShutdown,
            dcgmStartEmbedded,
            dcgmStartEmbedded_v2,
            dcgmStopEmbedded,
            dcgmConnect,
            dcgmConnect_v2,
            dcgmDisconnect,
            dcgmVersionInfo,
            dcgmHostengineVersionInfo,
            dcgmHostengineSetLoggingSeverity,
            dcgmHostengineIsHealthy,
            dcgmModuleIdToName,
            dcgmGetAllDevices,
            dcgmGetAllSupportedDevices,
            dcgmGetDeviceAttributes,
            dcgmGetEntityGroupEntities,
            dcgmGetGpuInstanceHierarchy,
            dcgmGetNvLinkLinkStatus,
            dcgmGetCpuHierarchy,
            dcgmGetCpuHierarchy_v2,
            dcgmGroupCreate,
            dcgmGroupDestroy,
            dcgmGroupAddDevice,
            dcgmGroupAddEntity,
            dcgmGroupRemoveDevice,
            dcgmGroupRemoveEntity,
            dcgmGroupGetInfo,
            dcgmGroupGetAllIds,
            dcgmFieldGroupCreate,
            dcgmFieldGroupDestroy,
            dcgmFieldGroupGetInfo,
            dcgmFieldGroupGetAll,
            dcgmStatusCreate,
            dcgmStatusDestroy,
            dcgmStatusGetCount,
            dcgmStatusPopError,
            dcgmStatusClear,
            dcgmConfigSet,
            dcgmConfigGet,
            dcgmConfigEnforce,
            dcgmWatchFields,
            dcgmUnwatchFields,
            dcgmGetValuesSince,
            dcgmGetValuesSince_v2,
            dcgmGetLatestValues,
            dcgmGetLatestValues_v2,
            dcgmGetLatestValuesForFields,
            dcgmEntityGetLatestValues,
            dcgmEntitiesGetLatestValues,
            dcgmGetFieldSummary,
            dcgmUpdateAllFields,
            dcgmWatchPidFields,
            dcgmGetPidInfo,
            dcgmWatchJobFields,
            dcgmJobStartStats,
            dcgmJobStopStats,
            dcgmJobGetStats,
            dcgmJobRemove,
            dcgmJobRemoveAll,
            dcgmHealthSet,
            dcgmHealthSet_v2,
            dcgmHealthGet,
            dcgmHealthCheck,
            dcgmPolicySet,
            dcgmPolicyGet,
            dcgmPolicyRegister_v2,
            dcgmPolicyUnregister,
            dcgmActionValidate,
            dcgmActionValidate_v2,
            dcgmRunDiagnostic,
            dcgmPolicyTrigger,
            dcgmGetDeviceWorkloadPowerProfileInfo,
            dcgmGetDeviceTopology,
            dcgmGetGroupTopology,
            dcgmIntrospectGetHostengineMemoryUsage,
            dcgmIntrospectGetHostengineCpuUtilization,
            dcgmSelectGpusByTopology,
            dcgmModuleDenylist,
            dcgmModuleGetStatuses,
            dcgmProfGetSupportedMetricGroups,
            dcgmProfPause,
            dcgmProfResume,
            dcgmAddFakeInstances,
            dcgmErrorMeta,
            dcgmErrorGetPriorityByCode,
            dcgmErrorGetCategoryByCode,
            dcgmErrorGetFormatMsgByCode,
            dcgmGetErrorMeta,
        })
    }
    #[doc = " Get a pointer to the metadata for a field by its field ID. See DCGM_FI_? for a list of field IDs.\n\n @param fieldId     IN: One of the field IDs (DCGM_FI_?)\n\n @return\n        0     On Failure\n       >0     Pointer to field metadata structure if found.\n"]
    pub unsafe fn DcgmFieldGetById(&self, fieldId: ::std::os::raw::c_ushort) -> dcgm_field_meta_p {
        (self
            .DcgmFieldGetById
            .as_ref()
            .expect("Expected function, got error."))(fieldId)
    }
    #[doc = " Get a pointer to the metadata for a field by its field tag.\n\n @param tag       IN: Tag for the field of interest\n\n @return\n        0     On failure or not found\n       >0     Pointer to field metadata structure if found\n"]
    pub unsafe fn DcgmFieldGetByTag(
        &self,
        tag: *const ::std::os::raw::c_char,
    ) -> dcgm_field_meta_p {
        (self
            .DcgmFieldGetByTag
            .as_ref()
            .expect("Expected function, got error."))(tag)
    }
    #[doc = " Initialize the DcgmFields module. Call this once from inside\n your program\n\n @return\n        0     On success\n       <0     On error\n"]
    pub unsafe fn DcgmFieldsInit(&self) -> ::std::os::raw::c_int {
        (self
            .DcgmFieldsInit
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Terminates the DcgmFields module. Call this once from inside your program\n\n @return\n        0     On success\n       <0     On error\n"]
    pub unsafe fn DcgmFieldsTerm(&self) -> ::std::os::raw::c_int {
        (self
            .DcgmFieldsTerm
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Get the string version of a entityGroupId\n\n @returns\n         - Pointer to a string like GPU/NvSwitch..etc\n         - Null on error\n"]
    pub unsafe fn DcgmFieldsGetEntityGroupString(
        &self,
        entityGroupId: dcgm_field_entity_group_t,
    ) -> *const ::std::os::raw::c_char {
        (self
            .DcgmFieldsGetEntityGroupString
            .as_ref()
            .expect("Expected function, got error."))(entityGroupId)
    }
    #[doc = " This function describes DCGM error codes in human readable form\n\n @param[in] result    - DCGM return code to describe\n\n @return\n          - Human readable string with the DCGM error code description if the code is valid.\n          - nullptr if there is not such error code"]
    pub unsafe fn errorString(&self, result: dcgmReturn_t) -> *const ::std::os::raw::c_char {
        (self
            .errorString
            .as_ref()
            .expect("Expected function, got error."))(result)
    }
    #[doc = " This method is used to initialize DCGM within this process. This must be called before\n dcgmStartEmbedded() or dcgmConnect()\n\n  * @return\n        - \\ref DCGM_ST_OK                   if DCGM has been properly initialized\n        - \\ref DCGM_ST_INIT_ERROR           if there was an error initializing the library"]
    pub unsafe fn dcgmInit(&self) -> dcgmReturn_t {
        (self
            .dcgmInit
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " This method is used to shut down DCGM. Any embedded host engines or remote connections will automatically\n be shut down as well.\n\n @return\n        - \\ref DCGM_ST_OK                   if DCGM has been properly shut down\n        - \\ref DCGM_ST_UNINITIALIZED        if the library was not shut down properly"]
    pub unsafe fn dcgmShutdown(&self) -> dcgmReturn_t {
        (self
            .dcgmShutdown
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Start an embedded host engine agent within this process.\n\n The agent is loaded as a shared library. This mode is provided to avoid any\n extra jitter associated with an additional autonomous agent needs to be managed. In\n this mode, the user has to periodically call APIs such as \\ref dcgmPolicyTrigger and\n \\ref dcgmUpdateAllFields which tells DCGM to wake up and perform data collection and\n operations needed for policy management.\n\n @param opMode       IN: Collect data automatically or manually when asked by the user.\n @param pDcgmHandle OUT: DCGM Handle to use for API calls\n\n @return\n         - \\ref DCGM_ST_OK                if DCGM was started successfully within our process\n         - \\ref DCGM_ST_UNINITIALIZED     if DCGM has not been initialized with \\ref dcgmInit yet\n"]
    pub unsafe fn dcgmStartEmbedded(
        &self,
        opMode: dcgmOperationMode_t,
        pDcgmHandle: *mut dcgmHandle_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmStartEmbedded
            .as_ref()
            .expect("Expected function, got error."))(opMode, pDcgmHandle)
    }
    #[doc = " Start an embedded host engine agent within this process.\n\n The agent is loaded as a shared library. This mode is provided to avoid any\n extra jitter associated with an additional autonomous agent needs to be managed. In\n this mode, the user has to periodically call APIs such as \\c dcgmPolicyTrigger and\n \\c dcgmUpdateAllFields which tells DCGM to wake up and perform data collection and\n operations needed for policy management.\n\n @param[in,out] params    A pointer to either \\c dcgmStartEmbeddedV2Params_v1 or \\c dcgmStartEmbeddedV2Params_v2.\n\n @return \\c DCGM_ST_OK                if DCGM was started successfully within our process\n @return \\c DCGM_ST_UNINITIALIZED     if DCGM has not been initialized with \\c dcgmInit yet\n @note This function has a versioned argument that can be actually called with two different types. The behavior will\n       depend on the params->version value.\n @see dcgmStartEmbeddedV2Params_v1\n @see dcgmStartEmbeddedV2Params_v2"]
    pub unsafe fn dcgmStartEmbedded_v2(
        &self,
        params: *mut dcgmStartEmbeddedV2Params_v1,
    ) -> dcgmReturn_t {
        (self
            .dcgmStartEmbedded_v2
            .as_ref()
            .expect("Expected function, got error."))(params)
    }
    #[doc = " Stop the embedded host engine within this process that was started with dcgmStartEmbedded\n\n @param pDcgmHandle IN : DCGM Handle of the embedded host engine that came from dcgmStartEmbedded\n\n @return\n         - \\ref DCGM_ST_OK                if DCGM was stopped successfully within our process\n         - \\ref DCGM_ST_UNINITIALIZED     if DCGM has not been initialized with \\ref dcgmInit or\n                                          the embedded host engine was not running.\n         - \\ref DCGM_ST_BADPARAM          if an invalid parameter was provided\n         - \\ref DCGM_ST_INIT_ERROR        if an error occurred while trying to start the host engine."]
    pub unsafe fn dcgmStopEmbedded(&self, pDcgmHandle: dcgmHandle_t) -> dcgmReturn_t {
        (self
            .dcgmStopEmbedded
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle)
    }
    #[doc = " This method is used to connect to a stand-alone host engine process. Remote host engines are started\n by running the nv-hostengine command.\n\n NOTE: dcgmConnect_v2 provides additional connection options.\n\n @param ipAddress    IN: Valid IP address for the remote host engine to connect to.\n                         If ipAddress is specified as x.x.x.x it will attempt to connect to the default\n                         port specified by DCGM_HE_PORT_NUMBER\n                         If ipAddress is specified as x.x.x.x:yyyy it will attempt to connect to the\n                         port specified by yyyy\n @param pDcgmHandle OUT: DCGM Handle of the remote host engine\n\n @return\n         - \\ref DCGM_ST_OK                   if we successfully connected to the remote host engine\n         - \\ref DCGM_ST_CONNECTION_NOT_VALID if the remote host engine could not be reached\n         - \\ref DCGM_ST_UNINITIALIZED        if DCGM has not been initialized with \\ref dcgmInit.\n         - \\ref DCGM_ST_BADPARAM             if pDcgmHandle is NULL or ipAddress is invalid\n         - \\ref DCGM_ST_INIT_ERROR           if DCGM encountered an error while initializing the remote client library\n         - \\ref DCGM_ST_UNINITIALIZED        if DCGM has not been initialized with \\ref dcgmInit"]
    pub unsafe fn dcgmConnect(
        &self,
        ipAddress: *const ::std::os::raw::c_char,
        pDcgmHandle: *mut dcgmHandle_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmConnect
            .as_ref()
            .expect("Expected function, got error."))(ipAddress, pDcgmHandle)
    }
    #[doc = " This method is used to connect to a stand-alone host engine process. Remote host engines are started\n by running the nv-hostengine command.\n\n @param ipAddress     IN: Valid IP address for the remote host engine to connect to.\n                          If ipAddress is specified as x.x.x.x it will attempt to connect to the default port\n                          specified by DCGM_HE_PORT_NUMBER.\n                          If ipAddress is specified as x.x.x.x:yyyy it will attempt to connect to the port\n                          specified by yyyy\n @param connectParams IN: Additional connection parameters. See \\ref dcgmConnectV2Params_t for details.\n @param pDcgmHandle  OUT: DCGM Handle of the remote host engine\n\n @return\n         - \\ref DCGM_ST_OK                   if we successfully connected to the remote host engine\n         - \\ref DCGM_ST_CONNECTION_NOT_VALID if the remote host engine could not be reached\n         - \\ref DCGM_ST_UNINITIALIZED        if DCGM has not been initialized with \\ref dcgmInit.\n         - \\ref DCGM_ST_BADPARAM             if pDcgmHandle is NULL or ipAddress is invalid\n         - \\ref DCGM_ST_INIT_ERROR           if DCGM encountered an error while initializing the remote client library\n         - \\ref DCGM_ST_UNINITIALIZED        if DCGM has not been initialized with \\ref dcgmInit"]
    pub unsafe fn dcgmConnect_v2(
        &self,
        ipAddress: *const ::std::os::raw::c_char,
        connectParams: *mut dcgmConnectV2Params_t,
        pDcgmHandle: *mut dcgmHandle_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmConnect_v2
            .as_ref()
            .expect("Expected function, got error."))(ipAddress, connectParams, pDcgmHandle)
    }
    #[doc = " This method is used to disconnect from a stand-alone host engine process.\n\n @param pDcgmHandle IN: DCGM Handle that came from dcgmConnect\n\n @return\n         - \\ref DCGM_ST_OK                if we successfully disconnected from the host engine\n         - \\ref DCGM_ST_UNINITIALIZED     if DCGM has not been initialized with \\ref dcgmInit\n         - \\ref DCGM_ST_BADPARAM          if pDcgmHandle is not a valid DCGM handle\n         - \\ref DCGM_ST_GENERIC_ERROR     if an unspecified internal error occurred"]
    pub unsafe fn dcgmDisconnect(&self, pDcgmHandle: dcgmHandle_t) -> dcgmReturn_t {
        (self
            .dcgmDisconnect
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle)
    }
    #[doc = " This method is used to return information about the build environment where DCGM was built.\n\n @param pVersionInfo OUT: Build environment information\n\n @return\n          - \\ref DCGM_ST_OK           if build information is sucessfully obtained\n          - \\ref DCGM_ST_BADPARAM     if pVersionInfo is null\n          - \\ref DCGM_ST_VER_MISMATCH if the expected and provided versions of dcgmVersionInfo_t do not match"]
    pub unsafe fn dcgmVersionInfo(&self, pVersionInfo: *mut dcgmVersionInfo_t) -> dcgmReturn_t {
        (self
            .dcgmVersionInfo
            .as_ref()
            .expect("Expected function, got error."))(pVersionInfo)
    }
    #[doc = " This method is used to return information about the build environment of the hostengine.\n\n @param pDcgmHandle  IN:  DCGM Handle that came from dcgmConnect\n @param pVersionInfo OUT: Build environment information\n\n @return\n          - \\ref DCGM_ST_OK           if build information is sucessfully obtained\n          - \\ref DCGM_ST_BADPARAM     if pVersionInfo is null\n          - \\ref DCGM_ST_VER_MISMATCH if the expected and provided versions of dcgmVersionInfo_t do not match"]
    pub unsafe fn dcgmHostengineVersionInfo(
        &self,
        pDcgmHandle: dcgmHandle_t,
        pVersionInfo: *mut dcgmVersionInfo_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmHostengineVersionInfo
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, pVersionInfo)
    }
    #[doc = " This method is used to set the logging severity on HostEngine for the specified logger\n\n @param pDcgmHandle  IN: DCGM Handle\n @param logging      IN: dcgmSettingsSetLoggingSeverity_t struct containing the target logger and severity\n\n @return\n          - \\ref DCGM_ST_OK           Severity successfuly set\n          - \\ref DCGM_ST_BADPARAM     Bad logger/severity string\n          - \\ref DCGM_ST_VER_MISMATCH if the expected and provided versions of dcgmSettingsSetLoggingSeverity_t\n                                      do not match"]
    pub unsafe fn dcgmHostengineSetLoggingSeverity(
        &self,
        pDcgmHandle: dcgmHandle_t,
        logging: *mut dcgmSettingsSetLoggingSeverity_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmHostengineSetLoggingSeverity
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, logging)
    }
    #[doc = " This function is used to return whether or not the host engine considers itself healthy\n\n @param[in]  pDcgmHandle - the handle to DCGM\n @param[out] heHealth - struct describing the health of the hostengine. if heHealth.hostengineHealth is 0,\n                        then the hostengine is healthy. Non-zero indicates not healthy with error codes\n                        determining the cause.\n\n @return\n          - \\ref DCGM_ST_OK         Able to gauge health\n          - \\ref DCGM_ST_BADPARAM   isHealthy is not a valid pointer"]
    pub unsafe fn dcgmHostengineIsHealthy(
        &self,
        pDcgmHandle: dcgmHandle_t,
        heHealth: *mut dcgmHostengineHealth_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmHostengineIsHealthy
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, heHealth)
    }
    #[doc = " This function describes DCGM Module by given Module ID\n\n @param id[in]        - Module ID to name.\n @param name[out]     - Module name will be provided via this argument.\n @return\n          - \\ref DCGM_ST_OK           Module name has valid value\n          - \\ref DCGM_ST_BADPARAM     There is no module with specified ID. Name value is not changed."]
    pub unsafe fn dcgmModuleIdToName(
        &self,
        id: dcgmModuleId_t,
        name: *mut *const ::std::os::raw::c_char,
    ) -> dcgmReturn_t {
        (self
            .dcgmModuleIdToName
            .as_ref()
            .expect("Expected function, got error."))(id, name)
    }
    #[doc = " This method is used to get identifiers corresponding to all the devices on the system. The\n identifier represents DCGM GPU Id corresponding to each GPU on the system and is immutable during\n the lifespan of the engine. The list should be queried again if the engine is restarted.\n\n The GPUs returned from this function include gpuIds of GPUs that are not supported by DCGM.\n To only get gpuIds of GPUs that are supported by DCGM, use dcgmGetAllSupportedDevices().\n\n @param pDcgmHandle                    IN: DCGM Handle\n @param gpuIdList                     OUT: Array reference to fill GPU Ids present on the system.\n @param count                         OUT: Number of GPUs returned in \\a gpuIdList.\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful.\n        - \\ref DCGM_ST_BADPARAM             if \\a gpuIdList or \\a count were not valid."]
    pub unsafe fn dcgmGetAllDevices(
        &self,
        pDcgmHandle: dcgmHandle_t,
        gpuIdList: *mut ::std::os::raw::c_uint,
        count: *mut ::std::os::raw::c_int,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetAllDevices
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, gpuIdList, count)
    }
    #[doc = " This method is used to get identifiers corresponding to all the DCGM-supported devices on the system. The\n identifier represents DCGM GPU Id corresponding to each GPU on the system and is immutable during\n the lifespan of the engine. The list should be queried again if the engine is restarted.\n\n The GPUs returned from this function ONLY includes gpuIds of GPUs that are supported by DCGM.\n To get gpuIds of all GPUs in the system, use dcgmGetAllDevices().\n\n\n @param pDcgmHandle                    IN: DCGM Handle\n @param gpuIdList                     OUT: Array reference to fill GPU Ids present on the system.\n @param count                         OUT: Number of GPUs returned in \\a gpuIdList.\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful.\n        - \\ref DCGM_ST_BADPARAM             if \\a gpuIdList or \\a count were not valid."]
    pub unsafe fn dcgmGetAllSupportedDevices(
        &self,
        pDcgmHandle: dcgmHandle_t,
        gpuIdList: *mut ::std::os::raw::c_uint,
        count: *mut ::std::os::raw::c_int,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetAllSupportedDevices
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, gpuIdList, count)
    }
    #[doc = " Gets device attributes corresponding to the \\a gpuId. If operation is not successful for any of\n the requested fields then the field is populated with one of DCGM_BLANK_VALUES defined in\n dcgm_structs.h.\n\n @param pDcgmHandle    IN: DCGM Handle\n @param gpuId          IN: GPU Id corresponding to which the attributes should be fetched\n @param pDcgmAttr  IN/OUT: Device attributes corresponding to \\a gpuId.<br> pDcgmAttr->version should be set to\n                           \\ref dcgmDeviceAttributes_version before this call.\n\n @return\n        - \\ref DCGM_ST_OK            if the call was successful.\n        - \\ref DCGM_ST_VER_MISMATCH  if pDcgmAttr->version is not set or is invalid."]
    pub unsafe fn dcgmGetDeviceAttributes(
        &self,
        pDcgmHandle: dcgmHandle_t,
        gpuId: ::std::os::raw::c_uint,
        pDcgmAttr: *mut dcgmDeviceAttributes_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetDeviceAttributes
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, gpuId, pDcgmAttr)
    }
    #[doc = " Gets the list of entities that exist for a given entity group. This API can be used in place of\n \\ref dcgmGetAllDevices.\n\n @param dcgmHandle      IN: DCGM Handle\n @param entityGroup     IN: Entity group to list entities of\n @param entities       OUT: Array of entities for entityGroup\n @param numEntities IN/OUT: Upon calling, this should be the number of entities that entityList[] can hold. Upon\n                            return, this will contain the number of entities actually saved to entityList.\n @param flags           IN: Flags to modify the behavior of this request.\n                            See DCGM_GEGE_FLAG_* #defines in dcgm_structs.h\n\n @return\n        - \\ref DCGM_ST_OK                if the call was successful.\n        - \\ref DCGM_ST_INSUFFICIENT_SIZE if numEntities was not large enough to hold the number of entities in the\n                                         entityGroup. numEntities will contain the capacity needed to complete this\n                                         request successfully.\n        - \\ref DCGM_ST_NOT_SUPPORTED     if the given entityGroup does not support enumeration.\n        - \\ref DCGM_ST_BADPARAM          if any parameter is invalid"]
    pub unsafe fn dcgmGetEntityGroupEntities(
        &self,
        dcgmHandle: dcgmHandle_t,
        entityGroup: dcgm_field_entity_group_t,
        entities: *mut dcgm_field_eid_t,
        numEntities: *mut ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetEntityGroupEntities
            .as_ref()
            .expect("Expected function, got error."))(
            dcgmHandle,
            entityGroup,
            entities,
            numEntities,
            flags,
        )
    }
    #[doc = " Gets the hierarchy of GPUs, GPU Instances, and Compute Instances.\n\n @param dcgmHandle       IN: DCGM Handle\n @param hierarchy       OUT: Hierarchy of GPUs, GPU Instances, and Compute Instances\n\n @return\n        - \\ref DCGM_ST_OK                if the call was successful.\n        - \\ref DCGM_ST_VER_MISMATCH      if the struct version is incorrect\n        - \\ref DCGM_ST_BADPARAM          if any parameter is invalid"]
    pub unsafe fn dcgmGetGpuInstanceHierarchy(
        &self,
        dcgmHandle: dcgmHandle_t,
        hierarchy: *mut dcgmMigHierarchy_v2,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetGpuInstanceHierarchy
            .as_ref()
            .expect("Expected function, got error."))(dcgmHandle, hierarchy)
    }
    #[doc = " Get the NvLink link status for every NvLink in this system. This includes the NvLinks of both GPUs and\n NvSwitches. Note that only NvSwitches and GPUs that are visible to the current environment will be\n returned in this structure.\n\n @param dcgmHandle  IN: DCGM Handle\n @param linkStatus OUT: Structure in which to store NvLink link statuses. .version should be set to\n                        dcgmNvLinkStatus_version1 before calling this.\n\n @return\n        - \\ref DCGM_ST_OK                if the call was successful.\n        - \\ref DCGM_ST_NOT_SUPPORTED     if the given entityGroup does not support enumeration.\n        - \\ref DCGM_ST_BADPARAM          if any parameter is invalid"]
    pub unsafe fn dcgmGetNvLinkLinkStatus(
        &self,
        dcgmHandle: dcgmHandle_t,
        linkStatus: *mut dcgmNvLinkStatus_v4,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetNvLinkLinkStatus
            .as_ref()
            .expect("Expected function, got error."))(dcgmHandle, linkStatus)
    }
    #[doc = " List supported CPUs and their cores present on the system\n\n This and other CPU APIs only support datacenter NVIDIA CPUs.  Use \\ref dcgmGetCpuHierarchy_v2 to\n get additional CPU information.\n\n @param dcgmHandle   IN: DCGM Handle\n @param cpuHierarchy OUT: Structure where the CPUs and their associated cores will be enumerated\n\n @return\n        - \\ref DCGM_ST_OK                if the call was successful.\n        - \\ref DCGM_ST_NOT_SUPPORTED     if the device is unsupported\n        - \\ref DCGM_ST_MODULE_NOT_LOADED if the sysmon module could not be loaded\n        - \\ref DCGM_ST_BADPARAM          if any parameter is invalid"]
    pub unsafe fn dcgmGetCpuHierarchy(
        &self,
        dcgmHandle: dcgmHandle_t,
        cpuHierarchy: *mut dcgmCpuHierarchy_v1,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetCpuHierarchy
            .as_ref()
            .expect("Expected function, got error."))(dcgmHandle, cpuHierarchy)
    }
    #[doc = " List supported CPUs and their cores present on the system\n\n This and other CPU APIs only support datacenter NVIDIA CPUs.\n\n @param dcgmHandle   IN: DCGM Handle\n @param cpuHierarchy OUT: Structure where the CPUs and their associated cores will be enumerated\n\n @return\n        - \\ref DCGM_ST_OK                if the call was successful.\n        - \\ref DCGM_ST_NOT_SUPPORTED     if the device is unsupported\n        - \\ref DCGM_ST_MODULE_NOT_LOADED if the sysmon module could not be loaded\n        - \\ref DCGM_ST_BADPARAM          if any parameter is invalid"]
    pub unsafe fn dcgmGetCpuHierarchy_v2(
        &self,
        dcgmHandle: dcgmHandle_t,
        cpuHierarchy: *mut dcgmCpuHierarchy_v2,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetCpuHierarchy_v2
            .as_ref()
            .expect("Expected function, got error."))(dcgmHandle, cpuHierarchy)
    }
    #[doc = " Used to create a entity group handle which can store one or more entity Ids as an opaque handle\n returned in \\a pDcgmGrpId. Instead of executing an operation separately for each entity, the\n DCGM group enables the user to execute same operation on all the entities present in the group as a\n single API call.\n\n To create the group with all the entities present on the system, the \\a type field should be\n specified as \\a DCGM_GROUP_DEFAULT or \\a DCGM_GROUP_ALL_NVSWITCHES. To create an empty group,\n the \\a type field should be specified as \\a DCGM_GROUP_EMPTY. The empty group can be updated\n with the desired set of entities using the APIs \\ref dcgmGroupAddDevice, \\ref dcgmGroupAddEntity,\n \\ref dcgmGroupRemoveDevice, and \\ref dcgmGroupRemoveEntity.\n\n @param pDcgmHandle    IN: DCGM Handle\n @param type           IN: Type of Entity Group to be formed\n @param groupName      IN: Desired name of the GPU group specified as NULL terminated C string\n @param pDcgmGrpId    OUT: Reference to group ID\n\n @return\n  - \\ref DCGM_ST_OK                if the group has been created\n  - \\ref DCGM_ST_BADPARAM          if any of \\a type, \\a groupName, \\a length or \\a pDcgmGrpId is invalid\n  - \\ref DCGM_ST_MAX_LIMIT         if number of groups on the system has reached the max limit \\a DCGM_MAX_NUM_GROUPS\n  - \\ref DCGM_ST_INIT_ERROR        if the library has not been successfully initialized"]
    pub unsafe fn dcgmGroupCreate(
        &self,
        pDcgmHandle: dcgmHandle_t,
        type_: dcgmGroupType_t,
        groupName: *const ::std::os::raw::c_char,
        pDcgmGrpId: *mut dcgmGpuGrp_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmGroupCreate
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle, type_, groupName, pDcgmGrpId
        )
    }
    #[doc = " Used to destroy a group represented by \\a groupId.\n Since DCGM group is a logical grouping of entities, the properties applied on the group stay intact\n for the individual entities even after the group is destroyed.\n\n @param pDcgmHandle   IN: DCGM Handle\n @param groupId       IN: Group ID\n\n @return\n  - \\ref DCGM_ST_OK                   if the group has been destroyed\n  - \\ref DCGM_ST_BADPARAM             if \\a groupId is invalid\n  - \\ref DCGM_ST_INIT_ERROR           if the library has not been successfully initialized\n  - \\ref DCGM_ST_NOT_CONFIGURED       if entry corresponding to the group does not exists"]
    pub unsafe fn dcgmGroupDestroy(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmGroupDestroy
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, groupId)
    }
    #[doc = " Used to add specified GPU Id to the group represented by \\a groupId.\n\n @param pDcgmHandle   IN: DCGM Handle\n @param groupId       IN: Group Id to which device should be added\n @param gpuId         IN: DCGM GPU Id\n\n @return\n  - \\ref DCGM_ST_OK                   if the GPU Id has been successfully added to the group\n  - \\ref DCGM_ST_INIT_ERROR           if the library has not been successfully initialized\n  - \\ref DCGM_ST_NOT_CONFIGURED       if entry corresponding to the group (\\a groupId) does not exists\n  - \\ref DCGM_ST_BADPARAM             if \\a gpuId is invalid or already part of the specified group"]
    pub unsafe fn dcgmGroupAddDevice(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        gpuId: ::std::os::raw::c_uint,
    ) -> dcgmReturn_t {
        (self
            .dcgmGroupAddDevice
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, groupId, gpuId)
    }
    #[doc = " Used to add specified entity to the group represented by \\a groupId.\n\n @param pDcgmHandle   IN: DCGM Handle\n @param groupId       IN: Group Id to which device should be added\n @param entityGroupId IN: Entity group that entityId belongs to\n @param entityId      IN: DCGM entityId\n\n @return\n  - \\ref DCGM_ST_OK                   if the entity has been successfully added to the group\n  - \\ref DCGM_ST_INIT_ERROR           if the library has not been successfully initialized\n  - \\ref DCGM_ST_NOT_CONFIGURED       if entry corresponding to the group (\\a groupId) does not exists\n  - \\ref DCGM_ST_BADPARAM             if \\a entityId is invalid or already part of the specified group"]
    pub unsafe fn dcgmGroupAddEntity(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        entityGroupId: dcgm_field_entity_group_t,
        entityId: dcgm_field_eid_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmGroupAddEntity
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle, groupId, entityGroupId, entityId
        )
    }
    #[doc = " Used to remove specified GPU Id from the group represented by \\a groupId.\n @param pDcgmHandle   IN: DCGM Handle\n @param groupId       IN: Group ID from which device should be removed\n @param gpuId         IN: DCGM GPU Id\n\n @return\n  - \\ref DCGM_ST_OK                   if the GPU Id has been successfully removed from the group\n  - \\ref DCGM_ST_INIT_ERROR           if the library has not been successfully initialized\n  - \\ref DCGM_ST_NOT_CONFIGURED       if entry corresponding to the group (\\a groupId) does not exists\n  - \\ref DCGM_ST_BADPARAM             if \\a gpuId is invalid or not part of the specified group"]
    pub unsafe fn dcgmGroupRemoveDevice(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        gpuId: ::std::os::raw::c_uint,
    ) -> dcgmReturn_t {
        (self
            .dcgmGroupRemoveDevice
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, groupId, gpuId)
    }
    #[doc = " Used to remove specified entity from the group represented by \\a groupId.\n @param pDcgmHandle   IN: DCGM Handle\n @param groupId       IN: Group ID from which device should be removed\n @param entityGroupId IN: Entity group that entityId belongs to\n @param entityId      IN: DCGM entityId\n\n @return\n  - \\ref DCGM_ST_OK                   if the entity has been successfully removed from the group\n  - \\ref DCGM_ST_INIT_ERROR           if the library has not been successfully initialized\n  - \\ref DCGM_ST_NOT_CONFIGURED       if entry corresponding to the group (\\a groupId) does not exists\n  - \\ref DCGM_ST_BADPARAM             if \\a entityId is invalid or not part of the specified group"]
    pub unsafe fn dcgmGroupRemoveEntity(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        entityGroupId: dcgm_field_entity_group_t,
        entityId: dcgm_field_eid_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmGroupRemoveEntity
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle, groupId, entityGroupId, entityId
        )
    }
    #[doc = " Used to get information corresponding to the group represented by \\a groupId. The information\n returned in \\a pDcgmGroupInfo consists of group name, and the list of entities present in the\n group.\n\n @param pDcgmHandle        IN: DCGM Handle\n @param groupId            IN: Group ID for which information to be fetched\n @param pDcgmGroupInfo    OUT: Group Information\n\n @return\n  - \\ref DCGM_ST_OK                   if the group info is successfully received.\n  - \\ref DCGM_ST_BADPARAM             if any of \\a groupId or \\a pDcgmGroupInfo is invalid.\n  - \\ref DCGM_ST_INIT_ERROR           if the library has not been successfully initialized.\n  - \\ref DCGM_ST_MAX_LIMIT            if the group does not contain the GPU\n  - \\ref DCGM_ST_NOT_CONFIGURED       if entry corresponding to the group (\\a groupId) does not exists"]
    pub unsafe fn dcgmGroupGetInfo(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        pDcgmGroupInfo: *mut dcgmGroupInfo_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmGroupGetInfo
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, groupId, pDcgmGroupInfo)
    }
    #[doc = " Used to get the Ids of all groups of entities. The information returned is a list of group ids\n in \\a groupIdList as well as a count of how many ids there are in \\a count. Please allocate enough\n memory for \\a groupIdList. Memory of size MAX_NUM_GROUPS should be allocated for \\a groupIdList.\n\n @param pDcgmHandle        IN: DCGM Handle\n @param groupIdList       OUT: List of Group Ids\n @param count             OUT: The number of Group ids in the list\n\n @return\n  - \\ref DCGM_ST_OK               if the ids of the groups were successfully retrieved\n  - \\ref DCGM_ST_BADPARAM         if either of the \\a groupIdList or \\a count is null\n  - \\ref DCGM_ST_GENERIC_ERROR    if an unknown error has occurred"]
    pub unsafe fn dcgmGroupGetAllIds(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupIdList: *mut dcgmGpuGrp_t,
        count: *mut ::std::os::raw::c_uint,
    ) -> dcgmReturn_t {
        (self
            .dcgmGroupGetAllIds
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, groupIdList, count)
    }
    #[doc = " Used to create a group of fields and return the handle in dcgmFieldGroupId\n\n @param dcgmHandle         IN: DCGM handle\n @param numFieldIds        IN: Number of field IDs that are being provided in fieldIds[]. Must be between 1 and\n                               DCGM_MAX_FIELD_IDS_PER_FIELD_GROUP.\n @param fieldIds           IN: Field IDs to be added to the newly-created field group\n @param fieldGroupName     IN: Unique name for this group of fields. This must not be the same as any existing field\n                               groups.\n @param dcgmFieldGroupId  OUT: Handle to the newly-created field group\n\n @return\n - \\ref DCGM_ST_OK                   if the field group was successfully created.\n - \\ref DCGM_ST_BADPARAM             if any parameters were bad\n - \\ref DCGM_ST_INIT_ERROR           if the library has not been successfully initialized.\n - \\ref DCGM_ST_MAX_LIMIT            if too many field groups already exist\n"]
    pub unsafe fn dcgmFieldGroupCreate(
        &self,
        dcgmHandle: dcgmHandle_t,
        numFieldIds: ::std::os::raw::c_int,
        fieldIds: *mut ::std::os::raw::c_ushort,
        fieldGroupName: *const ::std::os::raw::c_char,
        dcgmFieldGroupId: *mut dcgmFieldGrp_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmFieldGroupCreate
            .as_ref()
            .expect("Expected function, got error."))(
            dcgmHandle,
            numFieldIds,
            fieldIds,
            fieldGroupName,
            dcgmFieldGroupId,
        )
    }
    #[doc = " Used to remove a field group that was created with \\ref dcgmFieldGroupCreate\n\n @param dcgmHandle         IN: DCGM handle\n @param dcgmFieldGroupId   IN: Field group to remove\n\n @return\n - \\ref DCGM_ST_OK                   if the field group was successfully removed\n - \\ref DCGM_ST_BADPARAM             if any parameters were bad\n - \\ref DCGM_ST_INIT_ERROR           if the library has not been successfully initialized.\n"]
    pub unsafe fn dcgmFieldGroupDestroy(
        &self,
        dcgmHandle: dcgmHandle_t,
        dcgmFieldGroupId: dcgmFieldGrp_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmFieldGroupDestroy
            .as_ref()
            .expect("Expected function, got error."))(dcgmHandle, dcgmFieldGroupId)
    }
    #[doc = " Used to get information about a field group that was created with \\ref dcgmFieldGroupCreate.\n\n @param dcgmHandle         IN: DCGM handle\n @param fieldGroupInfo IN/OUT: Info about all of the field groups that exist.<br>\n                               .version should be set to \\ref dcgmFieldGroupInfo_version before this call<br>\n                               .fieldGroupId should contain the fieldGroupId you are interested in querying\n                               information for.\n\n @return\n - \\ref DCGM_ST_OK                   if the field group info was returned successfully\n - \\ref DCGM_ST_BADPARAM             if any parameters were bad\n - \\ref DCGM_ST_INIT_ERROR           if the library has not been successfully initialized.\n - \\ref DCGM_ST_VER_MISMATCH         if .version is not set or is invalid.\n"]
    pub unsafe fn dcgmFieldGroupGetInfo(
        &self,
        dcgmHandle: dcgmHandle_t,
        fieldGroupInfo: *mut dcgmFieldGroupInfo_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmFieldGroupGetInfo
            .as_ref()
            .expect("Expected function, got error."))(dcgmHandle, fieldGroupInfo)
    }
    #[doc = " Used to get information about all field groups in the system.\n\n @param dcgmHandle         IN: DCGM handle\n @param allGroupInfo   IN/OUT: Info about all of the field groups that exist.<br>\n                               .version should be set to \\ref dcgmAllFieldGroup_version before this call.\n\n @return\n - \\ref DCGM_ST_OK                   if the field group info was successfully returned\n - \\ref DCGM_ST_BADPARAM             if any parameters were bad\n - \\ref DCGM_ST_INIT_ERROR           if the library has not been successfully initialized.\n - \\ref DCGM_ST_VER_MISMATCH         if .version is not set or is invalid.\n"]
    pub unsafe fn dcgmFieldGroupGetAll(
        &self,
        dcgmHandle: dcgmHandle_t,
        allGroupInfo: *mut dcgmAllFieldGroup_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmFieldGroupGetAll
            .as_ref()
            .expect("Expected function, got error."))(dcgmHandle, allGroupInfo)
    }
    #[doc = " Creates reference to DCGM status handler which can be used to get the statuses for multiple\n operations on one or more devices.\n\n The multiple statuses are useful when the operations are performed at group level. The status\n handle provides a mechanism to access error attributes for the failed operations.\n\n The number of errors stored behind the opaque handle can be accessed using the the API\n \\ref dcgmStatusGetCount. The errors are accessed from the opaque handle \\a statusHandle\n using the API \\ref dcgmStatusPopError. The user can invoke \\ref dcgmStatusPopError\n for the number of errors or until all the errors are fetched.\n\n When the status handle is not required any further then it should be deleted using the API\n \\ref dcgmStatusDestroy.\n @param statusHandle   OUT: Reference to handle for list of statuses\n\n @return\n  - \\ref DCGM_ST_OK                   if the status handle is successfully created\n  - \\ref DCGM_ST_BADPARAM             if \\a statusHandle is invalid\n"]
    pub unsafe fn dcgmStatusCreate(&self, statusHandle: *mut dcgmStatus_t) -> dcgmReturn_t {
        (self
            .dcgmStatusCreate
            .as_ref()
            .expect("Expected function, got error."))(statusHandle)
    }
    #[doc = " Used to destroy status handle created using \\ref dcgmStatusCreate.\n @param statusHandle   IN: Handle to list of statuses\n\n @return\n  - \\ref DCGM_ST_OK                   if the status handle is successfully created\n  - \\ref DCGM_ST_BADPARAM             if \\a statusHandle is invalid\n"]
    pub unsafe fn dcgmStatusDestroy(&self, statusHandle: dcgmStatus_t) -> dcgmReturn_t {
        (self
            .dcgmStatusDestroy
            .as_ref()
            .expect("Expected function, got error."))(statusHandle)
    }
    #[doc = " Used to get count of error entries stored inside the opaque handle \\a statusHandle.\n @param statusHandle   IN: Handle to list of statuses\n @param count         OUT: Number of error entries present in the list of statuses\n\n @return\n  - \\ref DCGM_ST_OK                   if the error count is successfully received\n  - \\ref DCGM_ST_BADPARAM             if any of \\a statusHandle or \\a count is invalid\n"]
    pub unsafe fn dcgmStatusGetCount(
        &self,
        statusHandle: dcgmStatus_t,
        count: *mut ::std::os::raw::c_uint,
    ) -> dcgmReturn_t {
        (self
            .dcgmStatusGetCount
            .as_ref()
            .expect("Expected function, got error."))(statusHandle, count)
    }
    #[doc = " Used to iterate through the list of errors maintained behind \\a statusHandle. The method pops the\n first error from the list of DCGM statuses. In order to iterate through all the errors, the user\n can invoke this API for the number of errors or until all the errors are fetched.\n @param statusHandle       IN: Handle to list of statuses\n @param pDcgmErrorInfo    OUT: First error from the list of statuses\n\n @return\n  - \\ref DCGM_ST_OK                   if the error entry is successfully fetched\n  - \\ref DCGM_ST_BADPARAM             if any of \\a statusHandle or \\a pDcgmErrorInfo is invalid\n  - \\ref DCGM_ST_NO_DATA              if the status handle list is empty\n"]
    pub unsafe fn dcgmStatusPopError(
        &self,
        statusHandle: dcgmStatus_t,
        pDcgmErrorInfo: *mut dcgmErrorInfo_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmStatusPopError
            .as_ref()
            .expect("Expected function, got error."))(statusHandle, pDcgmErrorInfo)
    }
    #[doc = " Used to clear all the errors in the status handle created by the API\n \\ref dcgmStatusCreate. After one set of operation, the \\a statusHandle\n can be cleared and reused for the next set of operation.\n @param statusHandle   IN: Handle to list of statuses\n\n @return\n  - \\ref DCGM_ST_OK                   if the errors are successfully cleared\n  - \\ref DCGM_ST_BADPARAM             if \\a statusHandle is invalid\n"]
    pub unsafe fn dcgmStatusClear(&self, statusHandle: dcgmStatus_t) -> dcgmReturn_t {
        (self
            .dcgmStatusClear
            .as_ref()
            .expect("Expected function, got error."))(statusHandle)
    }
    #[doc = " Used to set configuration for the group of one or more GPUs identified by \\a groupId.\n\n The configuration settings specified in \\a pDeviceConfig are applied to all the GPUs in the\n group. Since DCGM group is a logical grouping of GPUs, the configuration settings stays intact\n for the individual GPUs even after the group is destroyed.\n\n If the user wishes to ignore the configuration of one or more properties in the input\n \\a pDeviceConfig then the property should be specified as one of \\a DCGM_INT32_BLANK,\n \\a DCGM_INT64_BLANK, \\a DCGM_FP64_BLANK or \\a DCGM_STR_BLANK based on the data type of the\n property to be ignored.\n\n If any of the properties fail to be configured for any of the GPUs in the group then the API\n returns an error. The status handle \\a statusHandle should be further evaluated to access error\n attributes for the failed operations. Please refer to status management APIs at \\ref DCGMAPI_ST\n to access the error attributes.\n\n To find out valid supported clock values that can be passed to dcgmConfigSet, look at the device\n attributes of a GPU in the group using the API dcgmGetDeviceAttributes.\n\n @param pDcgmHandle            IN: DCGM Handle\n @param groupId                IN: Group ID representing collection of one or more GPUs. Look at \\ref dcgmGroupCreate\n                                   for details on creating the group.\n @param pDeviceConfig          IN: Pointer to memory to hold desired configuration to be applied for all the GPU in the\n                                   group represented by \\a groupId.\n                                   The caller must populate the version field of \\a pDeviceConfig.\n @param statusHandle       IN/OUT: Resulting error status for multiple operations. Pass it as NULL if the detailed\n                                   error information is not needed.\n                                   Look at \\ref dcgmStatusCreate for details on creating status handle.\n\n @return\n        - \\ref DCGM_ST_OK                   if the configuration has been successfully set.\n        - \\ref DCGM_ST_BADPARAM             if any of \\a groupId or \\a pDeviceConfig is invalid.\n        - \\ref DCGM_ST_VER_MISMATCH         if \\a pDeviceConfig has the incorrect version.\n        - \\ref DCGM_ST_GENERIC_ERROR        if an unknown error has occurred."]
    pub unsafe fn dcgmConfigSet(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        pDeviceConfig: *mut dcgmConfig_t,
        statusHandle: dcgmStatus_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmConfigSet
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle,
            groupId,
            pDeviceConfig,
            statusHandle,
        )
    }
    #[doc = " Used to get configuration for all the GPUs present in the group.\n\n This API can get the most recent target or desired configuration set by \\ref dcgmConfigSet.\n Set type as \\a DCGM_CONFIG_TARGET_STATE to get target configuration. The target configuration\n properties are maintained by DCGM and are automatically enforced after a GPU reset or\n reinitialization is completed.\n\n The method can also be used to get the actual configuration state for the GPUs in the group.\n Set type as \\a DCGM_CONFIG_CURRENT_STATE to get the actually configuration state. Ideally, the\n actual configuration state will be exact same as the target configuration state.\n\n If any of the property in the target configuration is unknown then the property value in the\n output is populated as  one of DCGM_INT32_BLANK, DCGM_INT64_BLANK, DCGM_FP64_BLANK or\n DCGM_STR_BLANK based on the data type of the property.\n\n If any of the property in the current configuration state is not supported then the property\n value in the output is populated as one of DCGM_INT32_NOT_SUPPORTED, DCGM_INT64_NOT_SUPPORTED,\n DCGM_FP64_NOT_SUPPORTED or DCGM_STR_NOT_SUPPORTED based on the data type of the property.\n\n If any of the properties can't be fetched for any of the GPUs in the group then the API returns\n an error. The status handle \\a statusHandle should be further evaluated to access error\n attributes for the failed operations. Please refer to status management APIs at \\ref DCGMAPI_ST\n to access the error attributes.\n\n @param pDcgmHandle            IN: DCGM Handle\n @param groupId                IN: Group ID representing collection of one or more GPUs. Look at \\ref dcgmGroupCreate\n                                   for details on creating the group.\n @param type                   IN: Type of configuration values to be fetched.\n @param count                  IN: The number of entries that \\a deviceConfigList array can store.\n @param deviceConfigList      OUT: Pointer to memory to hold requested configuration corresponding to all the GPUs in\n                                   the group (\\a groupId). The size of the memory must be greater than or equal to hold\n                                   output information for the number of GPUs present in the group (\\a groupId).\n @param statusHandle       IN/OUT: Resulting error status for multiple operations. Pass it as NULL if the detailed\n                                   error information is not needed.\n                                   Look at \\ref dcgmStatusCreate for details on creating status handle.\n\n @return\n        - \\ref DCGM_ST_OK                   if the configuration has been successfully fetched.\n        - \\ref DCGM_ST_BADPARAM             if any of \\a groupId, \\a type, \\a count, or \\a deviceConfigList is invalid.\n        - \\ref DCGM_ST_NOT_CONFIGURED       if the target configuration is not already set.\n        - \\ref DCGM_ST_VER_MISMATCH         if \\a deviceConfigList has the incorrect version.\n        - \\ref DCGM_ST_GENERIC_ERROR        if an unknown error has occurred."]
    pub unsafe fn dcgmConfigGet(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        type_: dcgmConfigType_t,
        count: ::std::os::raw::c_int,
        deviceConfigList: *mut dcgmConfig_t,
        statusHandle: dcgmStatus_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmConfigGet
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle,
            groupId,
            type_,
            count,
            deviceConfigList,
            statusHandle,
        )
    }
    #[doc = " Used to enforce previously set configuration for all the GPUs present in the group.\n\n This API provides a mechanism to the users to manually enforce the configuration at any point of\n time. The configuration can only be enforced if it's already configured using the API \\ref\n dcgmConfigSet.\n\n If any of the properties can't be enforced for any of the GPUs in the group then the API returns\n an error. The status handle \\a statusHandle should be further evaluated to access error\n attributes for the failed operations. Please refer to status management APIs at \\ref DCGMAPI_ST\n to access the error attributes.\n\n @param pDcgmHandle            IN: DCGM Handle\n @param groupId                IN: Group ID representing collection of one or more GPUs. Look at \\ref dcgmGroupCreate\n                                   for details on creating the group. Alternatively, pass in the group id as\n                                   \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs.\n @param statusHandle       IN/OUT: Resulting error status for multiple operations. Pass it as NULL if the detailed\n                                   error information is not needed. Look at \\ref dcgmStatusCreate for details on\n                                   creating status handle.\n\n @return\n        - \\ref DCGM_ST_OK                   if the configuration has been successfully enforced.\n        - \\ref DCGM_ST_BADPARAM             if \\a groupId is invalid.\n        - \\ref DCGM_ST_NOT_CONFIGURED       if the target configuration is not already set.\n        - \\ref DCGM_ST_GENERIC_ERROR        if an unknown error has occurred.\n"]
    pub unsafe fn dcgmConfigEnforce(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        statusHandle: dcgmStatus_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmConfigEnforce
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, groupId, statusHandle)
    }
    #[doc = " Request that DCGM start recording updates for a given field collection.\n\n Note that the first update of the field will not occur until the next field update cycle.\n To force a field update cycle, call dcgmUpdateAllFields(1).\n\n @param pDcgmHandle         IN: DCGM Handle\n @param groupId             IN: Group ID representing collection of one or more entities. Look at \\ref dcgmGroupCreate\n                                for details on creating the group. Alternatively, pass in the group id as\n                                \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs or\n                                \\a DCGM_GROUP_ALL_NVSWITCHES to to perform the operation on all NvSwitches.\n @param fieldGroupId        IN: Fields to watch.\n @param updateFreq          IN: How often to update this field in usec\n @param maxKeepAge          IN: How long to keep data for this field in seconds\n @param maxKeepSamples      IN: Maximum number of samples to keep. 0=no limit\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n        - \\ref DCGM_ST_BADPARAM             if a parameter is invalid\n"]
    pub unsafe fn dcgmWatchFields(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        fieldGroupId: dcgmFieldGrp_t,
        updateFreq: ::std::os::raw::c_longlong,
        maxKeepAge: f64,
        maxKeepSamples: ::std::os::raw::c_int,
    ) -> dcgmReturn_t {
        (self
            .dcgmWatchFields
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle,
            groupId,
            fieldGroupId,
            updateFreq,
            maxKeepAge,
            maxKeepSamples,
        )
    }
    #[doc = " Request that DCGM stop recording updates for a given field collection.\n\n @param pDcgmHandle         IN: DCGM Handle\n @param groupId             IN: Group ID representing collection of one or more entities. Look at \\ref dcgmGroupCreate\n                                for details on creating the group. Alternatively, pass in the group id as\n                                \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs or\n                                \\a DCGM_GROUP_ALL_NVSWITCHES to to perform the operation on all NvSwitches.\n @param fieldGroupId        IN: Fields to unwatch.\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n        - \\ref DCGM_ST_BADPARAM             if a parameter is invalid\n"]
    pub unsafe fn dcgmUnwatchFields(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        fieldGroupId: dcgmFieldGrp_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmUnwatchFields
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, groupId, fieldGroupId)
    }
    #[doc = " Request updates for all field values that have updated since a given timestamp\n\n This version only works with GPU entities. Use \\ref dcgmGetValuesSince_v2 for entity groups\n containing NvSwitches.\n\n @param pDcgmHandle         IN: DCGM Handle\n @param groupId             IN: Group ID representing collection of one or more GPUs. Look at \\ref dcgmGroupCreate for\n                                details on creating the group. Alternatively, pass in the group id as\n                                \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs.\n @param fieldGroupId        IN: Fields to return data for\n @param sinceTimestamp      IN: Timestamp to request values since in usec since 1970. This will be returned in\n                                nextSinceTimestamp for subsequent calls 0 = request all data\n @param nextSinceTimestamp OUT: Timestamp to use for sinceTimestamp on next call to this function\n @param enumCB              IN: Callback to invoke for every field value update. Note that multiple updates can be\n                                returned in each invocation\n @param userData            IN: User data pointer to pass to the userData field of enumCB.\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n        - \\ref DCGM_ST_NOT_SUPPORTED        if one of the entities was from a non-GPU type\n        - \\ref DCGM_ST_BADPARAM             if a parameter is invalid\n"]
    pub unsafe fn dcgmGetValuesSince(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        fieldGroupId: dcgmFieldGrp_t,
        sinceTimestamp: ::std::os::raw::c_longlong,
        nextSinceTimestamp: *mut ::std::os::raw::c_longlong,
        enumCB: dcgmFieldValueEnumeration_f,
        userData: *mut ::std::os::raw::c_void,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetValuesSince
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle,
            groupId,
            fieldGroupId,
            sinceTimestamp,
            nextSinceTimestamp,
            enumCB,
            userData,
        )
    }
    #[doc = " Request updates for all field values that have updated since a given timestamp\n\n This version works with non-GPU entities like NvSwitches\n\n @param pDcgmHandle         IN: DCGM Handle\n @param groupId             IN: Group ID representing collection of one or more entities. Look at \\ref dcgmGroupCreate\n                                for details on creating the group. Alternatively, pass in the group id as\n                                \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs or\n                                \\a DCGM_GROUP_ALL_NVSWITCHES to perform the operation on all NvSwitches.\n @param fieldGroupId        IN: Fields to return data for\n @param sinceTimestamp      IN: Timestamp to request values since in usec since 1970. This will be returned in\n                                nextSinceTimestamp for subsequent calls 0 = request all data\n @param nextSinceTimestamp OUT: Timestamp to use for sinceTimestamp on next call to this function\n @param enumCB              IN: Callback to invoke for every field value update. Note that multiple updates can be\n                                returned in each invocation\n @param userData            IN: User data pointer to pass to the userData field of enumCB.\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n        - \\ref DCGM_ST_BADPARAM             if a parameter is invalid\n"]
    pub unsafe fn dcgmGetValuesSince_v2(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        fieldGroupId: dcgmFieldGrp_t,
        sinceTimestamp: ::std::os::raw::c_longlong,
        nextSinceTimestamp: *mut ::std::os::raw::c_longlong,
        enumCB: dcgmFieldValueEntityEnumeration_f,
        userData: *mut ::std::os::raw::c_void,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetValuesSince_v2
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle,
            groupId,
            fieldGroupId,
            sinceTimestamp,
            nextSinceTimestamp,
            enumCB,
            userData,
        )
    }
    #[doc = " Request latest cached field value for a field value collection\n\n This version only works with GPU entities. Use \\ref dcgmGetLatestValues_v2 for entity groups\n containing NvSwitches.\n\n @param pDcgmHandle        IN: DCGM Handle\n @param groupId            IN: Group ID representing collection of one or more GPUs. Look at \\ref dcgmGroupCreate for\n                               details on creating the group. Alternatively, pass in the group id as\n                               \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs.\n @param fieldGroupId       IN: Fields to return data for.\n @param enumCB             IN: Callback to invoke for every field value update. Note that multiple updates can be\n                               returned in each invocation\n @param userData           IN: User data pointer to pass to the userData field of enumCB.\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n        - \\ref DCGM_ST_NOT_SUPPORTED        if one of the entities was from a non-GPU type\n        - \\ref DCGM_ST_BADPARAM             if a parameter is invalid\n"]
    pub unsafe fn dcgmGetLatestValues(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        fieldGroupId: dcgmFieldGrp_t,
        enumCB: dcgmFieldValueEnumeration_f,
        userData: *mut ::std::os::raw::c_void,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetLatestValues
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle,
            groupId,
            fieldGroupId,
            enumCB,
            userData,
        )
    }
    #[doc = " Request latest cached field value for a field value collection\n\n This version works with non-GPU entities like NvSwitches\n\n @param pDcgmHandle        IN: DCGM Handle\n @param groupId            IN: Group ID representing collection of one or more entities. Look at \\ref dcgmGroupCreate\n                               for details on creating the group. Alternatively, pass in the group id as\n                               \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs or\n                               \\a DCGM_GROUP_ALL_NVSWITCHES to perform the operation on all NvSwitches.\n @param fieldGroupId       IN: Fields to return data for.\n @param enumCB             IN: Callback to invoke for every field value update. Note that multiple updates can be\n                               returned in each invocation\n @param userData           IN: User data pointer to pass to the userData field of enumCB.\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n        - \\ref DCGM_ST_NOT_SUPPORTED        if one of the entities was from a non-GPU type\n        - \\ref DCGM_ST_BADPARAM             if a parameter is invalid\n"]
    pub unsafe fn dcgmGetLatestValues_v2(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        fieldGroupId: dcgmFieldGrp_t,
        enumCB: dcgmFieldValueEntityEnumeration_f,
        userData: *mut ::std::os::raw::c_void,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetLatestValues_v2
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle,
            groupId,
            fieldGroupId,
            enumCB,
            userData,
        )
    }
    #[doc = " Request latest cached field value for a GPU\n\n @param pDcgmHandle   IN: DCGM Handle\n @param gpuId         IN: Gpu ID representing the GPU for which the fields are being requested.\n @param fields        IN: Field IDs to return data for. See the definitions in dcgm_fields.h that start with DCGM_FI_.\n @param count         IN: Number of field IDs in fields[] array.\n @param values       OUT: Latest field values for the fields in fields[].\n"]
    pub unsafe fn dcgmGetLatestValuesForFields(
        &self,
        pDcgmHandle: dcgmHandle_t,
        gpuId: ::std::os::raw::c_int,
        fields: *mut ::std::os::raw::c_ushort,
        count: ::std::os::raw::c_uint,
        values: *mut dcgmFieldValue_v1,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetLatestValuesForFields
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle, gpuId, fields, count, values
        )
    }
    #[doc = " Request latest cached field value for a group of fields for a specific entity\n\n @param pDcgmHandle   IN: DCGM Handle\n @param entityGroup   IN: entity_group_t (e.g. switch)\n @param entityId      IN: entity ID representing the rntity for which the fields are being requested.\n @param fields        IN: Field IDs to return data for. See the definitions in dcgm_fields.h that start with DCGM_FI_.\n @param count         IN: Number of field IDs in fields[] array.\n @param values       OUT: Latest field values for the fields in fields[].\n"]
    pub unsafe fn dcgmEntityGetLatestValues(
        &self,
        pDcgmHandle: dcgmHandle_t,
        entityGroup: dcgm_field_entity_group_t,
        entityId: ::std::os::raw::c_int,
        fields: *mut ::std::os::raw::c_ushort,
        count: ::std::os::raw::c_uint,
        values: *mut dcgmFieldValue_v1,
    ) -> dcgmReturn_t {
        (self
            .dcgmEntityGetLatestValues
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle,
            entityGroup,
            entityId,
            fields,
            count,
            values,
        )
    }
    #[doc = " Request the latest cached or live field value for a list of fields for a group of entities\n\n Note: The returned entities are not guaranteed to be in any order. Reordering can occur internally\n       in order to optimize calls to the NVIDIA driver.\n\n @param pDcgmHandle   IN: DCGM Handle\n @param entities      IN: List of entities to get values for\n @param entityCount   IN: Number of entries in entities[]\n @param fields        IN: Field IDs to return data for. See the definitions in dcgm_fields.h that start with DCGM_FI_.\n @param fieldCount    IN: Number of field IDs in fields[] array.\n @param flags         IN: Optional flags that affect how this request is processed. Pass \\ref DCGM_FV_FLAG_LIVE_DATA\n                          here to retrieve a live driver value rather than a cached value. See that flag's\n                          documentation for caveats.\n @param values       OUT: Latest field values for the fields requested. This must be able to hold entityCount *\n                          fieldCount field value records.\n"]
    pub unsafe fn dcgmEntitiesGetLatestValues(
        &self,
        pDcgmHandle: dcgmHandle_t,
        entities: *mut dcgmGroupEntityPair_t,
        entityCount: ::std::os::raw::c_uint,
        fields: *mut ::std::os::raw::c_ushort,
        fieldCount: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
        values: *mut dcgmFieldValue_v2,
    ) -> dcgmReturn_t {
        (self
            .dcgmEntitiesGetLatestValues
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle,
            entities,
            entityCount,
            fields,
            fieldCount,
            flags,
            values,
        )
    }
    #[doc = "/\n/**\n Get a summary of the values for a field id over a period of time.\n\n @param pDcgmHandle       IN: DCGM Handle\n @param request       IN/OUT: a pointer to the struct detailing the request and containing the response\n\n @return\n       - \\ref DCGM_ST_OK                if the call was successful\n       - \\ref DCGM_ST_FIELD_UNSUPPORTED_BY_API if the field is not int64 or double type\n"]
    pub unsafe fn dcgmGetFieldSummary(
        &self,
        pDcgmHandle: dcgmHandle_t,
        request: *mut dcgmFieldSummaryRequest_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetFieldSummary
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, request)
    }
    #[doc = " This method is used to tell the DCGM module to update all the fields being watched.\n\n Note: If the if the operation mode was set to manual mode (DCGM_OPERATION_MODE_MANUAL) during\n initialization (\\ref dcgmInit), this method must be caused periodically to allow field value watches\n the opportunity to gather samples.\n\n @param pDcgmHandle           IN: DCGM Handle\n @param waitForUpdate         IN: Whether or not to wait for the update loop to complete before returning to the\n                                  caller 1=wait. 0=do not wait.\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n        - \\ref DCGM_ST_BADPARAM             if \\a waitForUpdate is invalid\n        - \\ref DCGM_ST_GENERIC_ERROR        if an unspecified DCGM error occurs\n"]
    pub unsafe fn dcgmUpdateAllFields(
        &self,
        pDcgmHandle: dcgmHandle_t,
        waitForUpdate: ::std::os::raw::c_int,
    ) -> dcgmReturn_t {
        (self
            .dcgmUpdateAllFields
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, waitForUpdate)
    }
    #[doc = " Request that DCGM start recording stats for fields that can be queried with dcgmGetPidInfo().\n\n Note that the first update of the field will not occur until the next field update cycle.\n To force a field update cycle, call dcgmUpdateAllFields(1).\n\n @param pDcgmHandle         IN: DCGM Handle\n @param groupId             IN: Group ID representing collection of one or more GPUs. Look at \\ref dcgmGroupCreate for\n                                details on creating the group. Alternatively, pass in the group id as\n                                \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs.\n @param updateFreq          IN: How often to update this field in usec\n @param maxKeepAge          IN: How long to keep data for this field in seconds\n @param maxKeepSamples      IN: Maximum number of samples to keep. 0=no limit\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n        - \\ref DCGM_ST_BADPARAM             if a parameter is invalid\n        - \\ref DCGM_ST_REQUIRES_ROOT        if the host engine is being run as non-root, and accounting mode could not\n                                            be enabled (requires root). Run \"nvidia-smi -am 1\" as root on the node\n                                            before starting DCGM to fix this.\n"]
    pub unsafe fn dcgmWatchPidFields(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        updateFreq: ::std::os::raw::c_longlong,
        maxKeepAge: f64,
        maxKeepSamples: ::std::os::raw::c_int,
    ) -> dcgmReturn_t {
        (self
            .dcgmWatchPidFields
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle,
            groupId,
            updateFreq,
            maxKeepAge,
            maxKeepSamples,
        )
    }
    #[doc = " Get information about all GPUs while the provided pid was running\n\n In order for this request to work, you must first call dcgmWatchPidFields() to\n make sure that DCGM is watching the appropriate field IDs that will be\n populated in pidInfo\n\n @param pDcgmHandle IN: DCGM Handle\n @param groupId     IN: Group ID representing collection of one or more GPUs. Look at \\ref dcgmGroupCreate\n                        for details on creating the group. Alternatively, pass in the group id as\n                        \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs.\n @param pidInfo IN/OUT: Structure to return information about pid in. pidInfo->pid must be set to the pid in question.\n                        pidInfo->version should be set to dcgmPidInfo_version.\n\n @return\n       - \\ref DCGM_ST_OK                  if the call was successful\n       - \\ref DCGM_ST_NO_DATA             if the PID did not run on any GPU\n"]
    pub unsafe fn dcgmGetPidInfo(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        pidInfo: *mut dcgmPidInfo_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetPidInfo
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, groupId, pidInfo)
    }
    #[doc = " Request that DCGM start recording stats for fields that are queried with dcgmJobGetStats()\n\n Note that the first update of the field will not occur until the next field update cycle.\n To force a field update cycle, call dcgmUpdateAllFields(1).\n\n @param pDcgmHandle         IN: DCGM Handle\n @param groupId             IN: Group ID representing collection of one or more GPUs. Look at \\ref dcgmGroupCreate for\n                                details on creating the group. Alternatively, pass in the group id as\n                                \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs.\n @param updateFreq          IN: How often to update this field in usec\n @param maxKeepAge          IN: How long to keep data for this field in seconds\n @param maxKeepSamples      IN: Maximum number of samples to keep. 0=no limit\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n        - \\ref DCGM_ST_BADPARAM             if a parameter is invalid\n        - \\ref DCGM_ST_REQUIRES_ROOT        if the host engine is being run as non-root, and\n                                            accounting mode could not be enabled (requires root).\n                                            Run \"nvidia-smi -am 1\" as root on the node before starting\n                                            DCGM to fix this.\n"]
    pub unsafe fn dcgmWatchJobFields(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        updateFreq: ::std::os::raw::c_longlong,
        maxKeepAge: f64,
        maxKeepSamples: ::std::os::raw::c_int,
    ) -> dcgmReturn_t {
        (self
            .dcgmWatchJobFields
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle,
            groupId,
            updateFreq,
            maxKeepAge,
            maxKeepSamples,
        )
    }
    #[doc = " This API is used by the client to notify DCGM about the job to be started. Should be invoked as\n part of job prologue\n\n @param pDcgmHandle       IN: DCGM Handle\n @param groupId           IN: Group ID representing collection of one or more GPUs. Look at \\ref dcgmGroupCreate for\n                              details on creating the group. Alternatively, pass in the group id as\n                              \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs.\n @param jobId             IN: User provided string to represent the job\n\n @return\n       - \\ref DCGM_ST_OK                  if the call was successful\n       - \\ref DCGM_ST_BADPARAM            if a parameter is invalid\n       - \\ref DCGM_ST_DUPLICATE_KEY       if the specified \\a jobId is already in use\n"]
    pub unsafe fn dcgmJobStartStats(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        jobId: *mut ::std::os::raw::c_char,
    ) -> dcgmReturn_t {
        (self
            .dcgmJobStartStats
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, groupId, jobId)
    }
    #[doc = " This API is used by the clients to notify DCGM to stop collecting stats for the job represented\n by job id. Should be invoked as part of job epilogue.\n The job Id remains available to view the stats at any point but cannot be used to start a new job.\n You must call dcgmWatchJobFields() before this call to enable watching of job\n\n @param pDcgmHandle       IN: DCGM Handle\n @param jobId             IN: User provided string to represent the job\n\n @return\n       - \\ref DCGM_ST_OK                  if the call was successful\n       - \\ref DCGM_ST_BADPARAM            if a parameter is invalid\n       - \\ref DCGM_ST_NO_DATA             if \\a jobId is not a valid job identifier.\n"]
    pub unsafe fn dcgmJobStopStats(
        &self,
        pDcgmHandle: dcgmHandle_t,
        jobId: *mut ::std::os::raw::c_char,
    ) -> dcgmReturn_t {
        (self
            .dcgmJobStopStats
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, jobId)
    }
    #[doc = " Get stats for the job identified by DCGM generated job id. The stats can be retrieved at any\n point when the job is in process.\n If you want to reuse this jobId, call \\ref dcgmJobRemove after this call.\n\n @param pDcgmHandle        IN: DCGM Handle\n @param jobId              IN: User provided string to represent the job\n @param pJobInfo       IN/OUT: Structure to return information about the job.<br> .version should be set to\n                               \\ref dcgmJobInfo_version before this call.\n\n @return\n       - \\ref DCGM_ST_OK                  if the call was successful\n       - \\ref DCGM_ST_BADPARAM            if a parameter is invalid\n       - \\ref DCGM_ST_NO_DATA             if \\a jobId is not a valid job identifier.\n       - \\ref DCGM_ST_VER_MISMATCH        if .version is not set or is invalid.\n"]
    pub unsafe fn dcgmJobGetStats(
        &self,
        pDcgmHandle: dcgmHandle_t,
        jobId: *mut ::std::os::raw::c_char,
        pJobInfo: *mut dcgmJobInfo_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmJobGetStats
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, jobId, pJobInfo)
    }
    #[doc = " This API tells DCGM to stop tracking the job given by jobId. After this call, you will no longer\n be able to call dcgmJobGetStats() on this jobId. However, you will be able to reuse jobId after\n this call.\n\n @param pDcgmHandle       IN: DCGM Handle\n @param jobId             IN: User provided string to represent the job\n\n @return\n       - \\ref DCGM_ST_OK                  if the call was successful\n       - \\ref DCGM_ST_BADPARAM            if a parameter is invalid\n       - \\ref DCGM_ST_NO_DATA             if \\a jobId is not a valid job identifier.\n"]
    pub unsafe fn dcgmJobRemove(
        &self,
        pDcgmHandle: dcgmHandle_t,
        jobId: *mut ::std::os::raw::c_char,
    ) -> dcgmReturn_t {
        (self
            .dcgmJobRemove
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, jobId)
    }
    #[doc = " This API tells DCGM to stop tracking all jobs. After this call, you will no longer\n be able to call dcgmJobGetStats() any jobs until you call dcgmJobStartStats again.\n You will be able to reuse any previously-used jobIds after this call.\n\n @param pDcgmHandle       IN: DCGM Handle\n\n @return\n       - \\ref DCGM_ST_OK                  if the call was successful\n       - \\ref DCGM_ST_BADPARAM            if a parameter is invalid"]
    pub unsafe fn dcgmJobRemoveAll(&self, pDcgmHandle: dcgmHandle_t) -> dcgmReturn_t {
        (self
            .dcgmJobRemoveAll
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle)
    }
    #[doc = " Enable the DCGM health check system for the given systems defined in \\ref dcgmHealthSystems_t\n\n @param pDcgmHandle        IN: DCGM Handle\n @param groupId            IN: Group ID representing collection of one or more entities. Look at \\ref dcgmGroupCreate\n                               for details on creating the group. Alternatively, pass in the group id as\n                               \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs or\n                               \\a DCGM_GROUP_ALL_NVSWITCHES to perform operation on all the NvSwitches.\n @param systems            IN: An enum representing systems that should be enabled for health checks logically OR'd\n                               together. Refer to \\ref dcgmHealthSystems_t for details.\n\n @return\n       - \\ref DCGM_ST_OK                  if the call was successful\n       - \\ref DCGM_ST_BADPARAM            if a parameter is invalid\n"]
    pub unsafe fn dcgmHealthSet(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        systems: dcgmHealthSystems_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmHealthSet
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, groupId, systems)
    }
    #[doc = " Enable the DCGM health check system for the given systems defined in \\ref dcgmHealthSystems_t\n\n Since DCGM 2.0\n\n @param pDcgmHandle                   IN: DCGM Handle\n @param healthSet                     IN: Parameters to use when setting health watches. See\n                                          \\ref dcgmHealthSetParams_v2 for the description of each parameter.\n\n @return\n       - \\ref DCGM_ST_OK                  if the call was successful\n       - \\ref DCGM_ST_BADPARAM            if a parameter is invalid"]
    pub unsafe fn dcgmHealthSet_v2(
        &self,
        pDcgmHandle: dcgmHandle_t,
        params: *mut dcgmHealthSetParams_v2,
    ) -> dcgmReturn_t {
        (self
            .dcgmHealthSet_v2
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, params)
    }
    #[doc = " Retrieve the current state of the DCGM health check system\n\n @param pDcgmHandle        IN: DCGM Handle\n @param groupId            IN: Group ID representing collection of one or more entities. Look at \\ref dcgmGroupCreate\n                               for details on creating the group. Alternatively, pass in the group id as\n                               \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs or\n                               \\a DCGM_GROUP_ALL_NVSWITCHES to perform operation on all the NvSwitches.\n @param systems           OUT: An integer representing the enabled systems for the given group Refer to\n                               \\ref dcgmHealthSystems_t for details.\n\n @return\n       - \\ref DCGM_ST_OK                  if the call was successful\n       - \\ref DCGM_ST_BADPARAM            if a parameter is invalid\n"]
    pub unsafe fn dcgmHealthGet(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        systems: *mut dcgmHealthSystems_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmHealthGet
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, groupId, systems)
    }
    #[doc = " Check the configured watches for any errors/failures/warnings that have occurred\n since the last time this check was invoked.  On the first call, stateful information\n about all of the enabled watches within a group is created but no error results are\n provided.  On subsequent calls, any error information will be returned.\n\n\n @param pDcgmHandle                   IN: DCGM Handle\n @param groupId                       IN: Group ID representing a collection of one or more entities.\n                                          Refer to \\ref dcgmGroupCreate for details on creating a group\n @param results                      OUT: A reference to the dcgmHealthResponse_t structure to populate.\n                                          results->version must be set to dcgmHealthResponse_version.\n\n @return\n       - \\ref DCGM_ST_OK                  if the call was successful\n       - \\ref DCGM_ST_BADPARAM            if a parameter is invalid\n       - \\ref DCGM_ST_VER_MISMATCH        if results->version is not dcgmHealthResponse_version\n"]
    pub unsafe fn dcgmHealthCheck(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        results: *mut dcgmHealthResponse_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmHealthCheck
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, groupId, results)
    }
    #[doc = " Set the current violation policy inside the policy manager.  Given the conditions within the\n \\ref dcgmPolicy_t structure, if a violation has occurred, subsequent action(s) may be performed to\n either report or contain the failure.\n\n @param pDcgmHandle        IN: DCGM Handle\n @param groupId            IN: Group ID representing collection of one or more GPUs. Look at \\ref dcgmGroupCreate for\n                               details on creating the group. Alternatively, pass in the group id as\n                               \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs.\n @param policy             IN: A reference to \\ref dcgmPolicy_t that will be applied to all GPUs in the group.\n @param statusHandle   IN/OUT: Resulting status for the operation.  Pass it as NULL if the detailed error information\n                               is not needed. Refer to \\ref dcgmStatusCreate for details on creating a status handle.\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n        - \\ref DCGM_ST_BADPARAM             if \\a groupId or \\a policy is invalid\n        - \\ref DCGM_ST_NOT_SUPPORTED        if any unsupported GPUs are part of the GPU group specified in groupId\n        - DCGM_ST_*                         a different error has occurred and is stored in \\a statusHandle.\n                                            Refer to \\ref dcgmReturn_t\n"]
    pub unsafe fn dcgmPolicySet(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        policy: *mut dcgmPolicy_t,
        statusHandle: dcgmStatus_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmPolicySet
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle, groupId, policy, statusHandle
        )
    }
    #[doc = " Get the current violation policy inside the policy manager. Given a groupId, a number of\n policy structures are retrieved.\n\n @param pDcgmHandle        IN: DCGM Handle\n @param groupId            IN: Group ID representing collection of one or more GPUs. Look at \\ref dcgmGroupCreate for\n                               details on creating the group. Alternatively, pass in the group id as\n                               \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs.\n @param count              IN: The size of the policy array.  This is the maximum number of policies that will be\n                               retrieved and ultimately should correspond to the number of GPUs specified in the\n                               group.\n @param policy             OUT: A reference to \\ref dcgmPolicy_t that will used as storage for the current policies\n                                applied to each GPU in the group.\n @param statusHandle    IN/OUT: Resulting status for the operation. Pass it as NULL if the detailed error information\n                                for the operation is not needed. Refer to \\ref dcgmStatusCreate for details on\n                                creating a status handle.\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n        - \\ref DCGM_ST_BADPARAM             if \\a groupId or \\a policy is invalid\n        - DCGM_ST_*                         a different error has occurred and is stored in \\a statusHandle.\n                                            Refer to \\ref dcgmReturn_t\n"]
    pub unsafe fn dcgmPolicyGet(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        count: ::std::os::raw::c_int,
        policy: *mut dcgmPolicy_t,
        statusHandle: dcgmStatus_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmPolicyGet
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle,
            groupId,
            count,
            policy,
            statusHandle,
        )
    }
    #[doc = " Register a function to be called when a specific policy condition (see \\ref dcgmPolicyCondition_t) has been\n violated.  This callback(s) will be called automatically when in DCGM_OPERATION_MODE_AUTO mode and only after\n dcgmPolicyTrigger when in DCGM_OPERATION_MODE_MANUAL mode.  All callbacks are made within a separate thread.\n\n @param pDcgmHandle        IN: DCGM Handle\n @param groupId            IN: Group ID representing collection of one or more GPUs. Look at \\ref dcgmGroupCreate for\n                               details on creating the group. Alternatively, pass in the group id as\n                               \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs.\n @param condition          IN: The set of conditions specified as an OR'd list (see \\ref dcgmPolicyCondition_t) for\n                               which to register a callback function\n @param callback           IN: A reference to a function that should be called should a violation occur.\n                               This function will be called prior to any actions specified by the policy are taken.\n @param userData           IN: User data pointer to pass to the userData field of callback\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n        - \\ref DCGM_ST_BADPARAM             if \\a groupId, \\a condition, is invalid, \\a callback, is NULL\n        - \\ref DCGM_ST_NOT_SUPPORTED        if any unsupported GPUs are part of the GPU group specified in groupId\n"]
    pub unsafe fn dcgmPolicyRegister_v2(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        condition: dcgmPolicyCondition_t,
        callback: fpRecvUpdates,
        userData: u64,
    ) -> dcgmReturn_t {
        (self
            .dcgmPolicyRegister_v2
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle,
            groupId,
            condition,
            callback,
            userData,
        )
    }
    #[doc = " Unregister a function to be called for a specific policy condition (see \\ref dcgmPolicyCondition_t).\n This function will unregister all callbacks for a given condition and handle.\n\n @param pDcgmHandle        IN: DCGM Handle\n @param groupId            IN: Group ID representing collection of one or more GPUs. Look at \\ref dcgmGroupCreate for\n                               details on creating the group. Alternatively, pass in the group id as\n                               \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs.\n @param condition          IN: The set of conditions specified as an OR'd list (see \\ref dcgmPolicyCondition_t) for\n                               which to unregister a callback function\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n        - \\ref DCGM_ST_BADPARAM             if \\a groupId, \\a condition, is invalid\n        - \\ref DCGM_ST_IN_USE               if callback from policy registeration is in progress\n"]
    pub unsafe fn dcgmPolicyUnregister(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        condition: dcgmPolicyCondition_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmPolicyUnregister
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, groupId, condition)
    }
    #[doc = " Inform the action manager to perform a manual validation of a group of GPUs on the system\n\n *************************************** DEPRECATED ***************************************\n\n @param pDcgmHandle        IN: DCGM Handle\n @param groupId            IN: Group ID representing collection of one or more GPUs. Look at \\ref dcgmGroupCreate for\n                               details on creating the group. Alternatively, pass in the group id as\n                               \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs.\n @param validate           IN: The validation to perform after the action.\n @param response          OUT: Result of the validation process. Refer to \\ref dcgmDiagResponse_t for details.\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n        - \\ref DCGM_ST_NOT_SUPPORTED        if running the specified \\a validate is not supported. This is usually due\n                                            to the Tesla recommended driver not being installed on the system.\n        - \\ref DCGM_ST_BADPARAM             if \\a groupId, \\a validate, or \\a statusHandle is invalid\n        - \\ref DCGM_ST_GENERIC_ERROR        an internal error has occurred\n        - \\ref DCGM_ST_GROUP_INCOMPATIBLE   if \\a groupId refers to a group of non-homogeneous GPUs. This is currently\n                                            not allowed.\n"]
    pub unsafe fn dcgmActionValidate(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        validate: dcgmPolicyValidation_t,
        response: *mut dcgmDiagResponse_v11,
    ) -> dcgmReturn_t {
        (self
            .dcgmActionValidate
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle, groupId, validate, response
        )
    }
    #[doc = " Inform the action manager to perform a manual validation of a group of GPUs on the system\n\n @param pDcgmHandle        IN: DCGM Handle\n @param drd                IN: Contains the group id, test names, test parameters, struct version, and the validation\n                               that should be performed. Look at \\ref dcgmGroupCreate for details on creating the\n                               group. Alternatively, pass in the group id as \\a DCGM_GROUP_ALL_GPUS to perform\n                               operation on all the GPUs.\n @param response          OUT: Result of the validation process. Refer to \\ref dcgmDiagResponse_t for details.\n                               Note: It's a caller's responsibility to make sure the response is zero-initialized,\n                                     except for the version field.\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n        - \\ref DCGM_ST_NOT_SUPPORTED        if running the specified \\a validate is not supported. This is usually\n                                            due to the Tesla recommended driver not being installed on the system.\n        - \\ref DCGM_ST_BADPARAM             if \\a groupId, \\a validate, or \\a statusHandle is invalid\n        - \\ref DCGM_ST_GENERIC_ERROR        an internal error has occurred\n        - \\ref DCGM_ST_GROUP_INCOMPATIBLE   if \\a groupId refers to a group of non-homogeneous GPUs. This is\n                                            currently not allowed."]
    pub unsafe fn dcgmActionValidate_v2(
        &self,
        pDcgmHandle: dcgmHandle_t,
        drd: *mut dcgmRunDiag_v10,
        response: *mut dcgmDiagResponse_v11,
    ) -> dcgmReturn_t {
        (self
            .dcgmActionValidate_v2
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, drd, response)
    }
    #[doc = " Run a diagnostic on a group of GPUs\n\n @param pDcgmHandle        IN: DCGM Handle\n @param groupId            IN: Group ID representing collection of one or more GPUs. Look at \\ref dcgmGroupCreate\n                               for details on creating the group. Alternatively, pass in the group id as\n                               \\a DCGM_GROUP_ALL_GPUS to perform operation on all the GPUs.\n @param diagLevel          IN: Diagnostic level to run\n @param diagResponse   IN/OUT: Result of running the DCGM diagnostic.<br>\n                               .version should be set to \\ref dcgmDiagResponse_version before this call.\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n        - \\ref DCGM_ST_NOT_SUPPORTED        if running the diagnostic is not supported. This is usually due to the\n                                            Tesla recommended driver not being installed on the system.\n        - \\ref DCGM_ST_BADPARAM             if a provided parameter is invalid or missing\n        - \\ref DCGM_ST_GENERIC_ERROR        an internal error has occurred\n        - \\ref DCGM_ST_GROUP_INCOMPATIBLE   if \\a groupId refers to a group of non-homogeneous GPUs. This is\n                                            currently not allowed.\n        - \\ref DCGM_ST_VER_MISMATCH         if .version is not set or is invalid.\n"]
    pub unsafe fn dcgmRunDiagnostic(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        diagLevel: dcgmDiagnosticLevel_t,
        diagResponse: *mut dcgmDiagResponse_v11,
    ) -> dcgmReturn_t {
        (self
            .dcgmRunDiagnostic
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle, groupId, diagLevel, diagResponse
        )
    }
    #[doc = " Inform the policy manager loop to perform an iteration and trigger the callbacks of any\n registered functions. Callback functions will be called from a separate thread as the calling function.\n\n Note: The GPU monitoring and management agent must call this method periodically if the operation\n mode is set to manual mode (DCGM_OPERATION_MODE_MANUAL) during initialization\n (\\ref dcgmInit).\n\n @param pDcgmHandle                   IN: DCGM Handle\n\n @return\n        - \\ref DCGM_ST_OK                   If the call was successful\n        - DCGM_ST_GENERIC_ERROR             The policy manager was unable to perform another iteration."]
    pub unsafe fn dcgmPolicyTrigger(&self, pDcgmHandle: dcgmHandle_t) -> dcgmReturn_t {
        (self
            .dcgmPolicyTrigger
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle)
    }
    #[doc = " Gets device workload power profile information and status.\n\n @param pDcgmHandle             IN: DCGM Handle\n @param gpuId                   IN: GPU Id corresponding to which topology information should be fetched\n @param profilesInfo           OUT: Information about each of the supported workload power profiles available on this\n                                    device\n @param profilesStatus         OUT: Currently active, requested, and enforced workload power profiles on this device\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful.\n        - \\ref DCGM_ST_BADPARAM             if \\a gpuId, \\a profileInfo, or \\a profileStatus were not valid.\n        - \\ref DCGM_ST_VER_MISMATCH         if profileInfo or profileStatus were not set to the correct versions.\n"]
    pub unsafe fn dcgmGetDeviceWorkloadPowerProfileInfo(
        &self,
        pDcgmHandle: dcgmHandle_t,
        gpuId: ::std::os::raw::c_uint,
        profilesInfo: *mut dcgmWorkloadPowerProfileProfilesInfo_v1,
        profileStatus: *mut dcgmDeviceWorkloadPowerProfilesStatus_v1,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetDeviceWorkloadPowerProfileInfo
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle,
            gpuId,
            profilesInfo,
            profileStatus,
        )
    }
    #[doc = " Gets device topology corresponding to the \\a gpuId.\n\n @param pDcgmHandle             IN: DCGM Handle\n @param gpuId                   IN: GPU Id corresponding to which topology information should be fetched\n @param pDcgmDeviceTopology IN/OUT: Topology information corresponding to \\a gpuId. pDcgmDeviceTopology->version must\n                                    be set to dcgmDeviceTopology_version before this call.\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful.\n        - \\ref DCGM_ST_BADPARAM             if \\a gpuId or \\a pDcgmDeviceTopology were not valid.\n        - \\ref DCGM_ST_VER_MISMATCH         if pDcgmDeviceTopology->version was not set to dcgmDeviceTopology_version.\n"]
    pub unsafe fn dcgmGetDeviceTopology(
        &self,
        pDcgmHandle: dcgmHandle_t,
        gpuId: ::std::os::raw::c_uint,
        pDcgmDeviceTopology: *mut dcgmDeviceTopology_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetDeviceTopology
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle, gpuId, pDcgmDeviceTopology
        )
    }
    #[doc = " Gets group topology corresponding to the \\a groupId.\n\n @param pDcgmHandle            IN: DCGM Handle\n @param groupId                IN: GroupId corresponding to which topology information should be fetched\n @param pDcgmGroupTopology IN/OUT: Topology information corresponding to \\a groupId. pDcgmgroupTopology->version must\n                                   be set to dcgmGroupTopology_version.\n @return\n        - \\ref DCGM_ST_OK             if the call was successful.\n        - \\ref DCGM_ST_BADPARAM       if \\a groupId or \\a pDcgmGroupTopology were not valid.\n        - \\ref DCGM_ST_VER_MISMATCH   if pDcgmgroupTopology->version was not set to dcgmGroupTopology_version.\n"]
    pub unsafe fn dcgmGetGroupTopology(
        &self,
        pDcgmHandle: dcgmHandle_t,
        groupId: dcgmGpuGrp_t,
        pDcgmGroupTopology: *mut dcgmGroupTopology_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmGetGroupTopology
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle, groupId, pDcgmGroupTopology
        )
    }
    #[doc = "/\n/**\n Retrieve the total amount of memory that the hostengine process is currently using.\n This measurement represents both the resident set size (what is currently in RAM) and\n the swapped memory that belongs to the process.\n\n @param pDcgmHandle        IN: DCGM Handle\n @param memoryInfo     IN/OUT: see \\ref dcgmIntrospectMemory_t. memoryInfo->version must be set to\n                               dcgmIntrospectMemory_version prior to this call.\n @param waitIfNoData       IN: if no metadata is gathered wait till this occurs (!0) or return DCGM_ST_NO_DATA (0)\n\n @return\n       - \\ref DCGM_ST_OK                   if the call was successful\n       - \\ref DCGM_ST_NOT_CONFIGURED       if metadata gathering state is \\a DCGM_INTROSPECT_STATE_DISABLED\n       - \\ref DCGM_ST_NO_DATA              if \\a waitIfNoData is false and metadata has not been gathered yet\n       - \\ref DCGM_ST_VER_MISMATCH         if memoryInfo->version is 0 or invalid.\n"]
    pub unsafe fn dcgmIntrospectGetHostengineMemoryUsage(
        &self,
        pDcgmHandle: dcgmHandle_t,
        memoryInfo: *mut dcgmIntrospectMemory_t,
        waitIfNoData: ::std::os::raw::c_int,
    ) -> dcgmReturn_t {
        (self
            .dcgmIntrospectGetHostengineMemoryUsage
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, memoryInfo, waitIfNoData)
    }
    #[doc = "/\n/**\n Retrieve the CPU utilization of the DCGM hostengine process.\n\n @param pDcgmHandle        IN: DCGM Handle\n @param cpuUtil        IN/OUT: see \\ref dcgmIntrospectCpuUtil_t. cpuUtil->version must be set to\n                               dcgmIntrospectCpuUtil_version prior to this call.\n @param waitIfNoData       IN: if no metadata is gathered wait till this occurs (!0) or return DCGM_ST_NO_DATA (0)\n\n @return\n       - \\ref DCGM_ST_OK                   if the call was successful\n       - \\ref DCGM_ST_NOT_CONFIGURED       if metadata gathering state is \\a DCGM_INTROSPECT_STATE_DISABLED\n       - \\ref DCGM_ST_NO_DATA              if \\a waitIfNoData is false and metadata has not been gathered yet\n       - \\ref DCGM_ST_VER_MISMATCH         if cpuUtil->version or execTime->version is 0 or invalid.\n"]
    pub unsafe fn dcgmIntrospectGetHostengineCpuUtilization(
        &self,
        pDcgmHandle: dcgmHandle_t,
        cpuUtil: *mut dcgmIntrospectCpuUtil_t,
        waitIfNoData: ::std::os::raw::c_int,
    ) -> dcgmReturn_t {
        (self
            .dcgmIntrospectGetHostengineCpuUtilization
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, cpuUtil, waitIfNoData)
    }
    #[doc = "/\n/**\n Get the best group of gpus from the specified bitmask according to topological proximity: cpuAffinity, NUMA\n node, and NVLink.\n\n @param pDcgmHandle        IN: DCGM Handle\n @param inputGpuIds        IN: a bitmask of which GPUs DCGM should consider. If some of the GPUs on the system are\n                               already in use, they shouldn't be included in the bitmask. 0 means that all of the GPUs\n                               in the system should be considered.\n @param numGpus            IN: the number of GPUs that are desired from inputGpuIds. If this number is greater than\n                               the number of healthy GPUs in inputGpuIds, then less than numGpus gpus will be\n                               specified in outputGpuIds.\n @param outputGpuIds      OUT: a bitmask of numGpus or fewer GPUs from inputGpuIds that represent the best placement\n                               available from inputGpuIds.\n @param hintFlags          IN: a bitmask of DCGM_TOPO_HINT_F_ #defines of hints that should be taken into account when\n                               assigning outputGpuIds.\n\n @return\n        - \\ref DCGM_ST_OK                   if the call was successful\n"]
    pub unsafe fn dcgmSelectGpusByTopology(
        &self,
        pDcgmHandle: dcgmHandle_t,
        inputGpuIds: u64,
        numGpus: u32,
        outputGpuIds: *mut u64,
        hintFlags: u64,
    ) -> dcgmReturn_t {
        (self
            .dcgmSelectGpusByTopology
            .as_ref()
            .expect("Expected function, got error."))(
            pDcgmHandle,
            inputGpuIds,
            numGpus,
            outputGpuIds,
            hintFlags,
        )
    }
    #[doc = "/\n/**\n Add a module to the denylist. This module will be prevented from being loaded\n if it hasn't been loaded already. Modules are lazy-loaded as they are used by\n DCGM APIs, so it's important to call this API soon after the host engine has been started.\n You can also pass --denylist-modules to the nv-hostengine binary to make sure modules\n get add to the denylist immediately after the host engine starts up.\n\n @param pDcgmHandle        IN: DCGM Handle\n @param moduleId           IN: ID of the module to denylist. Use \\ref dcgmModuleGetStatuses to get a list of valid\n                               module IDs.\n\n @return\n        - \\ref DCGM_ST_OK         if the module has been add to the denylist.\n        - \\ref DCGM_ST_IN_USE     if the module has already been loaded and cannot add to the denylist.\n        - \\ref DCGM_ST_BADPARAM   if a parameter is missing or bad.\n"]
    pub unsafe fn dcgmModuleDenylist(
        &self,
        pDcgmHandle: dcgmHandle_t,
        moduleId: dcgmModuleId_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmModuleDenylist
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, moduleId)
    }
    #[doc = "/\n/**\n Get the status of all of the DCGM modules.\n\n @param pDcgmHandle        IN: DCGM Handle\n @param moduleStatuses    OUT: Module statuses.<br>\n                               .version should be set to dcgmModuleStatuses_version upon calling.\n\n @return\n        - \\ref DCGM_ST_OK         if the request succeeds.\n        - \\ref DCGM_ST_BADPARAM   if a parameter is missing or bad.\n"]
    pub unsafe fn dcgmModuleGetStatuses(
        &self,
        pDcgmHandle: dcgmHandle_t,
        moduleStatuses: *mut dcgmModuleGetStatuses_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmModuleGetStatuses
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, moduleStatuses)
    }
    #[doc = "/\n/**\n Get all of the profiling metric groups for a given GPU group.\n\n Profiling metrics are watched in groups of fields that are all watched together. For instance, if you want\n to watch DCGM_FI_PROF_GR_ENGINE_ACTIVITY, this might also be in the same group as DCGM_FI_PROF_SM_EFFICIENCY.\n Watching this group would result in DCGM storing values for both of these metrics.\n\n Some groups cannot be watched concurrently as others as they utilize the same hardware resource. For instance,\n you may not be able to watch DCGM_FI_PROF_TENSOR_OP_UTIL at the same time as DCGM_FI_PROF_GR_ENGINE_ACTIVITY\n on your hardware. At the same time, you may be able to watch DCGM_FI_PROF_TENSOR_OP_UTIL at the same time as\n DCGM_FI_PROF_NVLINK_TX_DATA.\n\n Metrics that can be watched concurrently will have different .majorId fields in their dcgmProfMetricGroupInfo_t\n\n See \\ref dcgmGroupCreate for details on creating a GPU group\n See \\ref dcgmWatchFields to actually watch the underlying profiling fields\n\n @param pDcgmHandle        IN: DCGM Handle\n @param metricGroups   IN/OUT: Metric groups supported for metricGroups->groupId.<br>\n                               metricGroups->version should be set to dcgmProfGetMetricGroups_version upon calling.\n\n @return\n        - \\ref DCGM_ST_OK                     if the request succeeds.\n        - \\ref DCGM_ST_BADPARAM               if a parameter is missing or bad.\n        - \\ref DCGM_ST_GROUP_INCOMPATIBLE     if metricGroups->groupId's GPUs are not identical GPUs.\n        - \\ref DCGM_ST_NOT_SUPPORTED          if profiling metrics are not supported for the given GPU group.\n"]
    pub unsafe fn dcgmProfGetSupportedMetricGroups(
        &self,
        pDcgmHandle: dcgmHandle_t,
        metricGroups: *mut dcgmProfGetMetricGroups_t,
    ) -> dcgmReturn_t {
        (self
            .dcgmProfGetSupportedMetricGroups
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, metricGroups)
    }
    #[doc = " Pause profiling activities in DCGM. This should be used when you are monitoring profiling fields\n from DCGM but want to be able to still run developer tools like nvprof, nsight systems, and nsight compute.\n Profiling fields start with DCGM_PROF_ and are in the field ID range 1001-1012.\n\n Call this API before you launch one of those tools and dcgmProfResume() after the tool has completed.\n\n DCGM will save BLANK values while profiling is paused.\n\n Calling this while profiling activities are already paused is fine and will be treated as a no-op.\n\n @param pDcgmHandle        IN: DCGM Handle\n\n @return\n        - \\ref DCGM_ST_OK                   If the call was successful.\n        - \\ref DCGM_ST_BADPARAM             if a parameter is invalid.\n"]
    pub unsafe fn dcgmProfPause(&self, pDcgmHandle: dcgmHandle_t) -> dcgmReturn_t {
        (self
            .dcgmProfPause
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle)
    }
    #[doc = " Resume profiling activities in DCGM that were previously paused with dcgmProfPause().\n\n Call this API after you have completed running other NVIDIA developer tools to reenable DCGM\n profiling metrics.\n\n DCGM will save BLANK values while profiling is paused.\n\n Calling this while profiling activities have already been resumed is fine and will be treated as a no-op.\n\n @param pDcgmHandle        IN: DCGM Handle\n\n @return\n        - \\ref DCGM_ST_OK                   If the call was successful.\n        - \\ref DCGM_ST_BADPARAM             if a parameter is invalid.\n"]
    pub unsafe fn dcgmProfResume(&self, pDcgmHandle: dcgmHandle_t) -> dcgmReturn_t {
        (self
            .dcgmProfResume
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle)
    }
    #[doc = " Adds fake GPU instances and or compute instances for testing purposes. The entity IDs specified for\n the GPU instances and compute instances are only guaranteed to be used by DCGM if MIG mode is not active.\n\n NOTE: this API will not work on a real system reading actual values from NVML, and it may even cause\n the real instances to malfunction. This API is for testing purposes only.\n\n @param pDcgmHandle        IN: DCGM Handle\n @param hierarchy\n\n @return\n        - \\ref DCGM_ST_OK\n"]
    pub unsafe fn dcgmAddFakeInstances(
        &self,
        pDcgmHandle: dcgmHandle_t,
        hierarchy: *mut dcgmMigHierarchy_v2,
    ) -> dcgmReturn_t {
        (self
            .dcgmAddFakeInstances
            .as_ref()
            .expect("Expected function, got error."))(pDcgmHandle, hierarchy)
    }
    pub unsafe fn dcgmErrorMeta(&self) -> *mut [dcgm_error_meta_t; 0usize] {
        *self
            .dcgmErrorMeta
            .as_ref()
            .expect("Expected variable, got error.")
    }
    pub unsafe fn dcgmErrorGetPriorityByCode(
        &self,
        code: ::std::os::raw::c_uint,
    ) -> dcgmErrorSeverity_t {
        (self
            .dcgmErrorGetPriorityByCode
            .as_ref()
            .expect("Expected function, got error."))(code)
    }
    pub unsafe fn dcgmErrorGetCategoryByCode(
        &self,
        code: ::std::os::raw::c_uint,
    ) -> dcgmErrorCategory_t {
        (self
            .dcgmErrorGetCategoryByCode
            .as_ref()
            .expect("Expected function, got error."))(code)
    }
    pub unsafe fn dcgmErrorGetFormatMsgByCode(
        &self,
        code: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char {
        (self
            .dcgmErrorGetFormatMsgByCode
            .as_ref()
            .expect("Expected function, got error."))(code)
    }
    pub unsafe fn dcgmGetErrorMeta(&self, error: dcgmError_t) -> *const dcgm_error_meta_t {
        (self
            .dcgmGetErrorMeta
            .as_ref()
            .expect("Expected function, got error."))(error)
    }
}
